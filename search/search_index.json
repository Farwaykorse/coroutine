{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Home/","text":"The document follows master branch Welcome to the luncliff/coroutine wiki! Please explore the pages with this link(GitHub Pages) If you have opinion for the docs, please create an issue and suggest your idea. Let me hear you and write more helpful contents. :D First with the C++ 20 Coroutines? If you're longing for the good references , visit the MattPD's collection ! If you want to run it now , there is a little example(Compiler Explorer) Developer Note This example project started with the post in 2017.02 . Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine(Eng) (\ud55c\uad6d\uc5b4) - the PDF is here! Articles Awaitable event using coroutine, epoll , and eventfd Designing the coroutine channel Combining C++ coroutines and pthread_create Russian Roulette and C++ Coroutines Windows DLL linking issues(WIP) Library Features Currently, I'm refining/rewriting all notes. Please check the test codes instead of the pages. Really sorry for those blanks :( Please check the navigation tab to explore the features. You can run them using the test codes in this repo. Clone the master branch and start your dive! :)","title":"Home"},{"location":"Home/#first-with-the-c-20-coroutines","text":"If you're longing for the good references , visit the MattPD's collection ! If you want to run it now , there is a little example(Compiler Explorer)","title":"First with the C++ 20 Coroutines?"},{"location":"Home/#developer-note","text":"This example project started with the post in 2017.02 . Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine(Eng) (\ud55c\uad6d\uc5b4) - the PDF is here! Articles Awaitable event using coroutine, epoll , and eventfd Designing the coroutine channel Combining C++ coroutines and pthread_create Russian Roulette and C++ Coroutines Windows DLL linking issues(WIP)","title":"Developer Note"},{"location":"Home/#library-features","text":"Currently, I'm refining/rewriting all notes. Please check the test codes instead of the pages. Really sorry for those blanks :( Please check the navigation tab to explore the features. You can run them using the test codes in this repo. Clone the master branch and start your dive! :)","title":"Library Features"},{"location":"_Footer/","text":"This work is licensed under a Creative Commons Attribution 4.0 International License .","title":" Footer"},{"location":"work-in-progress/","text":"","title":"coroutine/concepts.hpp"},{"location":"articles/awaitable-event/","text":"Awaitable event using the coroutine, epoll , and eventfd commit: ad1e682f The note explains the detail of event in coroutine/concrt.h Summary Look & feel of the interface via test code . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); } Note Motivation It would be convenient if there is a simple event type for co_await operator. Linux system's eventfd might be able to do the work. Requirement The requirement for the event type is simple. It doesn\u2019t support copy construction/assignment It doesn\u2019t support move construction/assignment The type can\u2019t be inherited( final ) It can be an operand of co_await operator The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. The first 3 requirement is quite strict, but it\u2019s for simplicity. Normally it won\u2019t be that hazardous for move operation. But moving from coroutine\u2019s frame to another space is a tricky situation. So I\u2019ve banned move semantics to prevent misusage like that. Design Win32 API supports internal thread pool , but Linux system API does not. So user code has to poll those created events. Fortunately, Linux supports epoll to allow the behavior. We can derive 2 behavior constraint from the interface limitation. To acquire a list of signaled events, user code has to perform a polling operation Limitation from epoll \u2019s use-case User has to resume coroutines that are suspended for an event object Limitation from coroutine_handle<void> and absence of embedded thread pool/APC support This was the rough version of the interface type & function. // Awaitable event type. class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // it's lightweight ! public : event (); ~ event (); void set (); bool await_ready () const ; void await_suspend ( coroutine_handle < void > coro ); void await_resume (); }; // Enumerate all suspended coroutines that are waiting for signaled events. auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; coro::enumerable<T> is my own implementation of the generator<T> in <experimental/generator> state is a space for eventfd , and signaled_event_tasks performs polling operation on the epoll file descriptor. Concerns You may think about why I didn\u2019t adopt design like io_context in Boost ASIO . Which provides an explicit point of creation and polling operation. For instance, with Boost ASIO, user code must create objects(e.g, socket) via boost::asio::io_context object. // see: https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/allocation/server.cpp class server { private : boost :: asio :: io_context & io_context_ ; tcp :: acceptor acceptor_ ; public : server ( boost :: asio :: io_context & io_context , short port ) : io_context_ ( io_context ), acceptor_ ( io_context , tcp :: endpoint ( tcp :: v4 (), port )) // <------ { session_ptr new_session ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } void handle_accept ( session_ptr new_session , const boost :: system :: error_code & error ) { if ( ! error ) { new_session -> start (); } new_session . reset ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } }; int main ( int argc , char * argv []) { try { // ... boost :: asio :: io_context io_context ; // <------ server s ( io_context , atoi ( argv [ 1 ])); io_context . run (); // <------ } catch ( std :: exception & e ) { std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; } As you can see, such design enforces to use reference in construction like server \u2019s constructor. Since there might be multiple instances of server in one program, this is sound and appropriate. However, event is used in system level, and we don\u2019t have to consider the owner of event objects because it is always system itself. This is why I didn\u2019t designed some type like event_context . Therefore, it will be enough to replace io_context.run() to signaled_event_tasks() . Implementation Each description is based on the actual code. In this note, I will explain with a simplified code. (skip some header, exception spec, etc.) Wrapping epoll Polling epoll Event interface Event state managment Event await operations Wrapping epoll linux/event_poll.h linux/event_poll.cpp I don't prefer writing wrapper for the system API, but I have another feature(networking) that uses it. Before the start, if you're not familiar with epoll , I do recommend you to find some articles and read them first. (I'm sorry!) Ok, let me start ... The wrapper follows RAII and provides some member functions. try_add : add or modify given epoll_event using epoll_ctl remove : epoll_ctl with EPOLL_CTL_DEL wait : wait for epoll_event s and allows iterate them for each epoll_wait #include <fcntl.h> #include <sys/epoll.h> #include <unistd.h> struct event_poll_t final : no_copy_move { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () ; ~ event_poll_t () ; void try_add ( uint64_t fd , epoll_event & req ) ; void remove ( uint64_t fd ); auto wait ( int timeout ) -> coro :: enumerable < epoll_event > ; }; As you can expect, it internally allocates an array to receive events from epoll_wait event_poll_t :: event_poll_t () : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () { close ( epfd ); } With the RAII, epoll_ctl can be wrapped with exception throwing code. You might be able to write your own version if you hate using the exception. void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try again with mod goto TRY_OP ; } // failed throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl EPOLL_CTL_DEL\" }; } It's not that complicated :) Polling epoll linux/event_poll.cpp Since event_poll_t is internal type, it is free to co_yield internal type objects like epoll_event . Type for the wait timeout uses int instead of chrono::duration because epoll_wait allows negative( -1 ) timeout. auto event_poll_t :: wait ( int timeout ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } In another translation unit, signaled_event_tasks queries the event_poll_t and yield coroutine handles from the user data in epoll_event . // signaled event list event_poll_t selist {}; auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Ok, now user code will invoke the function to acquire coroutines with the signaled event. Since its return type is coroutine generator, they can use for statement like the following test code . TEST_CASE ( \"wait for one event\" , \"[event]\" ) { // ... for ( auto task : signaled_event_tasks ()) { task . resume (); // ... } // ... } Event interface coroutine/concrt.h Now, it's time to implement event type. I will write some private member functions for each of await_ready , await_suspend , and await_resume . You may ask why I'm not implementing await_* functions directly. Well, that's because I've met an issue that exporting await_* functions for DLL leads to an internal compiler error . At least vc140 and vc141 did in my experience. My approach is to export those interface functions as private and redirecting to them using public functions to allow co_await statement // note: // _INTERFACE_ is __declspec(dllexport) or __attribute__((visibility(\"default\"))) class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // <--- will explain in next section private : _INTERFACE_ void on_suspend ( task ) ; _INTERFACE_ bool is_ready () const ; _INTERFACE_ void on_resume () ; public : _INTERFACE_ event () ; _INTERFACE_ ~ event () ; // signal the event object _INTERFACE_ void set () ; // ... redirect to private member functions safely ... bool await_ready () const { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) { return this -> on_suspend ( coro ); } void await_resume () { return this -> on_resume (); } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Its member functions will be explained below. Before that, let's see how the type implemented constructor and destructor . It's not complicated! event :: event () : state {} { const auto fd = eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } You can see a weird function, get_eventfd . Event's state managment Just like the code above, event 's state is from eventfd function. However, we need a piece of information to estimate the event is signaled . class event final : no_copy_move { private : uint64_t state ; }; Instead of using an internal counter of eventfd , I used a bit mask to distinguish that the event object is signaled . Please follow the comments. I wrote carefully! // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) { return static_cast < int64_t > ( ~ emask & state ); } uint64_t make_signaled ( int64_t efd ) ; Was the comment enough? With those helper functions, set operation becomes really simple. void event :: set () { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); state = make_signaled ( fd ); // if it didn't throwed // it's signaled state from now } Let me remind you of one of the requirements. For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. Let's just assume that our event 's fd is already registered to epoll . To make epoll return this event in epoll_wait , we will use write . And, of course, bit masking must come after the success of the operation! uint64_t make_signaled ( int64_t efd ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd auto sz = write ( efd , & efd , sizeof ( efd )); if ( sz == - 1 ) throw system_error { errno , system_category (), \"write\" }; return emask | static_cast < uint64_t > ( efd ); } Remember that we flagged EFD_NONBLOCK for eventfd function in the constructor. It was intended :) Event's await operations The last part of the implementation is for co_await statement. await_ready and await_resume is simple with the masking function. bool event :: is_ready () const { return is_signaled ( state ); } void event :: on_resume () { // make non-signaled state this -> state = static_cast < decltype ( state ) > ( get_eventfd ( state )); } The transition to non-signaled state is based on the requirement. And after set member function, await_ready will return true and will bypass await_suspend . The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend . Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement . Now, our keystone function is like this. We declared global variable with event_poll_t type when writing signaled_event_tasks . When the coroutine enters await_suspend , we have to send the coroutine_handle<void> to the event_poll_t . // signaled event list. event_poll_t selist {}; void event :: on_suspend ( task t ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded // to `signaled_event_tasks` by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } Here, we use epoll_event 's user data to save the coroutine frame's address. Compare the code with the implementation of the signaled_event_tasks below. It constructs coroutine handle from e.data.ptr . auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Summary for the implementation It wasn't that hard to combine coroutine with epoll and evnetfd . Let's cover the event again. // event type uses `eventfd` and bit masking for state check class event final : no_copy_move { public : using task = coroutine_handle < void > ; // becomes user data of `epoll_event` private : uint64_t state ; // msb + file descriptor public : event (); // create fd with `eventfd` ~ event (); // `close` the fd // if it's signaled (msb is 1), no suspend bool await_ready (); // bind current fd to epoll // and its epoll_event will hold the coroutine's handle void await_suspend ( coroutine_handle < void > coro ); // make non-signaled (reset msb to 0) void await_resume (); // if there is a suspended coroutine, // it means that the event's fd is alreadty registered via `await_suspend` // so we will invoke `write` for the fd. // `epoll` in the `signaled_event_tasks` will report that using `epoll_wait` // if it's not suspended (== no waiting coroutine), // `write` on it won't matter void set (); }; the exported function signaled_event_tasks allows user code to acquire suspended(event-waiting) coroutines. It might be unsatisfying that those coroutines are not resumed automatically, but if we already have a main loop for event handling, this function can be placed at the point without concerns. // access to hidden(global) `epoll` and invoke `epoll_wait`. // `epoll_wait` will return `epoll_event`s with `coroutine_handle<void>` // this function extracts and yields them to caller auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Whoa, that's all for the implementation details. Conclusion Now we can write a coroutine code like the summary section. epoll and eventfd is simple enough to use, but almost all of their examples use thread(or system process). With the C++ 20 coroutine, we can use the pair in a more graceful manner . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } // we must enter the loop REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Awaitable event using the coroutine, epoll and eventfd"},{"location":"articles/awaitable-event/#awaitable-event-using-the-coroutine-epoll-and-eventfd","text":"commit: ad1e682f The note explains the detail of event in coroutine/concrt.h","title":"Awaitable event using the coroutine, epoll, and eventfd"},{"location":"articles/awaitable-event/#summary","text":"Look & feel of the interface via test code . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Summary"},{"location":"articles/awaitable-event/#note","text":"","title":"Note"},{"location":"articles/awaitable-event/#motivation","text":"It would be convenient if there is a simple event type for co_await operator. Linux system's eventfd might be able to do the work.","title":"Motivation"},{"location":"articles/awaitable-event/#requirement","text":"The requirement for the event type is simple. It doesn\u2019t support copy construction/assignment It doesn\u2019t support move construction/assignment The type can\u2019t be inherited( final ) It can be an operand of co_await operator The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. The first 3 requirement is quite strict, but it\u2019s for simplicity. Normally it won\u2019t be that hazardous for move operation. But moving from coroutine\u2019s frame to another space is a tricky situation. So I\u2019ve banned move semantics to prevent misusage like that.","title":"Requirement"},{"location":"articles/awaitable-event/#design","text":"Win32 API supports internal thread pool , but Linux system API does not. So user code has to poll those created events. Fortunately, Linux supports epoll to allow the behavior. We can derive 2 behavior constraint from the interface limitation. To acquire a list of signaled events, user code has to perform a polling operation Limitation from epoll \u2019s use-case User has to resume coroutines that are suspended for an event object Limitation from coroutine_handle<void> and absence of embedded thread pool/APC support This was the rough version of the interface type & function. // Awaitable event type. class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // it's lightweight ! public : event (); ~ event (); void set (); bool await_ready () const ; void await_suspend ( coroutine_handle < void > coro ); void await_resume (); }; // Enumerate all suspended coroutines that are waiting for signaled events. auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; coro::enumerable<T> is my own implementation of the generator<T> in <experimental/generator> state is a space for eventfd , and signaled_event_tasks performs polling operation on the epoll file descriptor.","title":"Design"},{"location":"articles/awaitable-event/#concerns","text":"You may think about why I didn\u2019t adopt design like io_context in Boost ASIO . Which provides an explicit point of creation and polling operation. For instance, with Boost ASIO, user code must create objects(e.g, socket) via boost::asio::io_context object. // see: https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/allocation/server.cpp class server { private : boost :: asio :: io_context & io_context_ ; tcp :: acceptor acceptor_ ; public : server ( boost :: asio :: io_context & io_context , short port ) : io_context_ ( io_context ), acceptor_ ( io_context , tcp :: endpoint ( tcp :: v4 (), port )) // <------ { session_ptr new_session ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } void handle_accept ( session_ptr new_session , const boost :: system :: error_code & error ) { if ( ! error ) { new_session -> start (); } new_session . reset ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } }; int main ( int argc , char * argv []) { try { // ... boost :: asio :: io_context io_context ; // <------ server s ( io_context , atoi ( argv [ 1 ])); io_context . run (); // <------ } catch ( std :: exception & e ) { std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; } As you can see, such design enforces to use reference in construction like server \u2019s constructor. Since there might be multiple instances of server in one program, this is sound and appropriate. However, event is used in system level, and we don\u2019t have to consider the owner of event objects because it is always system itself. This is why I didn\u2019t designed some type like event_context . Therefore, it will be enough to replace io_context.run() to signaled_event_tasks() .","title":"Concerns"},{"location":"articles/awaitable-event/#implementation","text":"Each description is based on the actual code. In this note, I will explain with a simplified code. (skip some header, exception spec, etc.) Wrapping epoll Polling epoll Event interface Event state managment Event await operations","title":"Implementation"},{"location":"articles/awaitable-event/#wrapping-epoll","text":"linux/event_poll.h linux/event_poll.cpp I don't prefer writing wrapper for the system API, but I have another feature(networking) that uses it. Before the start, if you're not familiar with epoll , I do recommend you to find some articles and read them first. (I'm sorry!) Ok, let me start ... The wrapper follows RAII and provides some member functions. try_add : add or modify given epoll_event using epoll_ctl remove : epoll_ctl with EPOLL_CTL_DEL wait : wait for epoll_event s and allows iterate them for each epoll_wait #include <fcntl.h> #include <sys/epoll.h> #include <unistd.h> struct event_poll_t final : no_copy_move { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () ; ~ event_poll_t () ; void try_add ( uint64_t fd , epoll_event & req ) ; void remove ( uint64_t fd ); auto wait ( int timeout ) -> coro :: enumerable < epoll_event > ; }; As you can expect, it internally allocates an array to receive events from epoll_wait event_poll_t :: event_poll_t () : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () { close ( epfd ); } With the RAII, epoll_ctl can be wrapped with exception throwing code. You might be able to write your own version if you hate using the exception. void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try again with mod goto TRY_OP ; } // failed throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl EPOLL_CTL_DEL\" }; } It's not that complicated :)","title":"Wrapping epoll"},{"location":"articles/awaitable-event/#polling-epoll","text":"linux/event_poll.cpp Since event_poll_t is internal type, it is free to co_yield internal type objects like epoll_event . Type for the wait timeout uses int instead of chrono::duration because epoll_wait allows negative( -1 ) timeout. auto event_poll_t :: wait ( int timeout ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } In another translation unit, signaled_event_tasks queries the event_poll_t and yield coroutine handles from the user data in epoll_event . // signaled event list event_poll_t selist {}; auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Ok, now user code will invoke the function to acquire coroutines with the signaled event. Since its return type is coroutine generator, they can use for statement like the following test code . TEST_CASE ( \"wait for one event\" , \"[event]\" ) { // ... for ( auto task : signaled_event_tasks ()) { task . resume (); // ... } // ... }","title":"Polling epoll"},{"location":"articles/awaitable-event/#event-interface","text":"coroutine/concrt.h Now, it's time to implement event type. I will write some private member functions for each of await_ready , await_suspend , and await_resume . You may ask why I'm not implementing await_* functions directly. Well, that's because I've met an issue that exporting await_* functions for DLL leads to an internal compiler error . At least vc140 and vc141 did in my experience. My approach is to export those interface functions as private and redirecting to them using public functions to allow co_await statement // note: // _INTERFACE_ is __declspec(dllexport) or __attribute__((visibility(\"default\"))) class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // <--- will explain in next section private : _INTERFACE_ void on_suspend ( task ) ; _INTERFACE_ bool is_ready () const ; _INTERFACE_ void on_resume () ; public : _INTERFACE_ event () ; _INTERFACE_ ~ event () ; // signal the event object _INTERFACE_ void set () ; // ... redirect to private member functions safely ... bool await_ready () const { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) { return this -> on_suspend ( coro ); } void await_resume () { return this -> on_resume (); } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Its member functions will be explained below. Before that, let's see how the type implemented constructor and destructor . It's not complicated! event :: event () : state {} { const auto fd = eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } You can see a weird function, get_eventfd .","title":"Event interface"},{"location":"articles/awaitable-event/#events-state-managment","text":"Just like the code above, event 's state is from eventfd function. However, we need a piece of information to estimate the event is signaled . class event final : no_copy_move { private : uint64_t state ; }; Instead of using an internal counter of eventfd , I used a bit mask to distinguish that the event object is signaled . Please follow the comments. I wrote carefully! // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) { return static_cast < int64_t > ( ~ emask & state ); } uint64_t make_signaled ( int64_t efd ) ; Was the comment enough? With those helper functions, set operation becomes really simple. void event :: set () { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); state = make_signaled ( fd ); // if it didn't throwed // it's signaled state from now } Let me remind you of one of the requirements. For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. Let's just assume that our event 's fd is already registered to epoll . To make epoll return this event in epoll_wait , we will use write . And, of course, bit masking must come after the success of the operation! uint64_t make_signaled ( int64_t efd ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd auto sz = write ( efd , & efd , sizeof ( efd )); if ( sz == - 1 ) throw system_error { errno , system_category (), \"write\" }; return emask | static_cast < uint64_t > ( efd ); } Remember that we flagged EFD_NONBLOCK for eventfd function in the constructor. It was intended :)","title":"Event's state managment"},{"location":"articles/awaitable-event/#events-await-operations","text":"The last part of the implementation is for co_await statement. await_ready and await_resume is simple with the masking function. bool event :: is_ready () const { return is_signaled ( state ); } void event :: on_resume () { // make non-signaled state this -> state = static_cast < decltype ( state ) > ( get_eventfd ( state )); } The transition to non-signaled state is based on the requirement. And after set member function, await_ready will return true and will bypass await_suspend . The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend . Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement . Now, our keystone function is like this. We declared global variable with event_poll_t type when writing signaled_event_tasks . When the coroutine enters await_suspend , we have to send the coroutine_handle<void> to the event_poll_t . // signaled event list. event_poll_t selist {}; void event :: on_suspend ( task t ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded // to `signaled_event_tasks` by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } Here, we use epoll_event 's user data to save the coroutine frame's address. Compare the code with the implementation of the signaled_event_tasks below. It constructs coroutine handle from e.data.ptr . auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } }","title":"Event's await operations"},{"location":"articles/awaitable-event/#summary-for-the-implementation","text":"It wasn't that hard to combine coroutine with epoll and evnetfd . Let's cover the event again. // event type uses `eventfd` and bit masking for state check class event final : no_copy_move { public : using task = coroutine_handle < void > ; // becomes user data of `epoll_event` private : uint64_t state ; // msb + file descriptor public : event (); // create fd with `eventfd` ~ event (); // `close` the fd // if it's signaled (msb is 1), no suspend bool await_ready (); // bind current fd to epoll // and its epoll_event will hold the coroutine's handle void await_suspend ( coroutine_handle < void > coro ); // make non-signaled (reset msb to 0) void await_resume (); // if there is a suspended coroutine, // it means that the event's fd is alreadty registered via `await_suspend` // so we will invoke `write` for the fd. // `epoll` in the `signaled_event_tasks` will report that using `epoll_wait` // if it's not suspended (== no waiting coroutine), // `write` on it won't matter void set (); }; the exported function signaled_event_tasks allows user code to acquire suspended(event-waiting) coroutines. It might be unsatisfying that those coroutines are not resumed automatically, but if we already have a main loop for event handling, this function can be placed at the point without concerns. // access to hidden(global) `epoll` and invoke `epoll_wait`. // `epoll_wait` will return `epoll_event`s with `coroutine_handle<void>` // this function extracts and yields them to caller auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Whoa, that's all for the implementation details.","title":"Summary for the implementation"},{"location":"articles/awaitable-event/#conclusion","text":"Now we can write a coroutine code like the summary section. epoll and eventfd is simple enough to use, but almost all of their examples use thread(or system process). With the C++ 20 coroutine, we can use the pair in a more graceful manner . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } // we must enter the loop REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Conclusion"},{"location":"articles/combining-coroutines-and-pthread_create/","text":"Combining C++ Coroutines and pthread_create commit: 93ed8748 Some system functions use callback and an argument in void* type. In this article, I'm going to cover how such functions can be wrapped with co_await The base of examples here is my experience to try something like CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" with the POSIX threads. If you are a beginner, please do read the article about promise_type by Lewiss Baker . The article will enhance your understanding greatly. Creating a new thread Design What I'm going to try is creating a new thread in a simple manner. Traditionally we had to separate the step before/after pthread_create . To do so, we must write an additional function which is executed on the new thread. Like the thread_start in the pthread_create manual . But co_await can glue two routines into one. Let's see how it looks like. void per_thread_task (); auto work_on_new_thread ( pthread_t & tid , const pthread_attr_t * attr ) -> no_return { // this line is executed on the spawner thread co_await spawn_pthread ( tid , attr ); // the function is executed on the pthread with 'tid' per_thread_task (); } Since it's an example, it will be differenct when you have to write for your own. What I want to show here is that the look & feel of the wrapping pattern. Implementation start_routine to resume the coroutine Obviously the most important functions are the life cycle functions. pthread_create pthread_join #include <pthread.h> // create a new thread int pthread_create ( pthread_t * thread , const pthread_attr_t * attr , void * ( * start_routine ) ( void * ), void * arg ); // join with a terminated thread int pthread_join ( pthread_t thread , void ** retval ); Here, we can control 2 parameters. start_routine to designate a routine for the thread arg to forward an argument to the routine With them we can imagine some code in the system will be like this. void pthread_procedure ( void * out , ...){ // ... PC(Program Counter) jumps to here ... out = start_routine ( arg ); // perform `pthread_exit` ... // deliver 'out' to `pthread_join` or somewhere ... } We will define a simple function for the start_routine . It constructs the coroutine_handle from the arg and then resume it after checking with done . void * resume_on_pthread ( void * ptr ){ // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); } Forwarding arg from co_await So to make the function work properly, we have to forward coroutine_handle<void> as an argument of arg . This is easy since there is a member fuction, address . await_suspend will give us the handle like the following code. struct pthread_spawner_t { constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } }; Or if you like the simplicity, you can inherit suspend_always in the std::experimental . #include <experimental/coroutine> using std :: experimental :: suspend_always ; struct pthread_spawner_t : public suspend_always { // hide the function of `suspend_always` ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } }; In the meantime, now we have an awaitable type that creates a new thread. So we can trigger it in 1 line. auto work_on_new_thread () -> no_return { co_await pthread_spawner_t {}; // ... } Concerns You might curious about throw in the second pthread_spawner_t::await_suspend . In general, the function is the last point for the error handling. For our case, suppose that pthread_create failed. The callback resume_on_pthread won't be invoked. That means the coroutine's frame can't be resume d and coverage after co_await is going to be lost. So we have to make caller handle the situation before the coroutine becomes suspended state. One of the way is to throw an exception in await_suspend . Dealing with the thread's join Design Now we have to support join for the thread. pthread_join is so simple that we can't misuse it. What we have care is not the function but the behavior after pthread_join returned without an error. Do you remember that I returned the coroutine frame's address for our start_routine ? void * resume_on_pthread ( void * ptr ){ auto task = coroutine_handle < void >:: from_address ( ptr ); // ... return task . address (); } So in somewhere we have to get the address and destroy it. auto join_and_destroy ( pthread_t tid ){ void * ptr {}; if ( auto ec = pthread_join ( tid , & ptr )) throw system_error { ec , system_category (), \"pthread_join\" }; auto coro = coroutine_handle < void >:: from_address ( ptr ); if ( coro ) coro . destroy (); } But this code is dangerous. The reason is that there is no way to know whether the frame is not destroyed. When the frame is final_suspend ed, we can check it is done() == true and then resume / destroy it. But when the corouitine didn't suspended after final_suspend , its co_return will destroy the frame immediately. So the coro.destroy() above is a double-delete situation. Here, our plan is to provide a special return type which guarantees safe destruction of the frame. Implementation Intend of the final suspension A coroutine's frame is preserved if its coroutine_traits<R>::promise_type does final suspension. That means, it intended manual destruction of the frame, like generator<T> . // From VC++, <experimental/generator> namespace experimental { template < typename _Ty , typename _Alloc = allocator < char >> struct generator { struct promise_type { _Ty const * _CurrentValue ; // ... bool final_suspend () { return ( true ); } // ... }; // ... ~ generator () { if ( _Coro ) { // manual destruction of // the generator coroutine's frame _Coro . destroy (); } } private : coroutine_handle < promise_type > _Coro = nullptr ; }; } // namespace experimental You can see destroy() is invoked in its destructor. We will follow the way. Preserving frame for pthread_join There are 2 things that should be guaranteed. Meet the condition final_suspend == true so pthread_join can receive the destroyable frame Perform destroy after pthread_join Here is the type. It will be a return type for the coroutine which co_await s pthread_spawner_t . class pthread_joiner_t final { public : class promise_type final { public : auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ // preserve the frame after `co_return` return suspend_always {}; } void return_void (){ // we already returns coroutine's frame. // so `co_return` can't have its operand } void unhandled_exception (){ // ... } auto get_return_object () -> promise_type * { return this ; } }; private : pthread_t tid ; public : pthread_joiner_t ( promise_type * ) : tid {} { } ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; So if we use it as a return for the coroutine function, it will be like the following. Review the look and feel with the pthread_spawner_t . auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); // It can be useful if the `joiner` supports `operator pthread_t()` // pthread_t worker_id = joiner; } It seems like we are almost done, but it's not. Concerns You may ask that such design is seriously vulnerable when pthread_exit is used explicitly. My answer for that is, most of pthread_exit 's usage is careful enough. You can note for the dangerous point in your comment, document, or even #warn for the issue. And the users are able to redesign/rewrite their own logic with the note. Context-Aware co_await through await_transform Design auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); } This example looks fine, but it will be more safe when pthread_spawner_t is used if and only if the return type is pthread_joiner_t . Fortuantely C++ Coroutines specifies await_transform which can do the work. So our final goal will be like this. Can you find the difference? auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await attr ; // ... } pthread_attr_t can't work alone since it's a reserved type for the pthread_create . So when there is an instance of it, there must be an intent to create a new thread with it. Therefore co_await on it does express something like \"wait for the thread creation and then ...\". Implementation Pairing pthread_joiner_t with pthread_spawner_t Until now, pthread_spawner_t was an global type that can be used anywhere. The first we have to do is to make it available only when pthread_joiner_t is known. Simply nesting it will do the work. class pthread_joiner_t final { public : class promise_type ; // nest(hide) the `pthread_spawner_t` and allow access to `promise_type` class pthread_spawner_t final { friend class promise_type ; public : // awaitable interface must be open to public constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { // invoke `pthread_create` ... } void await_resume () noexcept { // nothing to do ... } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; }; Defining await_transform As mentioned above, we will define the await_transform in pthread_joiner_t::promise_type . The role of the function is to transform the operand of co_await to an awaitable type. In this case, the awaitable type is pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; // ... private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; class promise_type final { // ... see 'Preserving frame for `pthread_join`' ... // We can consider the `pthread_attr_t*` as an intent to create a new pthread. // Therefore, `promise_type` will transform the type to `pthread_spawner_t` auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr } } }; // ... same with above ... private : pthread_t tid ; }; By doing so we can achieve our design goal. Because typical return types for the coroutines are not aware of how to co_await on pthread_attr_t . Exposing pthread_t Now the last part is to store the new pthread's id in the pthread_joiner_t . This is what I wrote above. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; private : pthread_t tid ; public : // ... ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; However, we call pthread_create in pthread_spawner_t . So we can say there must be some sharing point to get the valid pthread_t from pthread_joiner_t . class pthread_joiner_t final { public : class pthread_spawner_t final { public : // ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())){ throw system_error { ec , system_category (), \"pthread_create\" }; } } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; // <--- duplicate with that of the `pthread_spawner_t` public : // ... ~ pthread_joiner_t () noexcept ( false ); }; At this moment, we must decide where to place the therad's id. In this code pthread_joiner_t is holding it as a member variable. That's pretty general for most of type for subroutines . Think of the implementation that pthread_spawner_t sends thread's id to pthread_joiner_t . If you decide to do so, you have to write a coroutine that aware of it's activator's address. To be more precise, the address of its return type's object. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { // Can we know the address of the returned pthread_joiner_t object ? // Even if that is possible, using the address is a sound design ? } Definatly that will lead to the bad(compex) code. Remember that we are preserving the coroutine frame until pthread_join . In other words, it is a valid behavior to access the frame before we invoke pthread_join . With the point, let's save the thread's id in the coroutine's frame, and access to the memory location when the thread's id is needed. Placing the object in the coroutine's frame isn't that hard. Since the promise_type object is placed in the frame , accessing to it can be done with 1 pointer. I already showed you how to get a ponter to promise_type . Let me show you again. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; class promise_type final { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_always {}; } void unhandled_exception (){ } auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr }; } auto get_return_object () -> promise_type * { return this ; } public : pthread_t tid {}; }; public : // we will receive the pointer from `get_return_object` pthread_joiner_t ( promise_type * p ) : promise { p } { } ~ pthread_joiner_t () noexcept ( false ) { // ... join with the thread id ... // ... destroy the coroutine frame ... } // and we can access to the `tid` through the pointer operator pthread_t () const noexcept { return promise -> tid ; } private : promise_type * const promise ; }; So the last job is to update tid in the promise_type . Let's rewrite the pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; public : constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_create ( this -> tid , this -> attr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // ... do nothing ... } private : // receives 2 pointer at once pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr }{ } pthread_t * const tid ; // pointer to the memory location in the promise const pthread_attr_t * const attr ; }; class promise_type final { auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // ... pthread_t tid {}; }; // ... }; Whoa, that was a long run ! Conclusion You can run the example with the WandBox. https://wandbox.org/permlink/qQ1vbwshsoujYnI0 In this article we covered 2 things by wrapping pthread_create for the coroutines step by step. How the awaitable can wrap the system function which uses a callback and it has a void* parameter How to define await_transform and which limitation it makes However, we only wrapped 2 pthread life cycle functions. So if the coroutine invokes pthread_exit instead of co_return , the assumption of the pthread_joiner_t will be broken. What I didn't cover here will be a good coroutine design practice for you. Move/Copy handling of the types The detach of a thread Triggering multiple thread createion for 1 pthread_joiner_t After Note Arthur O'Dwyer let me know how to improve the final(WandBox) example using private constructor. I will cover that in later post. Appreciate for his help and opinions! :D Allowing another awaitable types You may need to define more generic await_transform like this . class pthread_joiner_t final { public : class promise_type final { // the original auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // redirect to const pointer inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } // allow general co_await usage template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; // ... };","title":"Combining C++ coroutines and `pthread_create`"},{"location":"articles/combining-coroutines-and-pthread_create/#combining-c-coroutines-and-pthread_create","text":"commit: 93ed8748 Some system functions use callback and an argument in void* type. In this article, I'm going to cover how such functions can be wrapped with co_await The base of examples here is my experience to try something like CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" with the POSIX threads. If you are a beginner, please do read the article about promise_type by Lewiss Baker . The article will enhance your understanding greatly.","title":"Combining C++ Coroutines and pthread_create"},{"location":"articles/combining-coroutines-and-pthread_create/#creating-a-new-thread","text":"","title":"Creating a new thread"},{"location":"articles/combining-coroutines-and-pthread_create/#design","text":"What I'm going to try is creating a new thread in a simple manner. Traditionally we had to separate the step before/after pthread_create . To do so, we must write an additional function which is executed on the new thread. Like the thread_start in the pthread_create manual . But co_await can glue two routines into one. Let's see how it looks like. void per_thread_task (); auto work_on_new_thread ( pthread_t & tid , const pthread_attr_t * attr ) -> no_return { // this line is executed on the spawner thread co_await spawn_pthread ( tid , attr ); // the function is executed on the pthread with 'tid' per_thread_task (); } Since it's an example, it will be differenct when you have to write for your own. What I want to show here is that the look & feel of the wrapping pattern.","title":"Design"},{"location":"articles/combining-coroutines-and-pthread_create/#implementation","text":"","title":"Implementation"},{"location":"articles/combining-coroutines-and-pthread_create/#start_routine-to-resume-the-coroutine","text":"Obviously the most important functions are the life cycle functions. pthread_create pthread_join #include <pthread.h> // create a new thread int pthread_create ( pthread_t * thread , const pthread_attr_t * attr , void * ( * start_routine ) ( void * ), void * arg ); // join with a terminated thread int pthread_join ( pthread_t thread , void ** retval ); Here, we can control 2 parameters. start_routine to designate a routine for the thread arg to forward an argument to the routine With them we can imagine some code in the system will be like this. void pthread_procedure ( void * out , ...){ // ... PC(Program Counter) jumps to here ... out = start_routine ( arg ); // perform `pthread_exit` ... // deliver 'out' to `pthread_join` or somewhere ... } We will define a simple function for the start_routine . It constructs the coroutine_handle from the arg and then resume it after checking with done . void * resume_on_pthread ( void * ptr ){ // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); }","title":"start_routine to resume the coroutine"},{"location":"articles/combining-coroutines-and-pthread_create/#forwarding-arg-from-co_await","text":"So to make the function work properly, we have to forward coroutine_handle<void> as an argument of arg . This is easy since there is a member fuction, address . await_suspend will give us the handle like the following code. struct pthread_spawner_t { constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } }; Or if you like the simplicity, you can inherit suspend_always in the std::experimental . #include <experimental/coroutine> using std :: experimental :: suspend_always ; struct pthread_spawner_t : public suspend_always { // hide the function of `suspend_always` ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())) throw system_error { ec , system_category (), \"pthread_create\" }; } }; In the meantime, now we have an awaitable type that creates a new thread. So we can trigger it in 1 line. auto work_on_new_thread () -> no_return { co_await pthread_spawner_t {}; // ... }","title":"Forwarding arg from co_await"},{"location":"articles/combining-coroutines-and-pthread_create/#concerns","text":"You might curious about throw in the second pthread_spawner_t::await_suspend . In general, the function is the last point for the error handling. For our case, suppose that pthread_create failed. The callback resume_on_pthread won't be invoked. That means the coroutine's frame can't be resume d and coverage after co_await is going to be lost. So we have to make caller handle the situation before the coroutine becomes suspended state. One of the way is to throw an exception in await_suspend .","title":"Concerns"},{"location":"articles/combining-coroutines-and-pthread_create/#dealing-with-the-threads-join","text":"","title":"Dealing with the thread's join"},{"location":"articles/combining-coroutines-and-pthread_create/#design_1","text":"Now we have to support join for the thread. pthread_join is so simple that we can't misuse it. What we have care is not the function but the behavior after pthread_join returned without an error. Do you remember that I returned the coroutine frame's address for our start_routine ? void * resume_on_pthread ( void * ptr ){ auto task = coroutine_handle < void >:: from_address ( ptr ); // ... return task . address (); } So in somewhere we have to get the address and destroy it. auto join_and_destroy ( pthread_t tid ){ void * ptr {}; if ( auto ec = pthread_join ( tid , & ptr )) throw system_error { ec , system_category (), \"pthread_join\" }; auto coro = coroutine_handle < void >:: from_address ( ptr ); if ( coro ) coro . destroy (); } But this code is dangerous. The reason is that there is no way to know whether the frame is not destroyed. When the frame is final_suspend ed, we can check it is done() == true and then resume / destroy it. But when the corouitine didn't suspended after final_suspend , its co_return will destroy the frame immediately. So the coro.destroy() above is a double-delete situation. Here, our plan is to provide a special return type which guarantees safe destruction of the frame.","title":"Design"},{"location":"articles/combining-coroutines-and-pthread_create/#implementation_1","text":"","title":"Implementation"},{"location":"articles/combining-coroutines-and-pthread_create/#intend-of-the-final-suspension","text":"A coroutine's frame is preserved if its coroutine_traits<R>::promise_type does final suspension. That means, it intended manual destruction of the frame, like generator<T> . // From VC++, <experimental/generator> namespace experimental { template < typename _Ty , typename _Alloc = allocator < char >> struct generator { struct promise_type { _Ty const * _CurrentValue ; // ... bool final_suspend () { return ( true ); } // ... }; // ... ~ generator () { if ( _Coro ) { // manual destruction of // the generator coroutine's frame _Coro . destroy (); } } private : coroutine_handle < promise_type > _Coro = nullptr ; }; } // namespace experimental You can see destroy() is invoked in its destructor. We will follow the way.","title":"Intend of the final suspension"},{"location":"articles/combining-coroutines-and-pthread_create/#preserving-frame-for-pthread_join","text":"There are 2 things that should be guaranteed. Meet the condition final_suspend == true so pthread_join can receive the destroyable frame Perform destroy after pthread_join Here is the type. It will be a return type for the coroutine which co_await s pthread_spawner_t . class pthread_joiner_t final { public : class promise_type final { public : auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ // preserve the frame after `co_return` return suspend_always {}; } void return_void (){ // we already returns coroutine's frame. // so `co_return` can't have its operand } void unhandled_exception (){ // ... } auto get_return_object () -> promise_type * { return this ; } }; private : pthread_t tid ; public : pthread_joiner_t ( promise_type * ) : tid {} { } ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; So if we use it as a return for the coroutine function, it will be like the following. Review the look and feel with the pthread_spawner_t . auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); // It can be useful if the `joiner` supports `operator pthread_t()` // pthread_t worker_id = joiner; } It seems like we are almost done, but it's not.","title":"Preserving frame for pthread_join"},{"location":"articles/combining-coroutines-and-pthread_create/#concerns_1","text":"You may ask that such design is seriously vulnerable when pthread_exit is used explicitly. My answer for that is, most of pthread_exit 's usage is careful enough. You can note for the dangerous point in your comment, document, or even #warn for the issue. And the users are able to redesign/rewrite their own logic with the note.","title":"Concerns"},{"location":"articles/combining-coroutines-and-pthread_create/#context-aware-co_await-through-await_transform","text":"","title":"Context-Aware co_await through await_transform"},{"location":"articles/combining-coroutines-and-pthread_create/#design_2","text":"auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); } This example looks fine, but it will be more safe when pthread_spawner_t is used if and only if the return type is pthread_joiner_t . Fortuantely C++ Coroutines specifies await_transform which can do the work. So our final goal will be like this. Can you find the difference? auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await attr ; // ... } pthread_attr_t can't work alone since it's a reserved type for the pthread_create . So when there is an instance of it, there must be an intent to create a new thread with it. Therefore co_await on it does express something like \"wait for the thread creation and then ...\".","title":"Design"},{"location":"articles/combining-coroutines-and-pthread_create/#implementation_2","text":"","title":"Implementation"},{"location":"articles/combining-coroutines-and-pthread_create/#pairing-pthread_joiner_t-with-pthread_spawner_t","text":"Until now, pthread_spawner_t was an global type that can be used anywhere. The first we have to do is to make it available only when pthread_joiner_t is known. Simply nesting it will do the work. class pthread_joiner_t final { public : class promise_type ; // nest(hide) the `pthread_spawner_t` and allow access to `promise_type` class pthread_spawner_t final { friend class promise_type ; public : // awaitable interface must be open to public constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { // invoke `pthread_create` ... } void await_resume () noexcept { // nothing to do ... } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; };","title":"Pairing pthread_joiner_t with pthread_spawner_t"},{"location":"articles/combining-coroutines-and-pthread_create/#defining-await_transform","text":"As mentioned above, we will define the await_transform in pthread_joiner_t::promise_type . The role of the function is to transform the operand of co_await to an awaitable type. In this case, the awaitable type is pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; // ... private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; class promise_type final { // ... see 'Preserving frame for `pthread_join`' ... // We can consider the `pthread_attr_t*` as an intent to create a new pthread. // Therefore, `promise_type` will transform the type to `pthread_spawner_t` auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr } } }; // ... same with above ... private : pthread_t tid ; }; By doing so we can achieve our design goal. Because typical return types for the coroutines are not aware of how to co_await on pthread_attr_t .","title":"Defining await_transform"},{"location":"articles/combining-coroutines-and-pthread_create/#exposing-pthread_t","text":"Now the last part is to store the new pthread's id in the pthread_joiner_t . This is what I wrote above. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; private : pthread_t tid ; public : // ... ~ pthread_joiner_t () noexcept ( false ) { void * ptr {}; // we must acquire valid `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } }; However, we call pthread_create in pthread_spawner_t . So we can say there must be some sharing point to get the valid pthread_t from pthread_joiner_t . class pthread_joiner_t final { public : class pthread_spawner_t final { public : // ... void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; if ( auto ec = pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ())){ throw system_error { ec , system_category (), \"pthread_create\" }; } } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; private : pthread_t tid ; // <--- duplicate with that of the `pthread_spawner_t` public : // ... ~ pthread_joiner_t () noexcept ( false ); }; At this moment, we must decide where to place the therad's id. In this code pthread_joiner_t is holding it as a member variable. That's pretty general for most of type for subroutines . Think of the implementation that pthread_spawner_t sends thread's id to pthread_joiner_t . If you decide to do so, you have to write a coroutine that aware of it's activator's address. To be more precise, the address of its return type's object. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { // Can we know the address of the returned pthread_joiner_t object ? // Even if that is possible, using the address is a sound design ? } Definatly that will lead to the bad(compex) code. Remember that we are preserving the coroutine frame until pthread_join . In other words, it is a valid behavior to access the frame before we invoke pthread_join . With the point, let's save the thread's id in the coroutine's frame, and access to the memory location when the thread's id is needed. Placing the object in the coroutine's frame isn't that hard. Since the promise_type object is placed in the frame , accessing to it can be done with 1 pointer. I already showed you how to get a ponter to promise_type . Let me show you again. class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t ; class promise_type final { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_always {}; } void unhandled_exception (){ } auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr }; } auto get_return_object () -> promise_type * { return this ; } public : pthread_t tid {}; }; public : // we will receive the pointer from `get_return_object` pthread_joiner_t ( promise_type * p ) : promise { p } { } ~ pthread_joiner_t () noexcept ( false ) { // ... join with the thread id ... // ... destroy the coroutine frame ... } // and we can access to the `tid` through the pointer operator pthread_t () const noexcept { return promise -> tid ; } private : promise_type * const promise ; }; So the last job is to update tid in the promise_type . Let's rewrite the pthread_spawner_t . class pthread_joiner_t final { public : class promise_type ; class pthread_spawner_t final { friend class promise_type ; public : constexpr bool await_ready () const noexcept { return false ; } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_create ( this -> tid , this -> attr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // ... do nothing ... } private : // receives 2 pointer at once pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr }{ } pthread_t * const tid ; // pointer to the memory location in the promise const pthread_attr_t * const attr ; }; class promise_type final { auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // ... pthread_t tid {}; }; // ... }; Whoa, that was a long run !","title":"Exposing pthread_t"},{"location":"articles/combining-coroutines-and-pthread_create/#conclusion","text":"You can run the example with the WandBox. https://wandbox.org/permlink/qQ1vbwshsoujYnI0 In this article we covered 2 things by wrapping pthread_create for the coroutines step by step. How the awaitable can wrap the system function which uses a callback and it has a void* parameter How to define await_transform and which limitation it makes However, we only wrapped 2 pthread life cycle functions. So if the coroutine invokes pthread_exit instead of co_return , the assumption of the pthread_joiner_t will be broken. What I didn't cover here will be a good coroutine design practice for you. Move/Copy handling of the types The detach of a thread Triggering multiple thread createion for 1 pthread_joiner_t","title":"Conclusion"},{"location":"articles/combining-coroutines-and-pthread_create/#after-note","text":"Arthur O'Dwyer let me know how to improve the final(WandBox) example using private constructor. I will cover that in later post. Appreciate for his help and opinions! :D","title":"After Note"},{"location":"articles/combining-coroutines-and-pthread_create/#allowing-another-awaitable-types","text":"You may need to define more generic await_transform like this . class pthread_joiner_t final { public : class promise_type final { // the original auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // redirect to const pointer inline auto await_transform ( pthread_attr_t * attr ) noexcept ( false ) { return await_transform ( static_cast < const pthread_attr_t *> ( attr )); } // allow general co_await usage template < typename Awaitable > decltype ( auto ) await_transform ( Awaitable && a ) noexcept { return std :: forward < Awaitable &&> ( a ); } }; // ... };","title":"Allowing another awaitable types"},{"location":"articles/designing-the-channel/","text":"Designing the coroutine channel commit: 1.4.3 This is a design note for the channel<T> . It's one of the oldest feature in this library. In this article, I will write about the design background of the type. Summary John Bandela already talked about the coroutine based channel in CppCon 2016 . However, I designed more limited one on my own. #include <coroutine/channel.hpp> using namespace coro ; constexpr int bye = 0 ; auto consumer ( channel < int >& ch ) -> no_return { // the type doesn't support for-co_await for now for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: we received a value if ( msg == bye ) break ; co_await ch . write ( msg ); // we can write in the reader coroutine } } auto producer_owner () -> no_return { channel < int > ch {}; consumer ( ch ); // start a consumer routine for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ok == true: we sent a value co_await ch . read ( msg ); // we can read in the writer coroutine } } Notice that we are reading before writing values to the channel. You can visit more example(test) codes for the type: test/channel_read_write_nolock.cpp test/channel_read_fail_after_close.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_ownership_consumer.cpp test/channel_ownership_producer.cpp test/channel_race_no_leak.cpp Note Motivation(Background) There are multiple ways to deliver value(normally an object) from a routine to another routine. channel<T> is designed to play a role as one of them. Before the coroutine Before the C++ Coroutines becames available, there were 2 ways. return : from callee subroutine to caller subroutine future<T> since C++11 : return with synchronization(shared state) return forwards a T type object from callee subroutine to caller subroutine. C++ 11 future<T> , do the same work but uses a shared state to provide synchronization. As we know, such a synchronization is for multi-threaded code. One of those methods' limitation is that they can deliver only 1 object (of T type), only 1 time (with the return ). Which makes inconvenience sometimes... After the coroutine By adopting coroutine to our world, now we can suspend, and get a new way of delivery. task<T> : 1 time delivery, from a coroutine to another coroutine generator<T> : multi-time delivery, from the generator coroutine to activator coroutine task<T> is the simplest way to get co_return from a coroutine. The most important design point for a coroutine function is that managing suspension( co_await ). It's because suspension is more general than finalization( co_return ). task<T> deals with the cases and activates(resumes) awaiting coroutine when the activatee coroutine returns. generator<T> uses co_yield to deliver value from activatee(generator coroutine) to activator(resumer subroutine) multiple times. For us, co_yield itself is a syntatic sugar that invokes yield_value and evaluate co_await (therefore, suspend) at the same time. Indeed there is a harmony in the way generator<T> works. However, what if we can't acquire the value from generator<T> immediately? What if advancing its iterator is asynchronous? async_generator<T> : generator<T> + awaitable iterator So async_generator<T> allows us to attach a coroutine which will be resumed when the generator coroutine can yield(perform the delivery). In my perspective, using co_await on its iterator is indeed a good idea for the interface design. Its user code remains very similar to that of the generator<T> The consumer coroutine is resumed automatically, so there is no coverage leak You can review existing implementations. Please let me know if there is another implementations so I can add them :) From the https://github.com/kirkshoop/await In this library, which is based on kirkshoop's work, sequence<T> From the adorable cppcoro Another type of the delivery? At this point, we can recognize that we don't have a bidirectional delivery . generator<T> delivers its co_yield ed value only in 1 direction, and so does async_generator<T> . Also, if we need to write multi-threaded code, there are still needs of the synchronization. It depends on the pattern and can managed well, but it's still hard to the beginners. For nondirectional delivery, there is a good example in the Go language. It's channel . The channel can suspend both producer and consumer goroutines by affecting their scheduling. However, there is a difference between the coroutine in the C++ and Goroutine in the Go language. Goroutine is scheduled by the Go runtime, but coroutine are not. It doesn't have a built-in scheduling. Basically, coroutine_handle<T> itself is a pointer and programmers have to manage them manually. Requirement So the requirement for our new type is like the following. channel<T> Non-directional delivery (at least bidirectional) Optional synchronization Coverage leak prevention Invalidation Zero allocation Non-directional delivery We should be able to write/read to a channel in a same coroutine. It's convenient. And that is important for the beginners. Optional synchronization It supports single-threaded code and there must be zero-cost in the case. Coverage leak prevention The type must prevent coverage leak. That means, it must do its best to make related coroutines reach their ends. Invalidation The channel must be able to notify its invalidation. So its user code can handle the operation failure and prevent undefined behavior while they are writing the code. With the coverage requirement above, user will co_return the coroutine, or delegate its work somehow. Zero allocation new / delete is not allowed to avoid unnecessary cost. Design Concerns Optional synchronization The logic will remain while user applies different synchronization types. So the type will use be template. template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class channel final { public : using mutex_type = M ; private : mutex_type mtx ; } Also, as you can see above, it will use do nothing lockable by default. // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } }; Invalidation unlike the channel of Go, the type doesn't provide explicit close operation Explicit close is simple enough because we can just check the channel's state and break the loop. But it is highly possible that user will carefully design the value if there is no close . Suppose we have a close for the channel: auto producer ( channel < int >& ch ) -> no_return { int msg {}; // ... while ( ch . closed () == false ){ co_await ch . write ( msg ); // ... if ( cond ) break ; } ch . close (); // ok, no more value co_return ; } auto consumer ( channel < int >& ch ) -> no_return { while ( ch . closed () == false ){ int msg = co_await ch . read (); // ... } } In this case, user will think about the state of the channel. The following questions can be managed by patternized code, but will always arise from the existance of close . Which line should the close placed? When it's already closed, what should I do for read/write? When we don't have a close , users will think about another issue. When should I stop the read/write? The question is about managing the loop, and probably they will use something like EOF (sentinel value). In my perspective, it is more likely to have well-designed space for the value_type of the channel: auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { co_await ch . write ( msg ); // ... } } auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } Implementation Watching the CppCon 2016 talk will help you a lot for the following notes. Making a linked list of the coroutine frames Since coroutine frames are allocated separatly, we can use them like a node in the linked list. By placing next pointer in those frame, we can make zero-allocation channel. Actually they are a kind of pre-allocation since the cost is already paid in the frame construction(invocation) steps. So it will be enough for channel<T> to have 2 linked lists and 1 mutex to operate correctly under multi-threaded code. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... private : mutex_type mtx ; } To make a linked list of the coroutine frames, the type places an objects in the coroutine frame that containes next pointer. // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... public : // place a writer in the coroutine's frame decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // place a reader in the coroutine's frame decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; You can find next pointer in the following writer and reader . Notice that they have a reserved space to receive coroutine_handle<void> from await_suspend . template < typename T , typename M > class writer final { public : using value_type = T ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; union { writer * next = nullptr ; // Next writer in the channel channel_type * chan ; }; }; template < typename T , typename M > class reader { public : using value_type = T ; using channel_type = channel < T , M > ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; union { reader * next = nullptr ; // Next reader in the channel channel_type * chan ; }; }; Because of the design we will place the objects in the frame. Consider: auto temporary_reader_object ( channel < int >& ch ) -> no_return { // co_await ch.read(); reader < int > reader = ch . read (); co_await reader ; } When it's used with for statement, there will be at most 2 read/writes. So it won't be that complicated. // at most 2 operation in 1 for loop auto consumer ( channel < int >& ch ) -> no_return { for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ... } } auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ... } } Preventing Coverage Leak We all know that RAII is the best way to make the type system work for us. Let's consider about it. What is the proper behavior of the linked list on its destruction? Like the std::list<T> , it must delete its existing nodes to prevent memory leak. Unfortunately, this case is really special because the nodes are existing coroutines' frame. That means, if we free the node, it will destroy all objects in the frame. That's really brutal because it can break all existing expectations of the function that manages its frame manually (with customized promise_type ). So the appropriate behavior is to resume those frames and let them recognize that they can't access the channel anymore. In its destructor , channel<T, M> resumes all awaiting coroutines in its linked lists. Notice the destructor is specified noexcept(false) because typically resume operation is not guaranteed noexcept . template < typename T , typename M > class channel { // ... ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; size_t repeat = 1 ; while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); // <-- use a poison value coro . resume (); // <-- resume write operations } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); // <-- resume read operations } } } } With the behavior, user code must be changed like the following. It receive not only a value from the channel but also one bool that notifies the channel is still accessible. // Before auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } // After auto consumer ( channel < int >& ch ) -> no_return { // it's returning tuple, // declare memory objects using structured binding for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: the channel is accessible // ... } } By doing so, if the reader/writer coroutines are written correctly, channel can guarantee there is no dangling coroutines in its linked lists, and prevent coverage leak of them. Using a poison in await_resume I used poison to replace explicit close . Remember that the co_await expression is affected by await_resume . Returning a tuple from the function can constrain user's code. In the implementation, to decide to return true or false , both reader<T, M> and writer<T, M> have to check if the poison is delivered. // Awaitable for channel's read operation template < typename T , typename M > class reader { // ... auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; Unlike reader, writer just returns bool . The signature makes its return can be used in if or while conveniently. // Awaitable for channel's write operation template < typename T , typename M > class writer final { // ... bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; Furthermore, the signature makes user to places a boolean in the coroutine's frame, not in the channel . So it's on-demand cost. Skip: await_ready and await_suspend This part is realted to the requirement, optional synchronization. It will be covered later because they are purely about the implementation. If you are really curious, visit this page . Conclusion The type doesn't weighted for the performance. What I focused was to enforce intuitive code and to guide users' consideration to their behavior (and undelying semantics). It's not replacement nor alternative of the other delivery methods. To summarize each methods, return : 1 time, directional, subroutine to subroutine future<T> : 1 time, directional, subroutine to subroutine, synchronization(shared state) task<T> : 1 time, directional, coroutine to coroutine generator<T> : multi-time, directional, coroutine to coroutine asnyc_generator<T> : multi-time, directional, coroutine to coroutine, awaitable iterator channel<T> : multi-time (with suspend), non-directional, optional synchronization For channel<T> itself... Non-directional delivery You can see the example with the Compiler Explorer(MSVC) or with the WandBox(clang-8) Coverage Leak For the requirement, channel becomes a linked list of each reader and writer. Its operations place reader/writer object in the coroutine frame. In the destructor, all objects in linked lists receive the poison value. Invalidation (Close Status) To detect invalidation of the channel, we check the poison value in the await_resume function. It's signature enforces to make a memory object( ok in the example) to receive channel's status. When the poison is delivered, co_await on the reader/writer will return false , so the user can break the loop. This can be done without use of close operation.","title":"Designing the coroutine channel"},{"location":"articles/designing-the-channel/#designing-the-coroutine-channel","text":"commit: 1.4.3 This is a design note for the channel<T> . It's one of the oldest feature in this library. In this article, I will write about the design background of the type.","title":"Designing the coroutine channel"},{"location":"articles/designing-the-channel/#summary","text":"John Bandela already talked about the coroutine based channel in CppCon 2016 . However, I designed more limited one on my own. #include <coroutine/channel.hpp> using namespace coro ; constexpr int bye = 0 ; auto consumer ( channel < int >& ch ) -> no_return { // the type doesn't support for-co_await for now for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: we received a value if ( msg == bye ) break ; co_await ch . write ( msg ); // we can write in the reader coroutine } } auto producer_owner () -> no_return { channel < int > ch {}; consumer ( ch ); // start a consumer routine for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ok == true: we sent a value co_await ch . read ( msg ); // we can read in the writer coroutine } } Notice that we are reading before writing values to the channel. You can visit more example(test) codes for the type: test/channel_read_write_nolock.cpp test/channel_read_fail_after_close.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_ownership_consumer.cpp test/channel_ownership_producer.cpp test/channel_race_no_leak.cpp","title":"Summary"},{"location":"articles/designing-the-channel/#note","text":"","title":"Note"},{"location":"articles/designing-the-channel/#motivationbackground","text":"There are multiple ways to deliver value(normally an object) from a routine to another routine. channel<T> is designed to play a role as one of them.","title":"Motivation(Background)"},{"location":"articles/designing-the-channel/#before-the-coroutine","text":"Before the C++ Coroutines becames available, there were 2 ways. return : from callee subroutine to caller subroutine future<T> since C++11 : return with synchronization(shared state) return forwards a T type object from callee subroutine to caller subroutine. C++ 11 future<T> , do the same work but uses a shared state to provide synchronization. As we know, such a synchronization is for multi-threaded code. One of those methods' limitation is that they can deliver only 1 object (of T type), only 1 time (with the return ). Which makes inconvenience sometimes...","title":"Before the coroutine"},{"location":"articles/designing-the-channel/#after-the-coroutine","text":"By adopting coroutine to our world, now we can suspend, and get a new way of delivery. task<T> : 1 time delivery, from a coroutine to another coroutine generator<T> : multi-time delivery, from the generator coroutine to activator coroutine task<T> is the simplest way to get co_return from a coroutine. The most important design point for a coroutine function is that managing suspension( co_await ). It's because suspension is more general than finalization( co_return ). task<T> deals with the cases and activates(resumes) awaiting coroutine when the activatee coroutine returns. generator<T> uses co_yield to deliver value from activatee(generator coroutine) to activator(resumer subroutine) multiple times. For us, co_yield itself is a syntatic sugar that invokes yield_value and evaluate co_await (therefore, suspend) at the same time. Indeed there is a harmony in the way generator<T> works. However, what if we can't acquire the value from generator<T> immediately? What if advancing its iterator is asynchronous? async_generator<T> : generator<T> + awaitable iterator So async_generator<T> allows us to attach a coroutine which will be resumed when the generator coroutine can yield(perform the delivery). In my perspective, using co_await on its iterator is indeed a good idea for the interface design. Its user code remains very similar to that of the generator<T> The consumer coroutine is resumed automatically, so there is no coverage leak You can review existing implementations. Please let me know if there is another implementations so I can add them :) From the https://github.com/kirkshoop/await In this library, which is based on kirkshoop's work, sequence<T> From the adorable cppcoro","title":"After the coroutine"},{"location":"articles/designing-the-channel/#another-type-of-the-delivery","text":"At this point, we can recognize that we don't have a bidirectional delivery . generator<T> delivers its co_yield ed value only in 1 direction, and so does async_generator<T> . Also, if we need to write multi-threaded code, there are still needs of the synchronization. It depends on the pattern and can managed well, but it's still hard to the beginners. For nondirectional delivery, there is a good example in the Go language. It's channel . The channel can suspend both producer and consumer goroutines by affecting their scheduling. However, there is a difference between the coroutine in the C++ and Goroutine in the Go language. Goroutine is scheduled by the Go runtime, but coroutine are not. It doesn't have a built-in scheduling. Basically, coroutine_handle<T> itself is a pointer and programmers have to manage them manually.","title":"Another type of the delivery?"},{"location":"articles/designing-the-channel/#requirement","text":"So the requirement for our new type is like the following. channel<T> Non-directional delivery (at least bidirectional) Optional synchronization Coverage leak prevention Invalidation Zero allocation","title":"Requirement"},{"location":"articles/designing-the-channel/#non-directional-delivery","text":"We should be able to write/read to a channel in a same coroutine. It's convenient. And that is important for the beginners.","title":"Non-directional delivery"},{"location":"articles/designing-the-channel/#optional-synchronization","text":"It supports single-threaded code and there must be zero-cost in the case.","title":"Optional synchronization"},{"location":"articles/designing-the-channel/#coverage-leak-prevention","text":"The type must prevent coverage leak. That means, it must do its best to make related coroutines reach their ends.","title":"Coverage leak prevention"},{"location":"articles/designing-the-channel/#invalidation","text":"The channel must be able to notify its invalidation. So its user code can handle the operation failure and prevent undefined behavior while they are writing the code. With the coverage requirement above, user will co_return the coroutine, or delegate its work somehow.","title":"Invalidation"},{"location":"articles/designing-the-channel/#zero-allocation","text":"new / delete is not allowed to avoid unnecessary cost.","title":"Zero allocation"},{"location":"articles/designing-the-channel/#design-concerns","text":"","title":"Design Concerns"},{"location":"articles/designing-the-channel/#optional-synchronization_1","text":"The logic will remain while user applies different synchronization types. So the type will use be template. template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class channel final { public : using mutex_type = M ; private : mutex_type mtx ; } Also, as you can see above, it will use do nothing lockable by default. // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } };","title":"Optional synchronization"},{"location":"articles/designing-the-channel/#invalidation_1","text":"unlike the channel of Go, the type doesn't provide explicit close operation Explicit close is simple enough because we can just check the channel's state and break the loop. But it is highly possible that user will carefully design the value if there is no close . Suppose we have a close for the channel: auto producer ( channel < int >& ch ) -> no_return { int msg {}; // ... while ( ch . closed () == false ){ co_await ch . write ( msg ); // ... if ( cond ) break ; } ch . close (); // ok, no more value co_return ; } auto consumer ( channel < int >& ch ) -> no_return { while ( ch . closed () == false ){ int msg = co_await ch . read (); // ... } } In this case, user will think about the state of the channel. The following questions can be managed by patternized code, but will always arise from the existance of close . Which line should the close placed? When it's already closed, what should I do for read/write? When we don't have a close , users will think about another issue. When should I stop the read/write? The question is about managing the loop, and probably they will use something like EOF (sentinel value). In my perspective, it is more likely to have well-designed space for the value_type of the channel: auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { co_await ch . write ( msg ); // ... } } auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } }","title":"Invalidation"},{"location":"articles/designing-the-channel/#implementation","text":"Watching the CppCon 2016 talk will help you a lot for the following notes.","title":"Implementation"},{"location":"articles/designing-the-channel/#making-a-linked-list-of-the-coroutine-frames","text":"Since coroutine frames are allocated separatly, we can use them like a node in the linked list. By placing next pointer in those frame, we can make zero-allocation channel. Actually they are a kind of pre-allocation since the cost is already paid in the frame construction(invocation) steps. So it will be enough for channel<T> to have 2 linked lists and 1 mutex to operate correctly under multi-threaded code. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... private : mutex_type mtx ; } To make a linked list of the coroutine frames, the type places an objects in the coroutine frame that containes next pointer. // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... public : // place a writer in the coroutine's frame decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // place a reader in the coroutine's frame decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; You can find next pointer in the following writer and reader . Notice that they have a reserved space to receive coroutine_handle<void> from await_suspend . template < typename T , typename M > class writer final { public : using value_type = T ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; union { writer * next = nullptr ; // Next writer in the channel channel_type * chan ; }; }; template < typename T , typename M > class reader { public : using value_type = T ; using channel_type = channel < T , M > ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; union { reader * next = nullptr ; // Next reader in the channel channel_type * chan ; }; }; Because of the design we will place the objects in the frame. Consider: auto temporary_reader_object ( channel < int >& ch ) -> no_return { // co_await ch.read(); reader < int > reader = ch . read (); co_await reader ; } When it's used with for statement, there will be at most 2 read/writes. So it won't be that complicated. // at most 2 operation in 1 for loop auto consumer ( channel < int >& ch ) -> no_return { for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ... } } auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ... } }","title":"Making a linked list of the coroutine frames"},{"location":"articles/designing-the-channel/#preventing-coverage-leak","text":"We all know that RAII is the best way to make the type system work for us. Let's consider about it. What is the proper behavior of the linked list on its destruction? Like the std::list<T> , it must delete its existing nodes to prevent memory leak. Unfortunately, this case is really special because the nodes are existing coroutines' frame. That means, if we free the node, it will destroy all objects in the frame. That's really brutal because it can break all existing expectations of the function that manages its frame manually (with customized promise_type ). So the appropriate behavior is to resume those frames and let them recognize that they can't access the channel anymore. In its destructor , channel<T, M> resumes all awaiting coroutines in its linked lists. Notice the destructor is specified noexcept(false) because typically resume operation is not guaranteed noexcept . template < typename T , typename M > class channel { // ... ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; size_t repeat = 1 ; while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); // <-- use a poison value coro . resume (); // <-- resume write operations } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); // <-- resume read operations } } } } With the behavior, user code must be changed like the following. It receive not only a value from the channel but also one bool that notifies the channel is still accessible. // Before auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } // After auto consumer ( channel < int >& ch ) -> no_return { // it's returning tuple, // declare memory objects using structured binding for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: the channel is accessible // ... } } By doing so, if the reader/writer coroutines are written correctly, channel can guarantee there is no dangling coroutines in its linked lists, and prevent coverage leak of them.","title":"Preventing Coverage Leak"},{"location":"articles/designing-the-channel/#using-a-poison-in-await_resume","text":"I used poison to replace explicit close . Remember that the co_await expression is affected by await_resume . Returning a tuple from the function can constrain user's code. In the implementation, to decide to return true or false , both reader<T, M> and writer<T, M> have to check if the poison is delivered. // Awaitable for channel's read operation template < typename T , typename M > class reader { // ... auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; Unlike reader, writer just returns bool . The signature makes its return can be used in if or while conveniently. // Awaitable for channel's write operation template < typename T , typename M > class writer final { // ... bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; Furthermore, the signature makes user to places a boolean in the coroutine's frame, not in the channel . So it's on-demand cost.","title":"Using a poison in await_resume"},{"location":"articles/designing-the-channel/#skip-await_ready-and-await_suspend","text":"This part is realted to the requirement, optional synchronization. It will be covered later because they are purely about the implementation. If you are really curious, visit this page .","title":"Skip: await_ready and await_suspend"},{"location":"articles/designing-the-channel/#conclusion","text":"The type doesn't weighted for the performance. What I focused was to enforce intuitive code and to guide users' consideration to their behavior (and undelying semantics). It's not replacement nor alternative of the other delivery methods. To summarize each methods, return : 1 time, directional, subroutine to subroutine future<T> : 1 time, directional, subroutine to subroutine, synchronization(shared state) task<T> : 1 time, directional, coroutine to coroutine generator<T> : multi-time, directional, coroutine to coroutine asnyc_generator<T> : multi-time, directional, coroutine to coroutine, awaitable iterator channel<T> : multi-time (with suspend), non-directional, optional synchronization For channel<T> itself...","title":"Conclusion"},{"location":"articles/designing-the-channel/#non-directional-delivery_1","text":"You can see the example with the Compiler Explorer(MSVC) or with the WandBox(clang-8)","title":"Non-directional delivery"},{"location":"articles/designing-the-channel/#coverage-leak","text":"For the requirement, channel becomes a linked list of each reader and writer. Its operations place reader/writer object in the coroutine frame. In the destructor, all objects in linked lists receive the poison value.","title":"Coverage Leak"},{"location":"articles/designing-the-channel/#invalidation-close-status","text":"To detect invalidation of the channel, we check the poison value in the await_resume function. It's signature enforces to make a memory object( ok in the example) to receive channel's status. When the poison is delivered, co_await on the reader/writer will return false , so the user can break the loop. This can be done without use of close operation.","title":"Invalidation (Close Status)"},{"location":"articles/exploring-msvc-coroutine-kor/","text":"MSVC Coroutine \uc54c\uc544\ubcf4\uae30 Written in 2017/03/02 English \ucc38\uace0\uc790\ub8cc \uc81c\uc548\uc11c N3858 N3977 N4134 N4402 Visual C++ Team Blog Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++ \uc601\uc0c1 CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\" GitHub \uc800\uc7a5\uc18c kirkshoop/ await \uc8fc\uc758\uc0ac\ud56d \uc6b0\uc120 MSVC\uc758 Coroutine\uc744 \uc0ac\uc6a9\ud558\ub824\uba74 3\uac00\uc9c0\uac00 \ud544\uc694\ud558\ub2e4. Visual Studio 2015 Up3 \ud639\uc740 \uadf8 \uc774\uc0c1\uc758 \uac1c\ubc1c\ud658\uacbd /await : \ucef4\ud30c\uc77c \uc635\uc158 <experimental/*> : \uc18c\uc2a4 \ucf54\ub4dc\uc5d0 \ub123\uc744 \ud5e4\ub354\ud30c\uc77c \uc815\uc758 \uadf8\ub798\uc11c, \ucf54\ub8e8\ud2f4\uc774 \ub300\uccb4 \ubb54\uac00\uc694? \uace0\uc2dd(\u53e4\u5f0f) : \uae30\uacc4\ub808\ubca8\uc5d0\uc11c \uc0dd\uac01\ud558\uae30 \uae30\ubcf8\uc801\uc73c\ub85c, \ud504\ub85c\uc2dc\uc800\uc758 \ud638\ucd9c\uc740 goto \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uadf8\ub7f0\ub370 \uc5b4\ub514\ub85c goto \ud55c\ub2e4\ub294 \uac83\uc77c\uae4c? \ub2e4\uc74c\uc5d0 \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc77c \uac83\uc774\ub2e4. \uba85\ub839\uc5b4\ub294 \ub8e8\ud2f4\uacfc \ud504\ub85c\uadf8\ub7a8\uc758 \uc77c\ubd80\uc774\uae30\ub3c4 \ud55c\ub370, \uc7a0\uc2dc \uc5ec\uae30\uc11c \ud55c\ubc88 \uc9da\uc5b4\ubcf4\uaca0\ub2e4. [\ud504\ub85c\uadf8\ub7a8]\uc740 \uc77c\ub828\uc758 [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub4e4\ub85c \ubcfc \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc5ec\uae30\uc11c [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub780, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c \uac83\uc774\uc5b4\uc57c \ud558\uba70, \ud504\ub85c\uadf8\ub7a8\uc744 \uc218\ud589\ud558\ub294 \uae30\uacc4\uc758 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\uc758 \uac12\ub4e4\uc744 \ud569\uce5c \uac83(composition)\uc774\ub2e4. \ubcf4\ud1b5\uc740 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac \uac12\uc758 \uc870\ud569\uc774 \uc720\ud55c\ud558\ub3c4\ub85d \uc124\uacc4\ud55c\ub2e4. Program State = Environment X Memory (\ud568\uc218\uc801 \ud569\uc131 : Cartesian Product) \uc5ec\uae30\uc11c \uba85\ub839\uc5b4\ub4e4\uc740 \uc0c1\ud0dc\uac04\uc758 \uc804\uc774(transition)\ub77c\uace0 \uc815\uc758\ud560 \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc774\ub7ec\ud55c \uc804\uc774\ub4e4\uc744 \uc21c\uc11c\ub300\ub85c \ubb36\uc740 \uac83\uc744 \ub8e8\ud2f4(routine)\uc774\ub77c\uace0 \ud55c\ub2e4. Instruction : \uba85\ub839, \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\uc758 \uc804\uc774 Routine : \uc21c\uc11c\uac00 \uc788\ub294 \uba85\ub839 \ubb36\uc74c \uadf8\ub7ec\uba74 \uc774\uc81c \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc73c\ub85c \ub118\uc5b4\uac08 \ucc28\ub840\ub2e4. \uad00\uacc4 \ubaa8\ub4e0 \ud504\ub85c\uadf8\ub798\uba38\ub4e4\uc740 \ucf54\ub4dc\uc5d0 \ub300\ud574\uc11c \uc790\uc2e0\ub9cc\uc758 \uc2ec\uc0c1(Mental Model)\uc744 \uac16\uae30 \ub9c8\ub828\uc774\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc758 \uba58\ud0c8 \ubaa8\ub378 \ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uace0\uc790 \ud55c\ub2e4. \uc11c\ube0c\ub8e8\ud2f4 : Caller-Callee \uc11c\ube0c\ub8e8\ud2f4\uc758 \uad00\uacc4\ub294 \uc77c\ubc29\uc801\uc774\ub2e4. \ud638\ucd9c\uc790(Caller)\ub294 \uc774\ubbf8 \uc5b4\ub5a4 \uc0c1\ud0dc\uc5d0 \uc788\uace0(\uc774\uc804 \uc870\uac74), \uc5b4\ub5a4 \ub8e8\ud2f4\uc774 \ud544\uc694\ud55c\uc9c0, \ud639\uc740 \ud638\ucd9c\ud560\uc9c0 \uc54c\uace0\uc788\ub2e4. \ud53c\ud638\ucd9c\uc790(Callee)\ub294 \ud504\ub85c\uadf8\ub798\uba38\uc758 \uc758\ub3c4\ub300\ub85c \uc815\uc758\ub41c \ucf54\ub4dc\ub97c \uac00\uc9c0\uace0 \uc788\uace0, \ud638\ucd9c\uc790\uc640 \ubb34\uad00\ud558\uac8c \uba85\ub839\ub4e4\uc744 \uc218\ud589\ud55c\ub2e4. \uc5ec\uae30\uc11c \ubd80\uc218\ud6a8\uacfc(Side-effect)\uac00 \uc788\uc744 \uc218 \uc788\uc9c0\ub9cc, \uadf8\uac74 \uba85\ub839\uc758 \ub0b4\uc6a9\uc5d0 \ub300\ud55c \uac83\uc774\uace0 \uad00\uacc4\uc640\ub294 \ubb34\uad00\ud558\ub2e4. \ucf54\ub8e8\ud2f4 : Activator-Activator \ubcf4\ud1b5 \ucf54\ub8e8\ud2f4\uc740 cooperative\ud55c routine\uc774\ub2e4. \uc774 \ub54c\ubb38\uc5d0 \ud611\ub825\ub8e8\ud2f4\uc774\ub77c\uace0 \ubc88\uc5ed\ub418\uae30\ub3c4 \ud558\ub294\ub370, \uc774\ub7f0 \uc774\ub984\uc740 \ucf54\ub8e8\ud2f4\uc774 \ubb35\uc2dc\uc801\uc73c\ub85c \ub2e4\ub978 \ub8e8\ud2f4\uacfc \ud568\uaed8 \ub3d9\uc791\ud558\ub3c4\ub85d \uc124\uacc4\ub41c \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ub098\uc628 \ub8e8\ud2f4\ub4e4\uc740 \uc11c\ub85c\ub97c \ud65c\uc131\ud654\ud55c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \ud638\ucd9c\uc790(Invoker)\uc640 \uc7ac\uac1c\ub8e8\ud2f4(Resuming routine)\uc5d0 \uc758\ud574\uc11c \ud65c\uc131\ud654 \ub41c\ub2e4. \uc5ed\uc73c\ub85c \uc911\ub2e8\ud558\uac70\ub098 \ubc18\ud658\ud568\uc73c\ub85c\uc368 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\ub978 \ub8e8\ud2f4\uc744 \uc7ac\uac1c\uc2dc\ud0a4\uac8c \ub41c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c\ub294 Suspend/Return\ub4f1\uc73c\ub85c \uad6c\ubd84\ud558\uc600\uc73c\ub098, \ud65c\uc131\ud654\ub77c\ub294 \uac83\uc740 \uc2e4\uc81c\ub85c\ub294 \ub8e8\ud2f4 \uc548\uc758 \uc784\uc758\uc758 \uc9c0\uc810(\uba85\ub839\uc5b4)\uc73c\ub85c \uc810\ud504( goto / jmp )\ud558\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\ub294 \uac83\uc774 \ub2e4\ub978 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uac83\uacfc \uac19\uc744 \uc218 \uc788\uc73c\uba70, \ud568\uc218\uc758 \uc885\ub8cc\uc640 \uc911\ub2e8\uc758 \ucc28\uc774 \ub610\ud55c \ud655\uc5f0\ud558\uc9c0 \uc54a\uc744 \uc218 \uc788\ub2e4. \uc810\ud504\uc758 \ubaa9\ud45c\uc8fc\uc18c\uac00 \ub8e8\ud2f4\uc758 \ub3c4\uc785\ubd80(\ud568\uc218\ub77c\uba74 prologue)\ub77c\uba74 \ud65c\uc131\ud654\ub294 Invocation ( call )\uc774 \ub41c\ub2e4. \ubaa9\ud45c\uc8fc\uc18c\uac00 \ud504\ub85c\uc2dc\uc800\uc758 \ud55c\uac00\uc6b4\ub370 \uc704\uce58\ud558\uba74, \uc774\ub294 Activation ( resume )\uc774 \ub41c\ub2e4. Invocation: \ud638\ucd9c. \ub8e8\ud2f4\uc758 \uc2dc\uc791\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Activation: \ud65c\uc131\ud654. \ub8e8\ud2f4\uc758 \uc784\uc758 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc, \ucf54\ub8e8\ud2f4\uc740 \uc774\uc804 \uc0c1\ud0dc(Pre-condition)\uc640 \uc774\ud6c4 \uc0c1\ud0dc(Post-condition)\uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. \uc774 \ub9d0\uc740, \ucf54\ub8e8\ud2f4 \ub610\ud55c \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\ub97c \uc5b4\ub5bb\uac8c \uc804\uc774\uc2dc\ud0ac\uc9c0 \uc815\uc758\ub418\uc5b4\uc57c \ud55c\ub2e4\ub294 \ub9d0\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc11c\ube0c\ub8e8\ud2f4\uacfc\ub294 \ub2e4\ub974\uac8c, \ucf54\ub8e8\ud2f4\uc740 \uc790\uc2e0\ub9cc\uc758 \uc0c1\ud0dc\ub97c \uc720\uc9c0\ud55c \ucc44\ub85c \ub2e4\ub978 \uc8fc\uc18c\ub85c goto \ud560 \uc218 \uc788\ub2e4. \uc774\ub97c Suspension ( yield )\uc774\ub77c \ud55c\ub2e4. \uacbd\uc6b0\uc5d0 \ub530\ub77c \uc774\ub294 \ud504\ub85c\uc2dc\uc800\uc758 \uc885\ub8cc, \ud639\uc740 \ud568\uc218\uc758 \ubc18\ud658( return )\uc774 \ub420\uc218 \uc788\uc73c\uba70, \uadf8\ub54c\ub294 \uc885\ub8cc(finalization)\ub97c \ud568\uaed8 \uc218\ud589\ud558\uac8c \ub41c\ub2e4. Suspension: \uc911\ub2e8. \uc885\ub8cc\uc791\uc5c5 \uc5c6\uc774 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Finalization: \uc885\ub8cc. \ub8e8\ud2f4\uacfc \uad00\ub828\ub41c \uc790\uc6d0\ub4e4\uc744 \uc815\ub9ac(\ud30c\uad34)\ud558\uace0 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 \ucc28\uc774\uc810? \uc694\ucee8\ub300 \uac00\uc7a5 \ud070 \ucc28\uc774\uc810\uc740, \ucf54\ub8e8\ud2f4\uc740 \uc11c\ube0c\ub8e8\ud2f4\ubcf4\ub2e4 \ub354 \ub9ce\uc740 \ub3d9\uc791(Operation)\uc744 \uc9c0\uc6d0\ud55c\ub2e4\ub294 \uac83\uc774\ub2e4. \uc774\uac83\uc774 \ub3c4\ub110\ub4dc \ud06c\ub204\uc2a4\uac00 The Art of Computer Programming \uc5d0\uc11c \uc774\ub807\uac8c \uc11c\uc220\ud55c \uc774\uc720\ub2e4. \"Subroutines are special cases of ... coroutines\" - Donald Knuth \uc774\ub97c \ud45c\ub85c \uc815\ub9ac\ud558\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4. Operation Subroutine Coroutine Invoke o o \ud504\ub85c\uc2dc\uc800\ub97c \uc2dc\uc791\ud55c\ub2e4 Activate x o \ud2b9\uc815\ud55c \uc9c0\uc810\uc73c\ub85c \uc9c4\uc785\ud55c\ub2e4 Suspend x o Control Flow\ub97c \uba48\ucd98\ub2e4. Finalize o o \uc9c0\uc5ed\ubcc0\uc218, \ub9e4\uac1c\ubcc0\uc218\ub4e4\uc744 \uc815\ub9ac\ud558\uace0 return \ud55c\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc774 \uc81c\ud55c\ub418\uc5c8\uc9c0\ub9cc \uad00\uacc4\uc5d0 \ub300\ud55c \uace0\ub824\uac00 \ud544\uc694\uc5c6\uc5b4 \uac04\ub2e8\ud558\ub2e4. \ubc18\uba74\uc5d0 \ucf54\ub8e8\ud2f4\uc740 \ub354 \ub9ce\uc740 \ub3d9\uc791\uc774 \uac00\ub2a5\ud558\uc9c0\ub9cc, \uc911\ub2e8\uacfc \ud65c\uc131\ud654\uc5d0 \ub300\ud55c(\uadf8\ub9ac\uace0 \uac01\uac01\uc758 Pre/Post condition\uc5d0 \ub300\ud55c) \uc815\uc758\uac00 \ud544\uc694\ud558\ubbc0\ub85c \ub354 \ubcf5\uc7a1\ud558\ub2e4. Routine: \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub97c \ubcc0\ud654\uc2dc\ud0a4\ub294 \uba85\ub839\uc5b4 \ubb36\uc74c. \uadf8 \ub0b4\uc6a9\uc740 \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c\ub2e4. Subroutine: \ub3d9\uc791 2\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Finalize Coroutine: \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Activate Suspend Finalize \uc608\uc81c \ud06c\ub204\uc2a4\ub294 \uc774\ub7f0 \uac1c\ub150\uc774 \uc5b4\ub5bb\uac8c \ucf54\ub4dc\ub85c \ud45c\ud604\ub418\ub294\uc9c0 \uadf8\uc758 \ucc45\uc5d0\uc11c \uc124\uba85\ud558\uace0 \uc788\ub2e4. \ub2e4\uc74c \ucf54\ub4dc\ub294 The Art of Computer Programming\uc5d0 \uc788\ub294 MIX \uba85\ub839\uc5b4\ub4e4\uc744 \uadf8\ub300\ub85c \uc62e\uaca8\uc628 \uac83\uc73c\ub85c, \ubaa8\ub450 \uc774\ud574\ud560 \ud544\uc694\ub294 \uc5c6\ub2e4. \uc624\ub298\ub0a0\uc758 call / return \uad6c\uc870\uc640 \ub2ec\ub9ac, \ubaa8\ub4e0 \ub3d9\uc791\ub4e4\uc774 JMP \uba85\ub839\uc5b4\ub85c \uc218\ud589\ub418\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ud575\uc2ec\uc740 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\uc218\uc758 \uc9c4\uc785\uc810\uacfc \uc911\ub2e8\uc810\uc744 \uac00\uc9c4\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub354\ud574\uc11c, \ubb35\uc2dc\uc801\uc778 \uc0c1\ud0dc(\ub808\uc9c0\uc2a4\ud130 \ud639\uc740 \uba54\ubaa8\ub9ac)\ub97c \uac00\uc9c8 \uc218\ub3c4 \uc788\ub2e4. // MIX \uc608\uc81c, \uc8fc\uc11d\uc744 \ubcc0\uacbd\ud558\uc600\uc74c // \uc790\uc138\ud55c \ub0b4\uc6a9\uc740 The Art of Computer Programming 1.4.2 \uc5d0 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF . \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378 \uc2a4\ud0dd\uc774\ub2e4! \"\ud568\uc815\uc774\ub2e4!\" - \uc544\ud06c\ubc14 \uc81c\ub3c5 \uc624\ub298\ub0a0 \ub110\ub9ac \uc0ac\uc6a9\ub418\uace0 \uc788\ub294 High-level \uc5b8\uc5b4\ub4e4\uc740 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c\ub2e4. \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc740 \uc5b8\uc5b4\uc801\uc73c\ub85c \uba85\ud655\ud558\uac8c \uc815\uc758\ub418\uace0, \uc790\ub3d9\uc73c\ub85c \uad00\ub9ac\ub418\uba70, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uac1c\uc785\ud558\uc9c0 \uc54a\uc544\ub3c4 \ubb38\uc81c\uc5c6\uc774 \ub3d9\uc791\ud55c\ub2e4. \uad6c\uc870\uc801 \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc774\ub7f0 \uc2a4\ud0dd\uc911\uc2ec\uc758 \ubaa8\ub378\uacfc \uc870\ud654\ub97c \uc774\ub8e8\uc5b4\uc654\ub2e4. \uc774 \ubaa8\ub378\uc5d0\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uc218\ud559\uc801\uc73c\ub85c \ud45c\ud604\ud560 \uc218 \uc788\ub294 \uc218\uc2dd\ud2b8\ub9ac \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uacb0\uacfc\uc801\uc73c\ub85c main \ud568\uc218\ub294 \uc885\ub8cc\ud558\uba70, \uc801\ub2f9\ud55c \uacb0\uacfc\uac12\uc744 \ubc18\ud658\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ud45c\ud604\ud55c \uac83 \ucc98\ub7fc, \ud2b8\ub9ac\ud615 \ubaa8\ub378\uc5d0\uc11c \ud568\uc218\uc758 \ud750\ub984\uc740 \uc774 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uae4a\uc774-\uc6b0\uc120 \uc21c\uc11c\ub85c \uc21c\ud68c\ud558\uba70, \uc791\uc131\ud558\ub294 \uc2dc\uc810\ubd80\ud130 \uac01 \uad6c\ubb38(Statement)\ub4e4\uc758 \uc2e4\ud589 \uc21c\uc11c\uac00 \uc815\ud574\uc9c4\ub2e4. \uadf8\ub9bc\uc5d0\uc11c B \uad6c\ubb38\uc5d0 \ub3c4\ub2ec\ud558\uae30 \uc704\ud574\uc120, A \uad6c\ubb38\uc744 \ub9c8\uccd0\uc57c \ud55c\ub2e4. \uc774 \uc2dc\uc810\uc5d0 \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub294 \uad6c\ubb38 A\uc758 \uc601\ud5a5\uc744 \ubc1b\uc544 \ubcc0\ud558\uac8c \ub418\uba70, \ub808\uc9c0\uc2a4\ud130/\uba54\ubaa8\ub9ac\ub294 \uc801\ub2f9\ud55c \uac12\uc744 \uac00\uc9c0\uace0 \uc788\uc744 \uac83\uc774\ub2e4. Blocking \uc5ec\uae30\uc11c \ubb38\uc81c\uac00 \ub418\ub294 \uac83\uc740 \uc758\uc874\uc131\uc774\ub2e4. \ud2b8\ub9ac \ubaa8\ub378\uc740 \uc218\ud559\uc744 \ud504\ub85c\uadf8\ub7a8\uc73c\ub85c \uc62e\uaca8\ub193\uc740 \uac83\uc774\ub2e4. \uc218\uc2dd\uc5d0 \ud544\uc694\ud55c \ubaa8\ub4e0 \uac12\uc774 \uba54\ubaa8\ub9ac\uc5d0 \uc788\ub2e4\uba74, \ucef4\ud4e8\ud130\ub294 \uacc4\uc0b0\uc744 \ub3c4\uc911\uc5d0 \uba48\ucd94\uc9c0 \uc54a\uace0\ub3c4 \uc218\ud589\ud560 \uc218 \uc788\ub2e4. \ub2e4\ub9cc \uc6b0\ub9ac\uc758 \uc790\uc6d0\uc740 \ubb34\ud55c\ud558\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \ud504\ub85c\uadf8\ub7a8 \ud750\ub984\uc774 \uc2dc\uc791\ub418\ub294 \uc2dc\uc810\uc5d0 \ubaa8\ub4e0 \uac12\ub4e4\uc744 \uc900\ube44\ud560 \uc218\ub294 \uc5c6\ub2e4. \ub2e4\ub978 \uc6d0\uc778\ub3c4 \uc788\ub2e4. \uac12\uc774 \ubb3c\ub9ac\uc801\uc73c\ub85c \uac81\ub098 \uba3c \uacf3\uc5d0 \uc788\uc5b4\uc11c \uc2e4\uc2dc\uac04 \ud1b5\uc2e0\uc744 \ud574\uc57c\ud560\uc218\ub3c4 \uc788\ub2e4. \uacb0\uad6d \uc6b0\ub9ac\ub294 \ud544\uc5f0\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc744 \ud574\uc57c\ud55c\ub2e4. \uc804\ud1b5\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc740 \ub290\ub9ac\uace0, \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uba48\ucdb0\uc57c \ud588\ub2e4. \ubc18\uc751\uc131(Responsiveness)\uc744 \uc704\ud574 \ud504\ub85c\uadf8\ub7a8\uc774 \uba48\ucd94\uae30\ub97c \uc6d0\ud558\uc9c0 \uc54a\ub294\ub2e4\uba74 \uc5b4\ub5a8\uae4c? Non-blocking\uacfc \ube44\ub3d9\uae30(Asynchronous) \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc5ec\uae30\uc11c \uc2dc\uc791\ud55c\ub2e4. \uc774\ub294 \uc694\uc57d\ud558\uc790\uba74 \uae30\uc874\uc758 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uc77c\ubc18\ud654 \ud574\uc11c, \ud558\ub098\uc758 \uadf8\ub798\ud504\ub97c \uc791\uc131\ud558\ub294 \uac83\uc774\ub2e4. \uc0c1\ud0dc\uae30\uacc4\uac00 \uadf8\ub798\ud504\ub85c \ud45c\ud604\ub41c\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud574\ubcf4\ub77c. \uc774 \uadf8\ub798\ud504 \ubaa8\ub378\uc5d0\uc120 \ud504\ub85c\uadf8\ub7a8\uc740 \uc0c1\ud0dc\ub4e4\ub85c \uc774\ub8e8\uc5b4\uc9c4 \uadf8\ub798\ud504 \uac00 \ub41c\ub2e4. \uadf8\ub9ac\uace0 \ud504\ub85c\uc138\uc11c\ub4e4\uc740 \uc774 \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\ub294 \uac83\uc774\ub2e4. \ud504\ub85c\uc138\uc11c\ub294 \uc6b4\uc601\uccb4\uc81c\uc758 \ud504\ub85c\uc138\uc2a4, \uc2a4\ub808\ub4dc\uc77c \uc218 \uc788\ub2e4. \ub610\ub294 \uc5b8\uc5b4\ub808\ubca8\uc5d0\uc11c \uc9c0\uc6d0\ud558\ub294 \ucd94\uc0c1\ud654, \uac00\ub839 Erlang\uc758 \ud504\ub85c\uc138\uc2a4\ub098 Go\uc5b8\uc5b4\uc758 Goroutine\uc77c \uc218 \uc788\ub2e4. \ub354 \uc774\uc0c1\uc758 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc0dd\ub7b5\ud55c\ub2e4. \uc601\uc18d\uc131 \ud575\uc2ec\uc740, \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\uba74\uc11c \uc5b4\ub5bb\uac8c \uc815\uc810\uac04\uc758 \ubb38\ub9e5(context) \uad50\ud658\uc774 \uac00\ub2a5\ud560\uae4c \ud558\ub294 \uac83\uc774\ub2e4. \uc6b0\uc120 \uc11c\ube0c\ub8e8\ud2f4\uc740 return \uacfc \ub3d9\uc2dc\uc5d0 \ud30c\uad34\ub418\ubbc0\ub85c(\uc0ac\ub77c\uc9c0\ubbc0\ub85c) \uc774\uac83\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. \ub2ec\ub9ac \ub9d0\ud574 \uc11c\ube0c\ub8e8\ud2f4\uc740 \uc601\uc18d\uc131\uc774 \uc5c6\ub2e4. \uc774\ub294 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc774 \ub3d9\uc791\ud558\ub294 \ubc29\uc2dd\uc774\uc9c0\ub9cc, \ub3d9\uc2dc\uc5d0 \uc815\uc810(\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc)\uac04\uc758 \ubb38\ub9e5\uc804\ub2ec\uc744 \uc544\uc8fc \uc5b4\ub835\uac8c \ub9cc\ub4e4\uc5c8\ub2e4. \ucf5c\ubc31 \uc9c0\uc625 \ub3c4 \uacb0\uad6d\uc740 \ubb38\ub9e5\uc804\ub2ec\uc744 \ud558\uae30 \uc704\ud55c \uace0\uc721\uc9c0\ucc45\uc774\ub77c \ud560 \uc218 \uc788\ub2e4. \"\uc81c\uc784\uc2a4, \uc774 \ucf54\ub4dc\uc5d0\ub294 \ubc84\uadf8\uac00 \uc788\uc5b4\uc694. \uace0\uce60 \uc218 \uc788\uaca0\uc5b4\uc694?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); } \uc811\uadfc\ubc95 \uc6b0\ub9ac\uc5d0\uac90 \uc601\uc18d\uc131 \uc788\ub294 \ud568\uc218\uac00 \ud544\uc694\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc(finalization)\ud558\uc9c0 \uc54a\uc73c\uba74\uc11c \uc911\ub2e8(suspend/yield)\uc774 \uac00\ub2a5\ud588\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud558\uba74, \ub2f5\uc740 \uba85\ud655\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc788\uc73c\uba74 \uc774 \ubb38\uc81c\ub97c \ud574\uacb0\ud560 \uc218 \uc788\uc744 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc5b4\ub85c \uad6c\ud604\ud558\ub358 \uac1c\ub150\uc744 \uc5b4\ub5bb\uac8c \uc2a4\ud0dd \uc138\uc0c1\uc73c\ub85c \uac00\uc838\uc62c \uc218 \uc788\uc744\uae4c? \uc9c8\ubb38\uc744 \ubc14\uafd4\ubcf4\uc790. \ubb34\uc5c7\uc774 \uc601\uc18d\uc131\uc744 \uac00\uc838\uc57c \ud558\ub294\uac00?: \ubb38\ub9e5 \ubb38\ub9e5\uc740 \ubb34\uc5c7\uc778\uac00?: \ub8e8\ud2f4\uc758 \uc0c1\ud0dc \uc0c1\ud0dc\ub294 \ubb34\uc5c7\uc73c\ub85c \uc774\ub8e8\uc5b4\uc9c0\ub294\uac00?: \ud658\uacbd & \uba54\ubaa8\ub9ac \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\ub294 \uc5b4\ub514\uc5d0 \uc704\uce58\ud558\ub294\uac00?: \ud568\uc218 \ud504\ub808\uc784(Function Frame) \uc815\ub9ac\ud558\uc790\uba74, \uc9c8\ubb38\uc740 \uc5b4\ub5bb\uac8c \ud568\uc218 \ud504\ub808\uc784\ub4e4\uc744 \uc601\uc18d\uc131\uc788\uac8c \ub9cc\ub4e4 \uac83\uc778\uac00 \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc124\uba85\uc740 \uc790\uc138\ud788 \uae30\uc220\ud558\uc9c0\ub294 \uc54a\uaca0\uc9c0\ub9cc, \uc790\uc138\ud55c \uc124\uba85\uc744 \uc6d0\ud55c\ub2e4\uba74 \uc774 \ud398\uc774\uc9c0 \ub97c \ucc38\uace0\ud558\ub77c. \uc2a4\ud0dd \uc548? \ubc16! \"\uc65c \uc740\ud589\uc744 \ud130\ub098\uc694?\" \"\ub3c8\uc774 \uac70\uae30\uc5d0 \uc788\uc796\uc544\uc694\" - \uc5b4\ub290 \uc740\ud589 \uac15\ub3c4 \uc2a4\ud0dd \ub0b4(Stack-ful) \ucf54\ub8e8\ud2f4 / \ubd84\ud560 \uc2a4\ud0dd \uc5b8\uc5b4\ub9c8\ub2e4 \ub2e4\ub974\uaca0\uc9c0\ub9cc, C++\ub294 \ud568\uc218 \ud504\ub808\uc784\uc744 \uc2a4\ud0dd\uc5d0 \ubc30\uce58\ud55c\ub2e4. \uc774\ub7f0 \uc0c1\ud669\uc5d0\uc11c \ud504\ub808\uc784\uc744 \ubcf4\uc874\ud558\ub824\uba74, \ud504\ub808\uc784\uc744 \uadf8\ub300\ub85c \ubcf5\uc0ac\ud574\uc11c \uc5b4\ub518\uac00\uc5d0 \uc800\uc7a5\ud574\ub450\ub294 \uc218 \ubc16\uc5d0 \uc5c6\ub2e4. \ub2e4\ub978 \ubc29\ubc95\uc73c\ub85c\ub294 \uc801\ub2f9\ud55c \uacf5\uac04\uc744 \ub530\ub85c \uc608\uc57d\ud574\uc11c \ub300\uccb4 \uc2a4\ud0dd(side stack)\uc73c\ub85c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc774 \uc788\uc744 \uac83\uc774\ub2e4. \uc774 \ubd80\ubd84\uc740 \uc9c0\ub098\uce58\ub3c4\ub85d \ud558\uaca0\ub2e4. MSVC\ub294 \uc2a4\ud0dd \uc678 \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4. \uc2a4\ud0dd \uc678(Stack-less) \ucf54\ub8e8\ud2f4\uacfc \ud568\uc218 \ud504\ub808\uc784 N3858 \uc81c\uc548\uc11c\uc5d0\ub294 \uc774\ub978\ubc14 '\ub2e4\uc2dc \uc2dc\uc791\ud558\ub294 \ud568\uc218'(Resumable Function, \uc774\ud558 \uc7ac\uac1c\ud568\uc218)\uc758 \uad6c\ud604\uac00\ub2a5\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uadf8 \ubc29\ubc95\ub860 \uc911 \ud558\ub098\ub294 \ud799(Heap)\uc5d0 \ud568\uc218\uc758 \ud65c\uc131 \ud504\ub808\uc784(Activation Frame)\uc744 \ud560\ub2f9\ud558\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud504\ub808\uc784\uc740 \ub2e8\uc21c\ud558\uac8c\ub294 \uad6c\uc870\uccb4\uc77c \ubfd0\uc774\ub2e4. \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791 4\uac1c\ub294 \uc5b4\ub5bb\uac8c \ub41c \uac83\uc77c\uae4c? \uc774\ub4e4\uc740 Compiler Intrinsic \ud615\ud0dc\ub85c MSVC\uac00 \uc790\uccb4\uc801\uc73c\ub85c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... \uadf8\ub7ec\ub2c8 \uc774 \ubd80\ubd84\uc5d0 \ub300\ud574\uc11c\ub294 \uc190\ub308 \uc218 \uc788\ub294 \ubd80\ubd84\uc774 \uc5c6\ub2e4. \ub354 \uc790\uc138\ud55c \uc124\uba85\uc774 \ud544\uc694\ud558\ub2e4\uba74 \ucc38\uace0\uc790\ub8cc\uc5d0\uc11c CppCon \ubc1c\ud45c\ub4e4\uc744 \uc2dc\uccad\ud558\uae30\ub97c \uad8c\ud55c\ub2e4. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block \uc774 intrinsic\ub4e4 \uc911 Frame\uacfc Block\ub4e4\uc758 \uc5ed\ud560\uc5d0 \ub300\ud574\uc11c \uba85\ud655\ud558\uc9c0 \uc54a\uc740 \ubd80\ubd84\uc774 \ub0a8\uc544\uc788\ub294 \uac83 \uac19\uc2b5\ub2c8\ub2e4. \uae30\ud68c\uac00 \ub418\uba74 \uc5c5\ub370\uc774\ud2b8 \ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. The C++ Coroutine : Resumable Function \uc774 \uc2dc\uc810\uc5d0\uc11c \ub450 \uc6a9\uc5b4\ub97c \uc815\ub9ac\ud560 \ud544\uc694\uac00 \uc788\uc744 \uac83 \uac19\ub2e4. Coroutine : \uac1c\ub150 . \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Resumable Function : C++ \uc5b8\uc5b4\uc5d0\uc11c Coroutine\uc758 \uad6c\ud604 \ubc29\ubc95 \ucd94\uac00\ub85c \ub2e4\uc74c \ud45c\ub294 \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791\ub4e4\uc744 \uc5b4\ub5bb\uac8c \uc0ac\uc6a9\ud558\ub294\uc9c0 \uc815\ub9ac\ud55c \uac83\uc774\ub2e4. Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return \ud638\ucd9c(Invoke) \ud568\uc218 \ud638\ucd9c\uc5d0 \ub300\ud574\uc11c\ub294 \ubcc0\uacbd\uc0ac\ud56d\uc774 \uc5c6\ub2e4. \ud558\uc9c0\ub9cc \uc7ac\uac1c\ud568\uc218\ub294 std::future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4. \uc885\ub8cc(Finalize) \uc11c\ube0c\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ubc18\ud658\uc9c0\uc810\uc740 \uc775\ud788 \uc54c\ub824\uc9c4 return \ud0a4\uc6cc\ub4dc\ub97c \uc0ac\uc6a9\ud558\uba74 \ub41c\ub2e4. \ucf54\ub8e8\ud2f4\uc774\ub77c\uba74 co_return \ud0a4\uc6cc\ub4dc\uac00 \uc774 \uc5ed\ud560\uc744 \ub300\uc2e0\ud55c\ub2e4. \uc911\ub2e8(Suspend) \ud568\uc218\ub97c \uc911\ub2e8\ud558\uace0 Control Flow\ub97c \uc591\ubcf4\ud558\ub294 \ubc29\ubc95\uc740 co_yield expression\uacfc co_await \uc5f0\uc0b0\uc790\ub97c \uc0ac\uc6a9\ud558\ub294 \uac83\uc774\ub2e4. \uc774 \ub458 \uc911 \ud558\ub098\ub77c\ub3c4 \uc0ac\uc6a9\ud558\uba74, \uadf8 \uc9c0\uc810\uc740 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc73c\ub85c \uc0ac\uc6a9\ub418\uba70 MSVC\ub294 \uadf8 \ud568\uc218\ub97c \uc7ac\uac1c\ud568\uc218\ub85c \ub9cc\ub4e4\uac8c \ub41c\ub2e4. (\ub354\ud574\uc11c co_return \uad6c\ubb38\ub3c4 \ud568\uc218 \ub0b4\uc5d0 \uc704\uce58\ud558\uba74 \uc7ac\uac1c\ud568\uc218\ub85c \uc778\uc2dd\ub41c\ub2e4.) \ud65c\uc131\ud654(Activate) \uc911\ub2e8\ub41c \ud568\uc218\ub97c \ud65c\uc131\ud654 \ud560 \ub54c\ub294, coroutine_handle \uacfc \uba64\ubc84\ud568\uc218 .resume() \ub97c \uc0ac\uc6a9\ud55c\ub2e4. \uc774 \ud638\ucd9c\uc740 Compiler Intrinsic\uc778 _coro_resume \uc704\uc5d0 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc62c\ub9b0 \uac83\uc774\ub2e4. Code \uc608\uc81c \ucf54\ub4dc\uc640 \uad00\ub828\ud574 kirkshoop\uc758 \uc800\uc7a5\uc18c \uac00 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uc2b5\ub2c8\ub2e4. \ubbf8\ub9ac \uc694\uc57d\ud558\uc790\uba74, MSVC\uc758 \uc694\uad6c\uc0ac\ud56d\uc744 \ub530\ub974\uae30\ub9cc \ud55c\ub2e4\uba74 C++\uc5d0\uc11c\ub3c4 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. \uc81c\uc548\uc11c\uc758 \uc774\ub984\uc774 \uc7ac\uac1c (\ub530\ub77c\uc11c, \uc601\uc18d\uc131 \uc788\ub294) \ud568\uc218 \ub77c\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud558\ub77c. \uc7ac\uac1c\ud568\uc218\uc5d0\ub294 \uba87\uac00\uc9c0 \uc885\ub958\uac00 \uc788\ub294\ub370, \ud568\uc218\uc5d0 \uc5b4\ub5a4 \uc5ed\ud560\uc744 \ub9e1\uae30\uace0\uc790 \ud558\ub290\ub0d0\uc5d0 \ub530\ub77c \ub2ec\ub77c\uc9c4\ub2e4. \uadf8\ub7ec\uba74 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc694\uad6c\uc0ac\ud56d\uc774\ub780 \ubb34\uc5c7\uc77c\uae4c? Promise : \ucef4\ud30c\uc77c\ub7ec\uac00 \uc6d0\ud558\ub294 \uac83 C++11\uc5d0 \ucd94\uac00\ub41c std::future<T> \uc640 std::promise<T> , \uadf8\ub9ac\uace0 \uc774 \ub450 \uc9dd\uad81\uc758 \uad00\uacc4\uc5d0 \ub300\ud574\uc11c \uc54c \uac83\uc774\ub77c \uc804\uc81c\ud558\uaca0\ub2e4. \uc77c\ubc18\uc801\uc73c\ub85c, future<T> \ub294 \" \ub098\uc911\uc5d0 \uac12\uc774\ub098 \uc608\uc678\ub97c \uc904\uac8c\"\ub77c\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. ( std::async \ub97c \ucc38\uace0\ud558\ub77c) \uadf8\ub9ac\uace0 \uac12/\uc608\uc678\ub294 promise<T> \ub97c \ud1b5\ud574\uc11c \uc804\ub2ec\ub41c\ub2e4. \uc774\ub294 \"\uacb0\uacfc\ub97c \uc900\ub2e4\ub294 \uc57d\uc18d \uc744 \uc9c0\ucf30\ub2e4.\"\ub77c\ub294 \uac83\uc774\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\uac00 future<T> \ub97c \ubc18\ud658\ud55c\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \ub9d0 \uadf8\ub300\ub85c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \uc2a4\uc2a4\ub85c \uc911\ub2e8\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0 \ud65c\uc131\ud654\ud55c \ub8e8\ud2f4 \uc785\uc7a5\uc5d0\uc11c\ub294 \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc\ud588\ub294\uc9c0 \uc54c \ubc29\ubc95\uc774 \uc5c6\ub2e4. \ubc18\ud658\uac12\uc774 \uc788\ub2e4\ub294 \uac83\uc744 \uc54c \uc218 \uc5c6\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud568\uc218\uc758 \uc2dc\uadf8\ub2c8\ucc98(Signature)\uc0c1\uc73c\ub85c\ub294, \ub098\uc911\uc5d0 \ub77c\ub294 \uc758\ubbf8\uac00 \ub2f4\uae34 \ud0c0\uc785 future \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud568\uc73c\ub85c\uc368 \uc77c\ubc18\uc801\uc778 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uace0 \uc788\ub2e4. \ub2e4\ub9cc \uae30\uc874\uacfc \ub2ec\ub9ac \uc5ec\uae30\uc11c\uc758 promise \ub294 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c\uac83\uc774\ub2e4. N4402 \ub294 \uc774 \ub0b4\uc6a9\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uc5b4\uc9f8\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uac8c \uc57d\uc18d\uc774 \ud544\uc694\ud55c \uac83\uc77c\uae4c? \uc774\ub294 \uc7ac\uac1c\ud568\uc218\uac00 \ucd94\uc0c1\ud654 \ud55c \uacb0\uacfc\ubb3c\uc774\uae30 \ub54c\ubb38\uc774\ub2e4. \uc2a4\ud0dd \uae30\ubc18\uc758 \ud658\uacbd\ub54c\ubb38\uc5d0, \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud558\uae30\ub294 \ud588\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc640 \uac19\uc774 1\ucc28\uc6d0\uc73c\ub85c \ubc30\uce58\ub41c(flat) \uad6c\ubb38\uad6c\uc870\ub294 \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 \uacb0\uad6d \ud799\uc5d0\uc11c \uc0b4\uc544\uc788\uc73c\uba70, \ud799 \uc601\uc5ed(\ud568\uc218 \ud504\ub808\uc784)\uc5d0\uc11c \uc2a4\ud0dd \uc601\uc5ed( future \ub610\ub294 awaitable)\uc73c\ub85c \uac12\uc744 \uc804\ub2ec\ud574\uc57c \ud558\uace0, \uc774 \uacfc\uc815\uc740 \uc77c\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4 \ub97c \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9c0\ub3c4\ub85d \ud55c \uac83\uc774\ub2e4. \ubb3c\ub860 \uc778\ud130\ud398\uc774\uc2a4\ub294 \ucef4\ud30c\uc77c\ub7ec\uc640 \ud504\ub85c\uadf8\ub798\uba38 \uc591\ucabd \ubaa8\ub450\ub97c \uc704\ud55c \uac83\uc774\ub2e4. Resumable Promise Requirement \uc7ac\uac1c\ud568\uc218\uc758 Promise \uc694\uad6c\uc0ac\ud56d \uadf8 \uc778\ud130\ud398\uc774\uc2a4\uac00 \uc5b4\ub5bb\uac8c \uc4f0\uc774\ub294\uc9c0\ub294 \uc7a0\uc2dc \ud6c4 \uae30\uc220\ud558\uace0, \uadf8\uc5d0 \uc55e\uc11c N4402 \ubb38\uc11c\ub97c \uc0b4\ud3b4\ubcf4\uc790. \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc0ac\uc6a9\ub420 \uc218 \uc788\ub294 Promise \ud0c0\uc785\uc740 \uc544\ub798 \ud45c\uc5d0 \uc5f4\uac70\ub41c \uba64\ubc84\ud568\uc218\ub4e4\uc744 \uc9c0\uc6d0\ud574\uc57c \ud55c\ub2e4. \uc81c\uc548\uc11c\ub97c \uc694\uc57d\ud55c \uac83\uc774\ubbc0\ub85c, \ubcf4\ub2e4 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc81c\uc548\uc11c\ub97c \ucc38\uace0\ud558\uae30 \ubc14\ub780\ub2e4. Expression Note P{} \uc774 \ud0c0\uc785\uc740 default constructible \ud574\uc57c\ud55c\ub2e4. p.get_return_object() \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc744 \uacb0\uc815\ud55c\ub2e4. future<T> \ud639\uc740 \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc774 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4. p.return_value(v) co_return \uad6c\ubb38. \uacb0\uacfc\uac12\uc73c\ub85c v \ub97c \uc804\ub2ec\ud558\uba70, \uadf8 \uac12\uc740 \ub098\uc911\uc5d0 \uc0ac\uc6a9(consume)\ub41c\ub2e4. p.return_value() co_return \uad6c\ubb38. void \ud0c0\uc785\uc5d0 \uc0ac\uc6a9\ub418\uba70, \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\uc744 \uc758\ubbf8\ud558\uae30\ub3c4 \ud55c\ub2e4. \uc7ac\uac1c\ud568\uc218\uac00 \uc885\ub8cc\ub420\ub54c \uc0ac\uc6a9\ub41c\ub2e4. \uc774 \ud568\uc218\uac00 \ud638\ucd9c\ub418\ub294 \uac83\uc740 \"\ub354\uc774\uc0c1 \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\"\uc744 \uc758\ubbf8\ud55c\ub2e4. p.set_exception(e) \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. Resumer \uce21\uc5d0\uc11c \uacb0\uacfc\uac12\uc744 \uc0ac\uc6a9\ud558\ub824\uace0 \ud560\ub54c throw \ub41c\ub2e4. p.yield_value(v) co_yield \ud45c\ud604\uc2dd. return_value(v) \uc640 \uc720\uc0ac\ud558\ub2e4. p.initial_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810(initial suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. p.final_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810(final suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. \uc5ec\uae30\uc11c \uc77c\ubd80 \ud568\uc218\ub4e4\uc740 coroutine_traits<T> \uc640 \uc5f0\uad00\ub418\uc5b4\uc788\ub294\ub370, \uc774\ud6c4\uc5d0 \uc774 \ud0c0\uc785\uc758 \uc720\ub3d9\uc131\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\uaca0\ub2e4. \uc774\uc81c C++ \ucf54\ub8e8\ud2f4\uc758 \uc0ac\uc6a9\ubc29\ubc95\uc73c\ub85c \ucd08\uc810\uc744 \uc62e\uaca8\ubcf4\uc790. Generator \uac1c\ub150 Generator = Iterator + Resumable Function \ubc18\ubcf5\uc790\uac00 \ubcf4\uc774\ub294\uac00? generator<T> \ub294 \uac12\uc758 \uc218\uc5f4(sequence)\uc744 \ucd94\uc0c1\ud654 \ud55c \uac83\uc774\ub2e4. \uc774\ub54c \uac12\uc740 \uc7ac\uac1c\ud568\uc218\uc5d0 \uc758\ud574\uc11c \uc0dd\uc131\ub418\ub294\ub370, \uc7ac\uac1c\ud568\uc218\ub294 \uc0c8\ub85c \ud638\ucd9c\ub418\uba74 \ud568\uc218 \ud504\ub808\uc784\uc774 \ud799 \uc601\uc5ed\uc5d0 \uc720\uc9c0\ub418\ubbc0\ub85c, generator \ub9c8\ub2e4 \uace0\uc720\ud55c \ubb38\ub9e5\uc744 \uac00\uc9c0\uac8c \ub41c\ub2e4. Example \ub2e4\uc74c \ucf54\ub4dc\ub294 N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator \ub97c \uc791\uc131\ud55c \uac83\uc774\ub2e4. #include <experimental/generator> // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc9c0\uc815(Set)\ud558\uace0 \uc911\ub2e8(Suspend)\ud55c\ub2e4. co_yield f1 ; // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uad6c\ud55c \ub4a4 Shift \ud55c\ub2e4. int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // \ub354\uc774\uc0c1 \uac12\uc744 \uc0dd\uc131\ud558\uc9c0 \uc54a\ub294\ub2e4. } void usecase () { // 10\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \ubc1b\ub294\ub2e4. for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc5b4\ub5bb\uac8c \uc774\uac8c \uac00\ub2a5\ud55c\uac78\uae4c? generator<T> \uc758 \uc815\uc758\ub97c \uc0b4\ud3b4\ubcf4\uc790. \uc2e4\uccb4(Detail) \uac04\ub7b5\ud558\uac8c generator<T> \ub97c \uc62e\uaca8\uc654\ub2e4. iterator \uc640 promise_type \uc744 \uc9c0\uc6d0\ud558\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ub610\ud55c begin() / end() \ud568\uc218\ub85c Range-based for loop \ub97c \uc9c0\uc6d0\ud558\uace0 \uc788\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud578\ub4e4 coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc788\ub2e4\uba74 \uc7ac\uac1c\ud574\uc11c \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc788\ub2e4. if ( _Coro ) { _Coro . resume (); // \ud568\uc218\uac00 \ubc18\ud658\ub418\uc5c8\ub098? if ( _Coro . done ()) return { nullptr }; // return end(); } // \uc544\uc9c1 \ub05d\ub098\uc9c0 \uc54a\uc558\ub2e4. // \ub2e4\uc74c\uc5d0 \ub2e4\uc2dc resume\ud558\uc790... return { _Coro }; } iterator end () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc5c6\ub2e4\uba74, \uac12\uc744 \ub354 \uac00\uc838\uc62c \uc218 \uc5c6\ub2e4. return { nullptr }; } ~ generator () { // RAII : \ud568\uc218 \ud504\ub808\uc784\uc744 \ud30c\uad34\ud55c\ub2e4. if ( _Coro ) { _Coro . destroy (); } } }; \uc774\ub97c \ubc14\ud0d5\uc73c\ub85c \uc2e4\uc81c\ub85c\ub294 \uc774\ub7f0 \ucf54\ub4dc\uac00 \ub9cc\ub4e4\uc5b4\uc9c8 \uac83\uc774\ub2e4. void usecase () { // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int > gen = fibonacci ( 10 ); // `iter++`\ub294 delete\ub418\uc5c8\uc73c\ubbc0\ub85c \uc0ac\uc6a9\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc77c\ubc18\uc801\uc778 iterator-for \uad6c\ubb38\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. iterator \ub294 \uc5b4\ub5bb\uac8c \ub418\uc5b4\uc788\uc744\uae4c? template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // \ubc18\ubcf5\uc790 \uc778\ud130\ud398\uc774\uc2a4 struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // \ub2e4\uc74c\uc73c\ub85c \uc774\ub3d9\ud560\ub54c... iterator & operator ++ () { // \ud568\uc218\ub97c \uc7ac\uac1c\ud574\uc11c \uac12\uc744 yield\ud558\ub3c4\ub85d \ud55c\ub2e4. _Coro . resume (); // \ub9cc\uc57d \ud568\uc218\uac00 return\ud588\ub2e4\uba74, \uadf8 \ud578\ub4e4\uc740 generator\uac00 \uc18c\uba78\uc2dc\ud0ac \uac83\uc774\ub2e4. if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // MSVC\uc758 \ucf54\uba58\ud2b8\ub294, \uc694\uc57d\ud558\uc790\uba74, // \ud6c4\uc704\uc99d\uac00\uc2dd\uc740 iterator\ub97c \ub36e\uc5b4\uc4f8 \uc218 \uc788\uace0, // \uc774\ub85c\uc778\ud574 handle\uc774 nullptr\ub85c \ubc14\ub00c\uba74\uc11c // \ud568\uc218 \ud504\ub808\uc784 \ub0b4\uc5d0 \ub9c8\uc9c0\ub9c9 \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc5c6\ub2e4\ub294 \uac83\uc774\ub2e4. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // `promise`\uc5d0 \ud3ec\uc778\ud130\uac00 \uc788\ub2e4. \ud3ec\uc778\ud130\ub97c \ucc38\uc870\ud574 \ud504\ub808\uc784 \uc548\uc758 \uac12\uc744 \uac00\uc838\uc628\ub2e4. _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; \uc774 \ucf54\ub4dc\ub97c \ubcf4\uba74 \ubc18\ubcf5\uc790\uac00 \ud568\uc218\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc7ac\uac1c\ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 generator<T> \uc758 promise_type \uc744 \ud1b5\ud574\uc11c \uac12\uc744 \ud68d\ub4dd\ud55c\ub2e4. \uc774 \uacbd\uc6b0\ub294 usecase \ud568\uc218\uac00 generator \uc758 \ud638\ucd9c\uc790\uba74\uc11c \uc7ac\uac1c\uc790\uc778 \uac83\uc774\ub2e4. \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810 \uc774\uc81c \ud575\uc2ec\uc774 \ub418\ub294 promise_type \uc744 \ubcfc \ucc28\ub840\ub2e4. \uae30\uc220\ub41c \uac83 \ubcf4\ub2e4 \ucf54\ub4dc\uac00 \uc880 \ub354 \uc788\uc9c0\ub9cc \ub2e8\uc21c\ud654 \ud558\uc600\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } \uc774 promise_type \uc740 \uc694\uad6c\uc0ac\ud56d \uc911\uc5d0\uc11c 4\uac1c\uc758 \uba64\ubc84\ud568\uc218\ub97c \ub9cc\uc871\ud55c\ub2e4. get_return_object , initial_suspend , final_suspend , \uadf8\ub9ac\uace0 yield_value \uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. co_yield \ub294 \"\uac12\uc744 \uc9c0\uc815\ud558\uace0 \uc911\ub2e8\ud558\ub77c\"\uc640 \uac19\uc740 \uc758\ubbf8\uc778\ub370, \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774\ub97c \uc774\ub807\uac8c \ubcc0\uacbd\ud55c\ub2e4. co_yield : co_await + p.yield_value(x) \ub530\ub77c\uc11c, co_yield \uc5d0 \uc778\uc790 \ud45c\ud604\uc2dd\uc774 \uc5c6\ub2e4\ub294 \uac83\uc740 \ubd88\uac00\ub2a5 \ud558\ub2e4. x \ub294 void \uac00 \ub420 \uc218 \uc5c6\uae30 \ub54c\ubb38\uc774\ub2e4. \uac19\uc740 \uc774\uc720\ub85c generator<void> \ub294 \ucef4\ud30c\uc77c \uc5d0\ub7ec\uac00 \ub418\uba70, \uc5f0\uc18d\ub41c \uac12\uc758 \ucd94\uc0c1\ud654\ub77c\ub294 \uc815\uc758\uc5d0\ub3c4 \uc704\ubc30\ub41c\ub2e4. \uc5c4\ubc00\ud788 \ub9d0\ud574 \uc5ec\uae30\uc11c co_await \ub294 suspend \ub97c \uc758\ubbf8\ud55c\ub2e4. \uc790\uc138\ud55c \uc124\uba85\uc740 \ud6c4\uc220\ud55c\ub2e4. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud45c\ud604\uc2dd\uc744 \uc544\ub798\uc640 \uac19\uc774 \ubc14\uafbc\ub2e4. // co_yield f1; p . yield_value ( f1 ); // \uac12\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc9c0\uc815\ud558\uace0 co_await suspend_always {}; // \uc911\ub2e8\ud55c\ub2e4. // ... } co_return ; // \ub354\uc774\uc0c1 \uac12\uc774 \uc5c6\ub2e4. } \uc774 \ucf54\ub4dc\uc5d0\ub294 promise_type p{} \uac19\uc740 \ubcc0\uc218 \uc120\uc5b8\uc774\ub098, \ub2e4\ub978 \ud568\uc218\ub4e4\uc758 \ud638\ucd9c\uc774 \uc5c6\ub2e4. \uadf8 \uc774\uc720\ub294 \ub2e4\uc74c \ub2e8\uc6d0\uc5d0\uc11c \ub2e4\ub8e8\uaca0\ub2e4. Resumable Function \uc7ac\uac1c \ud568\uc218 \uc774\ubc88\uc5d4 \uc880 \ub354 \uc0c1\ud5a5\uc2dd\uc73c\ub85c \uc54c\uc544\ubcf4\uc790. \uc608\uc81c\ucf54\ub4dc\ub294 Awaitable Concept\ub97c \uc774\ud574\ud55c \ub4a4\uc5d0 \ubd10\uc57c \ud55c\ub2e4. \uac1c\ub150 Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> \ub294 \ub2e8\uc21c\ud55c \uc608\uc81c\uc600\ub2e4. generator \ub294 coroutine_handle \uc744 \uba64\ubc84\ubcc0\uc218\ub85c \uac00\uc9c0\uace0 \uc788\uc5c8\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ubb34\uc5c7\uc778\uc9c0 \uc0b4\ud3b4\ubd10\uc57c \ud55c\ub2e4. \uc0ac\uc2e4, coroutine_handle \uc758 \uc608\uc804 \uc774\ub984\uc740 resumable_handle \uc600\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 C++\uc0c1\uc5d0\uc11c \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud55c \uac83\uc774\ub77c\uace0 \uc124\uba85\ud588\ub294\ub370, coroutine_handle \ub294 \ub2ec\ub9ac \ub9d0\ud558\uba74 \uc7ac\uac1c\ud568\uc218\uc5d0 \ub300\ud55c \ud578\ub4e4(Resumable Function Handle)\uc774\ub2e4. Windows API\ub97c \uc0ac\uc6a9\ud574\ubcf8 \uacbd\ud5d8\uc774 \uc788\ub2e4\uba74 Handle \uc774 \uacb0\uad6d void* \ub77c\ub294 \uac83\uc744 \uc54c \uac83\uc774\ub2e4. \uc5ec\uae30\uc11c\ub3c4 \ub3d9\uc77c\ud558\ub2e4. \uc55e\uc11c \uc124\uba85\ud588\ub358 \uac83 \ucc98\ub7fc MSVC\ub294 \ud799 \uc601\uc5ed\uc5d0 \ud504\ub808\uc784\uc744 \ub3d9\uc801\ud560\ub2f9\ud558\uace0, \uac70\uae30\uc5d0 \uc57d\uac04\uc758 intrinsic\uc744 \ub354\ud558\ub294 \ud615\ud0dc\ub85c \uc2a4\ud0dd \uc678(stack-less) \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4. coroutine_handle \uc740 \uc774\ub4e4\uc744 \ud558\ub098\uc758 \ud0c0\uc785\uc73c\ub85c \ubb36\uc5b4\ub193\uc740 \uac83\uc774\ub2e4. \uc7ac\uac1c\ud568\uc218\uc758 \ud504\ub808\uc784 \uadf8\ub7ec\uba74, Resumable Frame \uc740 \ub300\uccb4 \uc5b4\ub5bb\uac8c \uc0dd\uacbc\uc744\uae4c? \uc77c\ub2e8 \ud504\ub808\uc784\uc740 Head\uc640 Body\ub85c \ub098\ub25c\ub2e4. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Head // - Fn : \uc7ac\uac1c\ud560 \ub54c \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc758 \uc8fc\uc18c // - cdecl : \uc774 Convention\uc5d0\uc11c \ud568\uc218 \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 Caller \uac00 \ub2f4\ub2f9\ud55c\ub2e4. // - Index : Resumption point\uc758 \uc778\ub371\uc2a4 // 0\ubc88\uc740 \ud568\uc218\uac00 \uc885\ub8cc\ub41c(`done()`) \uacbd\uc6b0\uc5d0 \uc0ac\uc6a9\ud55c\ub2e4. // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Body \uc5d0\ub294... // - Promise \ud0c0\uc785 \uac1c\uccb4 // - \ud504\ub808\uc784\uc73c\ub85c \uc774\ub3d9\uc2dc\ud0a8 Arguments // - \ud568\uc218 Body // - \uc9c0\uc5ed/\uc784\uc2dc \ubcc0\uc218\ub4e4 // - Platform \uc804\uc6a9 // - \ub808\uc9c0\uc2a4\ud130 \ub4f1\ub4f1 // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : \uc774\ub984\ucc98\ub7fc _Resumable_frame_prefix \uac00 \ud568\uc218\ud504\ub808\uc784\uc758 \uc55e\ubd80\ubd84\uc774 \ub41c\ub2e4. MSVC \ub294 \uc774 \uacf5\uac04\uc5d0 sizeof(void *) * 2 (x64 \uc5d0\uc11c 16 \ubc14\uc774\ud2b8)\ub9cc\ud07c\uc758 \uace0\uc815\ub41c \ud06c\uae30\ub97c \uc0ac\uc6a9\ud55c\ub2e4. Fn : cdecl \ud638\ucd9c \uaddc\uc57d\uc73c\ub85c \uc120\uc5b8\ub418\uc5b4\uc788\ub2e4\ub294 \uc810\uc774 \ud2b9\uc774\ud55c\ub370, cdecl \uc5d0\uc11c \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 \ud638\ucd9c\uc790\uc758 \uc5ed\ud560\uc774\uba70, \ub530\ub77c\uc11c Fn \uc744 \ud638\ucd9c\ud558\ub294 \uac83\uc740 \uadf8 \uc2dc\uc810\uc758 \uc2a4\ud0dd\uacfc \ud568\uc218 \ud504\ub808\uc784\uc5d0 \uc601\ud5a5\uc744 \ubbf8\uce58\uc9c0 \uc54a\ub294\ub2e4. Index : \uc7ac\uac1c\ud568\uc218\ub294 \ub2e4\uc218\uc758 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\ub4e4\uc744 \uac00\uc9c0\uace0 \uc788\uace0, Index \ub294 \uac01 \uc9c0\uc810\ub4e4\ub85c switch \ud558\ub294\ub370 \uc0ac\uc6a9\ub41c\ub2e4. Flag : ??? \uc774\uac74 \ub300\uccb4 \ubb58\uae4c ??? Body : N4402\uc5d0 \ud568\uc218 \ud504\ub808\uc784\uc758 \uad6c\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. James McNellis\uc758 \ubc1c\ud45c\uc790\ub8cc\uc5d0 \uc758\ud558\uba74, \ucef4\ud30c\uc77c\ub7ec\uac00 \uc0dd\uc131\ud558\ub294 \ud504\ub808\uc784\uc740 \ub2e4\uc74c\uc744 \ud3ec\ud568\ud55c\ub2e4. \uc77c\ubc18\uc801\uc778 \uc2a4\ud0dd \ud504\ub808\uc784\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // `fibonacci` \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784(\uc608\uc2dc) struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci\ub294 `generator<int>`\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int >:: promise_type _p ; // \ud504\ub808\uc784\uc5d0 \uc778\uc790\ub97c \uc800\uc7a5\ud55c\ub2e4. int _n ; // fibonacci(n); int _f1 , _f2 ; // \uc9c0\uc5ed \ubcc0\uc218 int _i , _f3 ; // \uc784\uc2dc \ubcc0\uc218 // Platform \uc804\uc6a9 \uc800\uc7a5\uc18c // \ub808\uc9c0\uc2a4\ud130\ub098 \uc774\uac83\uc800\uac83... }; Coroutine Traits p.get_return_object() \uc5d0 \ub300\ud574\uc11c \ub2e4\ub8e8\uc9c0 \uc54a\uc558\uc5c8\ub294\ub370, \uc5ec\uae30\uc11c \uac19\uc774 \ub2e4\ub8e8\uace0\uc790 \ud55c\ub2e4. \uba3c\uc800 coroutine_traits \ub97c \ub208\uc5ec\uaca8\ubd10\uc57c \ud55c\ub2e4. // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; \uad49\uc7a5\ud788 \ub2e8\uc21c\ud55c\ub370, coroutine_traits \uc774 \uc694\uad6c\ud558\ub294 \uac83\uc740 \uacb0\uad6d promise_type \ub97c \uad6c\ud604\ud558\ub77c\ub294 \uac83\uc774\ub2e4. \uc774\uc5d0 \ub300\ud55c \uac80\uc0ac\ub294 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uc774\ub8e8\uc5b4\uc9c0\uace0, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement \ub97c \ub9cc\uc871\uc2dc\ucf1c\uc57c \ud55c\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\ub294 future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \uc0ac\uc2e4 \uadf8\uac83\uc740 \ubd80\uc815\ud655\ud55c \uc124\uba85\uc774\uc5c8\ub2e4. coroutine_traits \ub97c \ub9cc\uc871\uc2dc\ud0a4\uae30\ub9cc \ud55c\ub2e4\uba74, \uadf8 \ud0c0\uc785\uc740 \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc774 \ub420 \uc218 \uc788\ub2e4. std::future<T> \ub97c \uc704\ud55c coroutine_traits \uc758 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 \ubc84\uc804\uc744 \uc62e\uaca8\uc654\ub2e4. generator<T> \uc758 \uacbd\uc6b0\ub294 \ub0b4\ubd80\uc5d0 promise_type \uc744 \uad6c\ud604\ud558\uace0 \uc788\uc5c8\ub294\ub370, \uc608\uc804\ubd80\ud130 \uc0ac\uc6a9\ud558\ub358 \ud0c0\uc785\ub4e4\uc774\ub098 \ucee4\uc2a4\ud140 \ud0c0\uc785\ub4e4\uc740 \uc774\ub7f0 \ud2b8\ub9ad\uc744 \uc0ac\uc6a9\ud574\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc720\uc5f0\ud558\uac8c \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. // <future> \ud5e4\ub354 #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // `std::future<T>`\ub97c \uc704\ud55c \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // `future<_Ty>`\ub97c \ubc18\ud658\ud558\ub294 \uc7ac\uac1c\ud568\uc218\ub4e4\uc744 \uc704\ud55c \ud0c0\uc785\uc815\uc758 struct promise_type { // `std::promise<T>`\ub97c \uadf8\ub300\ub85c \uc0ac\uc6a9\ud55c\ub2e4. promise < _Ty > _MyPromise ; // \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc740 `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // `false`\uc77c \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool initial_suspend () const { return ( false ); } // `false`\uc77c \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool final_suspend () const { return ( false ); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif MSVC\ub294 co_await / co_yield / co_return \ud0a4\uc6cc\ub4dc \uc911 \ud558\ub098\ub97c \ud655\uc778\ud558\uba74, coroutine_traits \ub97c \uc0ac\uc6a9\ud574 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uac80\uc0ac\ub97c \uc218\ud589\ud560 \uc218 \uc788\ub3c4\ub85d \ucf54\ub4dc\ub974 \uc0dd\uc131\ud55c\ub2e4. MSVC\uac00 \ud558\ub294 \uc77c\uc744 \ud655\uc778\ud558\uae30 \uc704\ud574 fibonacci \uc608\uc81c\ub85c \ub2e4\uc2dc \uac00\ubcf4\uc790. \uc774 \ucf54\ub4dc\ub294 \ud2c0\ub9b0 \ud615\ud0dc\uc77c \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc815\ud655\ud55c \uba54\ucee4\ub2c8\uc998\uc744 \ud655\uc778\ud558\uac8c \ub418\uba74 \uac31\uc2e0\ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // \ubcc4\uce6d : \ubc18\ud658\ud0c0\uc785 using return_type = generator < int > ; // \ubc18\ud658\ud0c0\uc785\uc774 Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294\uac00? using traits = coroutine_traite < return_type > ; // \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud55c\ub2e4\uba74 \uc774 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4. // fibonacci \ud568\uc218\ub97c \uc704\ud55c \uac00\uc0c1\uc758 \ud504\ub808\uc784. \uc704\uc640 \ub3d9\uc77c\ud558\ub2e4. struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // \ud504\ub808\uc784\uc744 \ub3d9\uc801\uc73c\ub85c \ud560\ub2f9\ud55c\ub2e4. context(ctx)\ub77c\uace0 \ud558\uaca0\ub2e4. // \ud2b9\uc815\ud55c Allocator\ub97c \uc0ac\uc6a9\ud574 \ucee4\uc2a4\ud130\ub9c8\uc774\uc988 \ud560 \uc218\ub3c4 \uc788\uc9c0\ub9cc \uc5ec\uae30\uc120 \ub2e8\uc21c\ud788 new\ub85c \uc124\uba85\ud55c\ub2e4. __frame * ctx = new __frame { std :: move ( n )}; // \ubc18\ud658 \uac1c\uccb4\ub97c \uc0dd\uc131\ud55c\ub2e4. return_type __return = ctx -> _promise . get_return_object (); // true\uc77c \uacbd\uc6b0 \uc911\ub2e8, false\uc77c \uacbd\uc6b0 \uc9c4\ud589\ud55c\ub2e4. if ( ctx -> _promise . initial_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __initial_suspend_point : } // \uc0ac\uc6a9\uc790 \ucf54\ub4dc\ub294 \ud504\ub808\uc784\uc744 \uc0ac\uc6a9\ud558\ub3c4\ub85d \ubcc0\uacbd\ub41c\ub2e4. // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // promise\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // `ctx->_prefix`\uc758 Index\ub97c \uc870\uc815\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4. // co_await suspend_always{}; __suspend_resume_point_1 : // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uacc4\uc0b0\ud558\uace0 Shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __final_suspend_point : } // \uc815\ub9ac\uc791\uc5c5... } \uc0dd\uac01\ubcf4\ub2e4 \ucef4\ud30c\uc77c\ub7ec\uac00 \ub9ce\uc740 \uc791\uc5c5\uc744, \ud558\uc9c0\ub9cc \uae30\uc874\uc5d0 \uc2a4\ud0dd \ud504\ub808\uc784\uc5d0 \ub300\ud574\uc11c \ud558\ub358\uac83\uacfc \uc720\uc0ac\ud55c \uc791\uc5c5\uc744 \ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\uc5c8\ub2e4. ctx \uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ud799\uc601\uc5ed\uc5d0 \uc704\uce58\ud55c \ubcc0\uc218\ub97c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc740 this \ud3ec\uc778\ud130\uc758 \uc0ac\uc6a9\uacfc \ub2e4\ub974\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \uc774\ub7f0 \ud504\ub808\uc784 \uae30\ubc18 \uad6c\ud604\uc758 \ube44\uc6a9\uc740 \ucd94\uac00\uc801\uc778 co_await \uad00\ub828 \ube44\uc6a9\uc774\uc678\uc5d0\ub294 \ubb34\uc2dc\ud560 \uc218 \uc788\ub294 \uc218\uc900\uc77c \uac83\uc774\ub2e4. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend; \uc7a0\uae50 \uc815\ub9ac co_return \uacfc co_yield \uc5d0 \ub300\ud574\uc11c generator<T> \uc608\uc81c\ub97c \ud1b5\ud574 \uc0b4\ud3b4\ubd24\ub2e4. Generator\ub294 \ubc18\ubcf5\uc790\uc640 \uc7ac\uac1c\ud568\uc218\ub97c \ud569\uce5c \uac83\uc774\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 coroutine_handle \uc744 \uc0ac\uc6a9\ud558\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\uc640 \ucef4\ud30c\uc77c\ub7ec Intrinsic\uc744 \ud569\uccd0\ub193\uc740 \uac83\uc774\ub2e4. \ud504\ub808\uc784 \uae30\ubc18\uc758 \uad6c\ud604\uc740 this \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ubcc0\uc218\ub97c \uc870\uc791\ud558\ub294 \uac83\uacfc \uc720\uc0ac\ud558\ub2e4. \ucef4\ud30c\uc77c \uc2dc\uac04(\uc815\uc801) \uac80\uc0ac\ub97c \uc704\ud574 coroutine_traits<T> \uac00 \uc0ac\uc6a9\ub41c\ub2e4. \uc774\ub97c \ud1b5\ud574 promise_type \uc744 \uad6c\ud604\ud558\ub3c4\ub85d \uac15\uc81c\ud558\uba70, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement\ub97c \ub9cc\uc871\ud574\uc57c \ud55c\ub2e4. std::future<T> \uc758 \uacbd\uc6b0 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654\uac00 \uae30\ubcf8\uc801\uc73c\ub85c \uc9c0\uc6d0\ub41c\ub2e4. \"\uae30\ub2e4\ub9b4 \uc218 \uc788\ub2e4\"\ub294 \uac1c\ub150\uc5d0 \ub300\ud574\uc11c operator co_await = Syntactic Sugar + Resumable Function \uc7ac\uac1c\ud568\uc218\uc758 \ub9c8\uc9c0\ub9c9 \ud575\uc2ec\uc740 \ub2e8\ud56d \uc5f0\uc0b0\uc790 co_await \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ubb38\ub9e5\uc0c1\uc73c\ub85c, await\ub294 suspend\uc640 \uac19\uc740\uc758\ubbf8\ub2e4 . \uadf8\ub9ac\uace0 \uc774 \uc911\ub2e8 \ub54c\ubb38\uc5d0, \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \uc790\uc5f0\uc2a4\ub7fd\uac8c \ube44\ub3d9\uae30 \uac00 \ub41c\ub2e4. \uba58\ud0c8 \ubaa8\ub378 \uc0c1\uc5d0\uc11c \uc774\ub7f0 \ud2b9\uc131\uc740 \uaf64 \uc911\uc694\ud55c \uc810\uc778\ub370, C# \uc5b8\uc5b4\uc758 async & await \uae30\ub2a5\uacfc \uc720\uc0ac\ud558\ub2e4\uace0 \ubcfc \uc218 \uc788\ub2e4. C++ \uc138\uc0c1\uc5d0\uc11c \ub2e4\ub978\uc810\uc740, \ud504\ub85c\uadf8\ub798\uba38\uc758 \ucf54\ub4dc\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc9c0\uc6d0\uc744 \uc0ac\uc6a9\ud574\uc11c \uc218\ub3d9\uc73c\ub85c \uad00\ub9ac\ud560 \uc218 \uc788\ub2e4\ub294 \uc810\uc774\ub2e4. Example MSVC \ube14\ub85c\uadf8\uc758 \uc608\uc81c\ub97c \uac00\uc838\uc654\ub2e4. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // \uc5f0\uc0b0\uc790 \uc624\ubc84\ub85c\ub4dc // co_await \ub294 \uae30\ubcf8 \ud0c0\uc785(primitive type) \uc778\uc790\ub294 \ubc1b\uc9c0 \uc54a\ub294\ub2e4. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc120 \ud568\uc218 3\uac1c\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback\uc744 \uc218\ud589\ud558\ub294 Thread\uc5d0\uc11c Resume\ud55c\ub2e4. coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // \uc900\ube44\uac00 \uc548\ub418\uc5c8\uc73c\uba74 (`false`), `await_suspend`\ub97c \ud638\ucd9c\ud55c\ub2e4. // \uac12\uc774 \uc900\ube44\ub418\uc5c8\uc73c\uba74 (`true`), `await_resume`\ub97c \ubc14\ub85c \ud638\ucd9c\ud55c\ub2e4. bool await_ready () const { return duration . count () <= 0 ; } // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \ubb34\uc2dc\ub420 \uc218 \uc788\ub2e4. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // \ud0c0\uc774\uba38\ub97c \uc138\ud305\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4.... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // \uc7ac\uac1c\ub41c \ud6c4\uc5d0\ub294 T \ud0c0\uc785 \uac12\uc744 \ubc18\ud658\ud55c\ub2e4. // `void`\ub3c4 \uac00\ub2a5\ud558\ub2e4. void await_resume () {} }; return awaiter { duration }; } // \ucf54\ub8e8\ud2f4(\uc7ac\uac1c\ud568\uc218) future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // 1 \ubc00\ub9ac\ucd08\ub97c \uae30\ub2e4\ub9b0\ub2e4... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // \ud3c9\ubc94\ud55c \uc11c\ube0c\ub8e8\ud2f4 void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } \uc774 \ucf54\ub4dc\ub294 \ub300\ub7b5 \uc774\ub7f0 \uc2dd\uc73c\ub85c \uc9c4\ud589\ub41c\ub2e4. \uae30\ub2e4\ub9ac\uae30 \uc704\ud55c \uc778\ud130\ud398\uc774\uc2a4 co_await \ub294 \ub3d9\uc791\ud558\uae30 \uc704\ud574\uc11c \ud2b9\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc694\uad6c\ud55c\ub2e4. \uc704\uc5d0\uc11c \ubcf8 \uac83 \ucc98\ub7fc, Awaitable Interface\ub294 3\uac00\uc9c0 \ud568\uc218\ub97c \uad6c\ud604\ud574\uc57c\ub9cc \ud55c\ub2e4. await_ready await_suspend await_resume \uc774\ub4e4\uc740 \uba64\ubc84\ud568\uc218\uc77c \uc218\ub3c4 \uc788\uace0, \uc77c\ubc18 \ud568\uc218\ub85c\ub3c4 \uac00\ub2a5\ud558\ub2e4. future<T> \uc5ed\uc2dc \uc774 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. \ub2ec\ub9ac\ub9d0\ud574, future<T> \uac00 co_await \uc758 \uc778\uc790\uac00 \ub420\uc218\ub3c4 \uc788\ub2e4\ub294 \uc758\ubbf8\ub2e4. \uc544\ub798 \ucf54\ub4dc\ucc98\ub7fc \ube44\ud6a8\uc728\uc801\uc77c \uc218\ub3c4 \uc788\uaca0\uc9c0\ub9cc, \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c \uac04\ub2e8\ud55c \uc624\ubc84\ub85c\ub4dc \ub9cc\uc73c\ub85c\ub3c4 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4\ub294 \uc7a5\uc810\uc774 \uc788\ub2e4. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // future\ub97c await\ud558\uba74 \uc2a4\ub808\ub4dc\ub97c \ub9cc\ub4e4\uc5b4\uc11c detach\uc2dc\ud0a8\ub2e4. // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std \ucef4\ud30c\uc77c\ub7ec \ucabd\uc740 \uc5b4\ub5a8\uae4c? \uc774 \ucf54\ub4dc\uac00 \uc5b4\ub5bb\uac8c \ubc14\ub014\uae4c? \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810 operator co_await = Syntactic Sugar + Resumable Function co_await \ub294 \ud45c\ud604\uc744 \ubc14\uafbc\ub2e4\ub294 \uc810\uc5d0\uc11c \uacb0\uad6d syntatic sugar\ub77c\uace0 \ud560\uc218 \uc788\ub2e4. \uc778\uc790\ud0c0\uc785\uc774 Awaitable Interface\ub97c \uc54c\ub9de\uac8c \uad6c\ud604\ud558\uae30\ub9cc \ud55c\ub2e4\uba74, \ucef4\ud30c\uc77c\ub7ec\ub294 \ucf54\ub4dc\ub97c \ubc14\uafd4\uc900\ub2e4. \uc880\uc804\uc758 \uc608\uc81c\ucf54\ub4dc\ub97c \uc880\ub354 \uc790\uc138\ud558\uac8c \uc0b4\ud3b4\ubcf4\uaca0\ub2e4. // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // `co_await`\ud0a4\uc6cc\ub4dc\uac00 \uc788\uc73c\ubbc0\ub85c \uc7ac\uac1c\ud568\uc218\uac00 \ub41c\ub2e4. future < void > test () { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4... __frame * context ; // ... // Awaitable interface\ub97c \uad6c\ud604\ud558\uc600\ub2e4. // \uc815\ud655\ud558\uac8c\ub294 \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc774 \ubcc0\uc218\uac00 \uc0dd\uc131\ub420 \uac83\uc774\ub2e4. awaiter aw = operator co_await ( 1 ms ); // \uac12\uc774 \uc900\ube44\ub418\uc5b4 \uc788\ub294\uac00? if ( aw . await_ready () == false ) // await_ready(aw); { // \uac12\uc774 \uc5c6\uc73c\ubbc0\ub85c \uae30\ub2e4\ub824\uc57c \ud55c\ub2e4. // \ud568\uc218 \ud504\ub808\uc784\uc744 `coroutine_handle` \ud0c0\uc785\uc73c\ub85c \uac10\uc2f8\uace0... coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); // suspend \ud568\uc218\ub97c \ud638\ucd9c\ud55c\ub2e4. aw . await_suspend ( resume_cb ); // \uc911\ub2e8 \uc9c1\uc804\uc5d0 \ud504\ub808\uc784\uc5d0 Index\ub97c \ubcc0\uacbd\ud558\uace0...... __suspend_resume_point_1 : // \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc774 \uc5ec\uae30\uc5d0 \uc788\uc73c\ubbc0\ub85c ready\uc5d0\uc11c true\ub97c \ubc18\ud658\ud558\uba74 // \ud568\uc218\ub294 \uba48\ucd94\uc9c0 \uc54a\uace0 \uc9c4\ud589\ud55c\ub2e4. } // await_resume\uc774 \ubc18\ud658\ud0c0\uc785\uc774 \uc788\ub2e4\uba74 value\uc5d0 \uac12\uc744 \uc800\uc7a5\ud55c\ub2e4. // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } \uc774\uc81c \uc778\ud130\ud398\uc774\uc2a4\uc758 \uac01 \ud568\uc218\ub4e4\uc5d0 \ub300\ud574\uc11c \uc9da\uc5b4\ubcfc \uc218 \uc788\uaca0\ub2e4. await_ready : \"\uc9c0\uae08 \uac12\uc774 \uc788\ub294\uac00?\" await_ready \uc740 \ubd84\uae30\uc810\uc774 \ub41c\ub2e4. \uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\uba74 await_resume \uc5d0\uc11c \ubc14\ub85c \uadf8 \uac12\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uaca0\uc9c0\ub9cc, \uadf8\ub807\uc9c0 \uc54a\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc73c\ub85c \ubd84\uae30\ud574 \ud568\uc218\ub97c \uc911\ub2e8\ud55c\ub2e4. await_ready \ud568\uc218\uac00 \uc5b8\uc81c\ub098 true \ub97c \ubc18\ud658\ud55c\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc740 Dead Code\uac00 \ub418\uace0, \ucef4\ud30c\uc77c\ub7ec\uc758 \ucd5c\uc801\ud654 \uacfc\uc815\uc5d0\uc11c \uc18c\uba78\ub420 \uac83\uc774\ub2e4. \uc774 \uacbd\uc6b0\ub294 \ud504\ub808\uc784\uae4c\uc9c0 \uc18c\uba78\ub418\uace0 \uc77c\ubc18 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \ucd5c\uc801\ud654\ub420 \uc218 \ub3c4 \uc788\ub2e4. \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8 \ubc94\uc704\ub85c \uc9c4\uc785\ud558\uba74, \ud568\uc218 \ud504\ub808\uc784\uc744 coroutine_handle<> \ub85c \uac10\uc2f8\uc11c \uc778\uc790\ub85c \ub118\uaca8\uc900\ub2e4. coroutine_handle<>::from_address \ud568\uc218\uac00 \uc774 \uc5ed\ud560\uc744 \ud574\uc900\ub2e4. await_suspend : \"\uace7 \ub8e8\ud2f4\uc774 \uba48\ucda5\ub2c8\ub2e4. \ud574\uc57c\ud560 \uc77c\uc774\ub77c\ub3c4?\" await_suspend \ub294 coroutine_handle<> \uc744 \uc778\uc790\ub85c \ubc1b\uace0, \uc911\ub2e8\ud558\uae30 \uc804\uc5d0 \ud574\uc57c\ud560 \ub0b4\uc6a9\uc744 \ucf54\ub4dc\ub85c \ub07c\uc6cc\ub123\uc744 \uc218 \uc788\uac8c \ub41c\ub2e4. // Windows Thread Pool Timer\ub97c \uc0ac\uc6a9\ud55c\ub2e4. // Timer Callback\uc5d0 \ud504\ub808\uc784\uc758 \uc8fc\uc18c\ub97c \ub118\uaca8\uc8fc\ub294 \ubc29\uc2dd\uc73c\ub85c \ucf54\ub8e8\ud2f4\uc744 \ub9c8\ubb34\ub9ac\ud55c\ub2e4. class awaiter { bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // \ud3ec\uc778\ud130\ub85c \ubcc0\ud658\ud55c\ub2e4. resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Windows Thread Pool\uc5d0 \uc788\ub294 \uc2a4\ub808\ub4dc\uac00 Callback\uc744 \ud638\ucd9c\ud558\uac8c \ub41c\ub2e4. // \uc790\uc5f0\uc2a4\ub7fd\uac8c Resumer Thread\uac00 \ub41c\ub2e4. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // \ud504\ub808\uc784 \ud3ec\uc778\ud130\ub97c \ud578\ub4e4\ub85c \ubcc0\ud658, \uadf8\ub9ac\uace0 \uc7ac\uac1c. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"\uc5ec\uae30 \uacb0\uacfc\uac12\uacfc \uc2e4\ud589 \ud750\ub984\uc774\uc694.\" \ud568\uc218\ub97c \uc7ac\uac1c\ud558\uba74 \uc911\ub2e8\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\uba70, \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8\ubc94\uc704\ub97c \ubc97\uc5b4\ub098 await_resume \uc744 \ud638\ucd9c\ud55c\ub2e4. \uc911\ub2e8\ud558\ub358 \uc2dc\uc810\uc5d0\ub294 \uacb0\uacfc\uac12\uc774 \uc5c6\uc5c8\uae30 \ub54c\ubb38\uc5d0, \ud568\uc218\uac00 \uc7ac\uac1c\ub418\uc5c8\ub2e4\ub294 \uac83\uc740 \uacb0\uacfc\uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\ub294 \uc758\ubbf8\uac00 \ub41c\ub2e4. \ub9cc\uc57d void\ub77c\uba74 co_await \uc544\ub798\uc5d0 \uc788\ub294 \ucf54\ub4dc\ub97c \uc2e4\ud589\ud574\uc57c \ud558\ub3c4\ub85d \uc2e4\ud589\ud750\ub984\uc744 \ub118\uaca8\uc900\ub2e4\ub294 \uc758\ubbf8\uc77c \uac83\uc774\ub2e4. co_await Tricks Kenny Kerr \uc640 James Mcnellis \ub294 \uc774\ub7f0 \uba54\ucee4\ub2c8\uc998\uc744 \uc0ac\uc6a9\ud55c \ud2b8\ub9ad\ub4e4\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\ub294\ub370, \uc2dc\uac04\uc801 \uc5ec\uc720\uac00 \uc788\ub2e4\uba74 \uaf2d \ubcf4\uae30\ub97c \uad8c\ud55c\ub2e4. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Async Generator \uac1c\ub150 Async Generator = Awaitable iterator + Resumable function Generator\uc640 \ub9e4\uc6b0 \uc720\uc0ac\ud558\uc9c0\ub9cc, \ub2e4\ub978\uc810\uc740 \ubc18\ubcf5\uc790\uac00 Awaitable\ud558\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub2ec\ub9ac \ub9d0\ud558\uba74, Awaitable iterator \uc5d0 \ub300\ud574\uc11c for co_await \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. Kirkshoop\uc758 \uc124\uba85 \uc774 \ub3c4\uc6c0\uc774 \ub420 \uac83\uc774\ub2e4. Example \uc774 \uae30\ub2a5\uc744 \uc81c\ub300\ub85c \uc0ac\uc6a9\ud574\ubcf4\uc9c0 \ubabb\ud574 \uc81c\ub300\ub85c \ub41c \uc608\uc81c\ub97c \uc801\uc9c0 \ubabb\ud588\ub2e4. \ud558\uc9c0\ub9cc \uc9c0\uae08\uae4c\uc9c0\uc758 \uc608\uc81c\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810\uc5d0 \ub300\ud55c \uc124\uba85\uc744 \uc77d\uc5c8\ub2e4\uba74 \uc774 \ucf54\ub4dc\uac00 \uc774\ud574\ub420 \uac83\uc774\ub77c \uc0dd\uac01\ud55c\ub2e4. // \ubb34\ud55c\ud55c \uc815\uc218 \uc218\uc5f4 async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await \uad6c\ubb38 for co_await ( int v : infinite ()) { // `v`\ub85c \ubb34\uc5b8\uac00 \ud55c\ub2e4... } } iterator \uac00 Awaitable\ud558\ub2e4\uace0 \ud588\ub294\ub370, \uc774\ub294 usecase \uac00 \ub2e4\uc74c\uacfc \uac19\ub2e4\ub294 \uc758\ubbf8\ub2e4. std :: future < void > usecase () { // \uae30\ub2e4\ub9b4 \uc218 \uc788\ub294 \ubc18\ubcf5\uc790 : awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `begin()` \uc5d0 // `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. iter != gen . end (); // `end()` \ub294 nullptr\uc640 \uac19\ub2e4. co_await ++ iter ) // `operator++()`\uc5d0 `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. { int v = * iter ; // ... } } generator<T> \uc608\uc81c\uc640 \ub2e4\ub978 \uc810\uc740 \ud568\uc218\uac00 2\uac1c \uc9c0\uc810\uc5d0\uc11c \ubc18\ubcf5\uc790\ub97c \uae30\ub2e4\ub9ac\uace0 \uc788\ub2e4\ub294 \uac83\uc774\ub2e4. \ub530\ub77c\uc11c begin() \uacfc operator++() \ub294 usecase \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8/\uc7ac\uac1c\uc9c0\uc810\uc774 \ub41c\ub2e4. \uc5ec\uae30\uc120 value_type \uc740 \uae30\ubcf8 \uc790\ub8cc\ud615 int \ub77c\uc11c \uc5b4\ub824\uc6b4 \ucf54\ub4dc\ub294 \uc5c6\ub2e4. Awaitable iterator \ucf54\ub4dc\ub294 \ub2e4\uc74c\ucc98\ub7fc \ub9cc\ub4e4 \uc218 \uc788\ub2e4. \uc0ac\uc2e4 std::experimental::generator<T> \uc758 \ucf54\ub4dc\ub97c \uac70\uc758 \uadf8\ub300\ub85c \uac00\uc838\uc628 \uac83\uc774\ub2e4. // generator\uac00 \uc544\ub2c8\ub77c iterator\uac00 \ube44\ub3d9\uae30\ub85c \ub3d9\uc791\ud55c\ub2e4.(awaitable). template < typename T > struct async_generator { struct promise_type ; // Awaitable interface\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // \uc9c0\uae08\uc740 \uc608\uc81c\uc774\ubbc0\ub85c, \uc5b8\uc81c\ub098 \uac12\uc774 \uc874\uc7ac\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\uc9c0\ub3c4 \uc54a\ub294\ub2e4. bool await_ready () const { return true ; } // \uc911\ub2e8\ud558\uc9c0 \uc54a\uc73c\ubbc0\ub85c \ub0b4\uc6a9\uc774 \uc5c6\ub2e4. void await_suspend ( coroutine_handle <> hcoro ) {} // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc774 `co_await`\uc5d0\uac8c \uc804\ub2ec\ub41c\ub2e4. iterator await_resume () const { return * this ; } }; // iterator }; // async_generator \uba64\ubc84\ud568\uc218 3\uac1c\ub97c iterator \uc5d0 \ucd94\uac00\ud568\uc73c\ub85c\uc368, awaitable \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uc600\uace0 for co_await \uad6c\ubb38\uc744 \uc4f8 \uc218 \uc788\uc5c8\ub2e4. \ud558\uc9c0\ub9cc Awaitable Interface \ub2e8\ub77d\uc5d0\uc11c \uc124\uba85\ud588\ub4ef \uad73\uc774 \uba64\ubc84\ud568\uc218\uc77c \ud544\uc694\ub294 \uc5c6\ub2e4. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } \uc774\ub807\uac8c \ubcf4\uc870 \ud568\uc218\ub97c \uc815\uc758\ud558\ub294 \uac83 \ub9cc\uc73c\ub85c\ub3c4 \uae30\uc874\uc5d0 \uc0ac\uc6a9\ud558\ub358 iterator \ud0c0\uc785\ub4e4\uc744 \uc7ac\ud65c\uc6a9\ud560 \uc218 \uc788\ub2e4. \ub05d! \ud6c4\uae30 MSVC \ucf54\ub8e8\ud2f4\uc758 \uac1c\ub150\uacfc \ucf54\ub4dc\ub97c \ud6d1\uc5b4\ubd24\ub2e4. \uadf8\uac8c \uc804\ubd80\ub2e4. \ubd80\ub514 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uae30\ub97c. \uc0ac\uc2e4 \uc774 Feature\uc758 \ub514\uc2a4\uc5b4\uc148\ube14\ub9ac \uacb0\uacfc\uc5d0 \ub300\ud574\uc11c\ub3c4 \uc4f0\uace0 \uc2f6\uc5c8\ub294\ub370, \uad00\ub828\ud574\uc11c\ub294 \uc544\uc9c1 \ucd08\ubcf4\uc790 \ub2e8\uacc4\ub77c \uc81c\ub300\ub85c \uc124\uba85\ud560 \uc218\uac00 \uc5c6\uc5c8\ub2e4. \uae30\ud68c\uac00 \ub41c\ub2e4\uba74 \ucc28\ud6c4\uc5d0 \ub2e4\uc2dc \uae00\uc744 \uc368\ubcf4\uace0 \uc2f6\ub2e4. \ub098\uc911\uc5d0 \ub354\uc6b1 \uac1c\uc120\ud560 \uae30\ud68c\uac00 \uc788\uae30\ub97c. :D","title":"MSVC Coroutine \uc54c\uc544\ubcf4\uae30"},{"location":"articles/exploring-msvc-coroutine-kor/#msvc-coroutine","text":"Written in 2017/03/02 English","title":"MSVC Coroutine \uc54c\uc544\ubcf4\uae30"},{"location":"articles/exploring-msvc-coroutine-kor/#_1","text":"","title":"\ucc38\uace0\uc790\ub8cc"},{"location":"articles/exploring-msvc-coroutine-kor/#_2","text":"N3858 N3977 N4134 N4402","title":"\uc81c\uc548\uc11c"},{"location":"articles/exploring-msvc-coroutine-kor/#visual-c-team-blog","text":"Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++","title":"Visual C++ Team Blog"},{"location":"articles/exploring-msvc-coroutine-kor/#_3","text":"CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\"","title":"\uc601\uc0c1"},{"location":"articles/exploring-msvc-coroutine-kor/#github","text":"kirkshoop/ await","title":"GitHub \uc800\uc7a5\uc18c"},{"location":"articles/exploring-msvc-coroutine-kor/#_4","text":"\uc6b0\uc120 MSVC\uc758 Coroutine\uc744 \uc0ac\uc6a9\ud558\ub824\uba74 3\uac00\uc9c0\uac00 \ud544\uc694\ud558\ub2e4. Visual Studio 2015 Up3 \ud639\uc740 \uadf8 \uc774\uc0c1\uc758 \uac1c\ubc1c\ud658\uacbd /await : \ucef4\ud30c\uc77c \uc635\uc158 <experimental/*> : \uc18c\uc2a4 \ucf54\ub4dc\uc5d0 \ub123\uc744 \ud5e4\ub354\ud30c\uc77c","title":"\uc8fc\uc758\uc0ac\ud56d"},{"location":"articles/exploring-msvc-coroutine-kor/#_5","text":"\uadf8\ub798\uc11c, \ucf54\ub8e8\ud2f4\uc774 \ub300\uccb4 \ubb54\uac00\uc694?","title":"\uc815\uc758"},{"location":"articles/exploring-msvc-coroutine-kor/#_6","text":"\uae30\ubcf8\uc801\uc73c\ub85c, \ud504\ub85c\uc2dc\uc800\uc758 \ud638\ucd9c\uc740 goto \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uadf8\ub7f0\ub370 \uc5b4\ub514\ub85c goto \ud55c\ub2e4\ub294 \uac83\uc77c\uae4c? \ub2e4\uc74c\uc5d0 \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc77c \uac83\uc774\ub2e4. \uba85\ub839\uc5b4\ub294 \ub8e8\ud2f4\uacfc \ud504\ub85c\uadf8\ub7a8\uc758 \uc77c\ubd80\uc774\uae30\ub3c4 \ud55c\ub370, \uc7a0\uc2dc \uc5ec\uae30\uc11c \ud55c\ubc88 \uc9da\uc5b4\ubcf4\uaca0\ub2e4. [\ud504\ub85c\uadf8\ub7a8]\uc740 \uc77c\ub828\uc758 [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub4e4\ub85c \ubcfc \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc5ec\uae30\uc11c [\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc]\ub780, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c \uac83\uc774\uc5b4\uc57c \ud558\uba70, \ud504\ub85c\uadf8\ub7a8\uc744 \uc218\ud589\ud558\ub294 \uae30\uacc4\uc758 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\uc758 \uac12\ub4e4\uc744 \ud569\uce5c \uac83(composition)\uc774\ub2e4. \ubcf4\ud1b5\uc740 \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac \uac12\uc758 \uc870\ud569\uc774 \uc720\ud55c\ud558\ub3c4\ub85d \uc124\uacc4\ud55c\ub2e4. Program State = Environment X Memory (\ud568\uc218\uc801 \ud569\uc131 : Cartesian Product) \uc5ec\uae30\uc11c \uba85\ub839\uc5b4\ub4e4\uc740 \uc0c1\ud0dc\uac04\uc758 \uc804\uc774(transition)\ub77c\uace0 \uc815\uc758\ud560 \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 \uc774\ub7ec\ud55c \uc804\uc774\ub4e4\uc744 \uc21c\uc11c\ub300\ub85c \ubb36\uc740 \uac83\uc744 \ub8e8\ud2f4(routine)\uc774\ub77c\uace0 \ud55c\ub2e4. Instruction : \uba85\ub839, \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\uc758 \uc804\uc774 Routine : \uc21c\uc11c\uac00 \uc788\ub294 \uba85\ub839 \ubb36\uc74c \uadf8\ub7ec\uba74 \uc774\uc81c \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc73c\ub85c \ub118\uc5b4\uac08 \ucc28\ub840\ub2e4.","title":"\uace0\uc2dd(\u53e4\u5f0f) : \uae30\uacc4\ub808\ubca8\uc5d0\uc11c \uc0dd\uac01\ud558\uae30"},{"location":"articles/exploring-msvc-coroutine-kor/#_7","text":"\ubaa8\ub4e0 \ud504\ub85c\uadf8\ub798\uba38\ub4e4\uc740 \ucf54\ub4dc\uc5d0 \ub300\ud574\uc11c \uc790\uc2e0\ub9cc\uc758 \uc2ec\uc0c1(Mental Model)\uc744 \uac16\uae30 \ub9c8\ub828\uc774\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uacfc \ucf54\ub8e8\ud2f4\uc758 \uba58\ud0c8 \ubaa8\ub378 \ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uace0\uc790 \ud55c\ub2e4.","title":"\uad00\uacc4"},{"location":"articles/exploring-msvc-coroutine-kor/#caller-callee","text":"\uc11c\ube0c\ub8e8\ud2f4\uc758 \uad00\uacc4\ub294 \uc77c\ubc29\uc801\uc774\ub2e4. \ud638\ucd9c\uc790(Caller)\ub294 \uc774\ubbf8 \uc5b4\ub5a4 \uc0c1\ud0dc\uc5d0 \uc788\uace0(\uc774\uc804 \uc870\uac74), \uc5b4\ub5a4 \ub8e8\ud2f4\uc774 \ud544\uc694\ud55c\uc9c0, \ud639\uc740 \ud638\ucd9c\ud560\uc9c0 \uc54c\uace0\uc788\ub2e4. \ud53c\ud638\ucd9c\uc790(Callee)\ub294 \ud504\ub85c\uadf8\ub798\uba38\uc758 \uc758\ub3c4\ub300\ub85c \uc815\uc758\ub41c \ucf54\ub4dc\ub97c \uac00\uc9c0\uace0 \uc788\uace0, \ud638\ucd9c\uc790\uc640 \ubb34\uad00\ud558\uac8c \uba85\ub839\ub4e4\uc744 \uc218\ud589\ud55c\ub2e4. \uc5ec\uae30\uc11c \ubd80\uc218\ud6a8\uacfc(Side-effect)\uac00 \uc788\uc744 \uc218 \uc788\uc9c0\ub9cc, \uadf8\uac74 \uba85\ub839\uc758 \ub0b4\uc6a9\uc5d0 \ub300\ud55c \uac83\uc774\uace0 \uad00\uacc4\uc640\ub294 \ubb34\uad00\ud558\ub2e4.","title":"\uc11c\ube0c\ub8e8\ud2f4 : Caller-Callee"},{"location":"articles/exploring-msvc-coroutine-kor/#activator-activator","text":"\ubcf4\ud1b5 \ucf54\ub8e8\ud2f4\uc740 cooperative\ud55c routine\uc774\ub2e4. \uc774 \ub54c\ubb38\uc5d0 \ud611\ub825\ub8e8\ud2f4\uc774\ub77c\uace0 \ubc88\uc5ed\ub418\uae30\ub3c4 \ud558\ub294\ub370, \uc774\ub7f0 \uc774\ub984\uc740 \ucf54\ub8e8\ud2f4\uc774 \ubb35\uc2dc\uc801\uc73c\ub85c \ub2e4\ub978 \ub8e8\ud2f4\uacfc \ud568\uaed8 \ub3d9\uc791\ud558\ub3c4\ub85d \uc124\uacc4\ub41c \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ub098\uc628 \ub8e8\ud2f4\ub4e4\uc740 \uc11c\ub85c\ub97c \ud65c\uc131\ud654\ud55c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \ud638\ucd9c\uc790(Invoker)\uc640 \uc7ac\uac1c\ub8e8\ud2f4(Resuming routine)\uc5d0 \uc758\ud574\uc11c \ud65c\uc131\ud654 \ub41c\ub2e4. \uc5ed\uc73c\ub85c \uc911\ub2e8\ud558\uac70\ub098 \ubc18\ud658\ud568\uc73c\ub85c\uc368 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\ub978 \ub8e8\ud2f4\uc744 \uc7ac\uac1c\uc2dc\ud0a4\uac8c \ub41c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c\ub294 Suspend/Return\ub4f1\uc73c\ub85c \uad6c\ubd84\ud558\uc600\uc73c\ub098, \ud65c\uc131\ud654\ub77c\ub294 \uac83\uc740 \uc2e4\uc81c\ub85c\ub294 \ub8e8\ud2f4 \uc548\uc758 \uc784\uc758\uc758 \uc9c0\uc810(\uba85\ub839\uc5b4)\uc73c\ub85c \uc810\ud504( goto / jmp )\ud558\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\ub294 \uac83\uc774 \ub2e4\ub978 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uac83\uacfc \uac19\uc744 \uc218 \uc788\uc73c\uba70, \ud568\uc218\uc758 \uc885\ub8cc\uc640 \uc911\ub2e8\uc758 \ucc28\uc774 \ub610\ud55c \ud655\uc5f0\ud558\uc9c0 \uc54a\uc744 \uc218 \uc788\ub2e4. \uc810\ud504\uc758 \ubaa9\ud45c\uc8fc\uc18c\uac00 \ub8e8\ud2f4\uc758 \ub3c4\uc785\ubd80(\ud568\uc218\ub77c\uba74 prologue)\ub77c\uba74 \ud65c\uc131\ud654\ub294 Invocation ( call )\uc774 \ub41c\ub2e4. \ubaa9\ud45c\uc8fc\uc18c\uac00 \ud504\ub85c\uc2dc\uc800\uc758 \ud55c\uac00\uc6b4\ub370 \uc704\uce58\ud558\uba74, \uc774\ub294 Activation ( resume )\uc774 \ub41c\ub2e4. Invocation: \ud638\ucd9c. \ub8e8\ud2f4\uc758 \uc2dc\uc791\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Activation: \ud65c\uc131\ud654. \ub8e8\ud2f4\uc758 \uc784\uc758 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc, \ucf54\ub8e8\ud2f4\uc740 \uc774\uc804 \uc0c1\ud0dc(Pre-condition)\uc640 \uc774\ud6c4 \uc0c1\ud0dc(Post-condition)\uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. \uc774 \ub9d0\uc740, \ucf54\ub8e8\ud2f4 \ub610\ud55c \ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc\ub97c \uc5b4\ub5bb\uac8c \uc804\uc774\uc2dc\ud0ac\uc9c0 \uc815\uc758\ub418\uc5b4\uc57c \ud55c\ub2e4\ub294 \ub9d0\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc11c\ube0c\ub8e8\ud2f4\uacfc\ub294 \ub2e4\ub974\uac8c, \ucf54\ub8e8\ud2f4\uc740 \uc790\uc2e0\ub9cc\uc758 \uc0c1\ud0dc\ub97c \uc720\uc9c0\ud55c \ucc44\ub85c \ub2e4\ub978 \uc8fc\uc18c\ub85c goto \ud560 \uc218 \uc788\ub2e4. \uc774\ub97c Suspension ( yield )\uc774\ub77c \ud55c\ub2e4. \uacbd\uc6b0\uc5d0 \ub530\ub77c \uc774\ub294 \ud504\ub85c\uc2dc\uc800\uc758 \uc885\ub8cc, \ud639\uc740 \ud568\uc218\uc758 \ubc18\ud658( return )\uc774 \ub420\uc218 \uc788\uc73c\uba70, \uadf8\ub54c\ub294 \uc885\ub8cc(finalization)\ub97c \ud568\uaed8 \uc218\ud589\ud558\uac8c \ub41c\ub2e4. Suspension: \uc911\ub2e8. \uc885\ub8cc\uc791\uc5c5 \uc5c6\uc774 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83 Finalization: \uc885\ub8cc. \ub8e8\ud2f4\uacfc \uad00\ub828\ub41c \uc790\uc6d0\ub4e4\uc744 \uc815\ub9ac(\ud30c\uad34)\ud558\uace0 \ub2e4\ub978 \uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\ub294 \uac83","title":"\ucf54\ub8e8\ud2f4 : Activator-Activator"},{"location":"articles/exploring-msvc-coroutine-kor/#_8","text":"\uc694\ucee8\ub300 \uac00\uc7a5 \ud070 \ucc28\uc774\uc810\uc740, \ucf54\ub8e8\ud2f4\uc740 \uc11c\ube0c\ub8e8\ud2f4\ubcf4\ub2e4 \ub354 \ub9ce\uc740 \ub3d9\uc791(Operation)\uc744 \uc9c0\uc6d0\ud55c\ub2e4\ub294 \uac83\uc774\ub2e4. \uc774\uac83\uc774 \ub3c4\ub110\ub4dc \ud06c\ub204\uc2a4\uac00 The Art of Computer Programming \uc5d0\uc11c \uc774\ub807\uac8c \uc11c\uc220\ud55c \uc774\uc720\ub2e4. \"Subroutines are special cases of ... coroutines\" - Donald Knuth \uc774\ub97c \ud45c\ub85c \uc815\ub9ac\ud558\uba74 \ub2e4\uc74c\uacfc \uac19\ub2e4. Operation Subroutine Coroutine Invoke o o \ud504\ub85c\uc2dc\uc800\ub97c \uc2dc\uc791\ud55c\ub2e4 Activate x o \ud2b9\uc815\ud55c \uc9c0\uc810\uc73c\ub85c \uc9c4\uc785\ud55c\ub2e4 Suspend x o Control Flow\ub97c \uba48\ucd98\ub2e4. Finalize o o \uc9c0\uc5ed\ubcc0\uc218, \ub9e4\uac1c\ubcc0\uc218\ub4e4\uc744 \uc815\ub9ac\ud558\uace0 return \ud55c\ub2e4. \uc11c\ube0c\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc774 \uc81c\ud55c\ub418\uc5c8\uc9c0\ub9cc \uad00\uacc4\uc5d0 \ub300\ud55c \uace0\ub824\uac00 \ud544\uc694\uc5c6\uc5b4 \uac04\ub2e8\ud558\ub2e4. \ubc18\uba74\uc5d0 \ucf54\ub8e8\ud2f4\uc740 \ub354 \ub9ce\uc740 \ub3d9\uc791\uc774 \uac00\ub2a5\ud558\uc9c0\ub9cc, \uc911\ub2e8\uacfc \ud65c\uc131\ud654\uc5d0 \ub300\ud55c(\uadf8\ub9ac\uace0 \uac01\uac01\uc758 Pre/Post condition\uc5d0 \ub300\ud55c) \uc815\uc758\uac00 \ud544\uc694\ud558\ubbc0\ub85c \ub354 \ubcf5\uc7a1\ud558\ub2e4. Routine: \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub97c \ubcc0\ud654\uc2dc\ud0a4\ub294 \uba85\ub839\uc5b4 \ubb36\uc74c. \uadf8 \ub0b4\uc6a9\uc740 \ud504\ub85c\uadf8\ub798\uba38\uac00 \uc815\uc758\ud55c\ub2e4. Subroutine: \ub3d9\uc791 2\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Finalize Coroutine: \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Invoke Activate Suspend Finalize","title":"\ucc28\uc774\uc810?"},{"location":"articles/exploring-msvc-coroutine-kor/#_9","text":"\ud06c\ub204\uc2a4\ub294 \uc774\ub7f0 \uac1c\ub150\uc774 \uc5b4\ub5bb\uac8c \ucf54\ub4dc\ub85c \ud45c\ud604\ub418\ub294\uc9c0 \uadf8\uc758 \ucc45\uc5d0\uc11c \uc124\uba85\ud558\uace0 \uc788\ub2e4. \ub2e4\uc74c \ucf54\ub4dc\ub294 The Art of Computer Programming\uc5d0 \uc788\ub294 MIX \uba85\ub839\uc5b4\ub4e4\uc744 \uadf8\ub300\ub85c \uc62e\uaca8\uc628 \uac83\uc73c\ub85c, \ubaa8\ub450 \uc774\ud574\ud560 \ud544\uc694\ub294 \uc5c6\ub2e4. \uc624\ub298\ub0a0\uc758 call / return \uad6c\uc870\uc640 \ub2ec\ub9ac, \ubaa8\ub4e0 \ub3d9\uc791\ub4e4\uc774 JMP \uba85\ub839\uc5b4\ub85c \uc218\ud589\ub418\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ud575\uc2ec\uc740 \ucf54\ub8e8\ud2f4\uc740 \ub2e4\uc218\uc758 \uc9c4\uc785\uc810\uacfc \uc911\ub2e8\uc810\uc744 \uac00\uc9c4\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub354\ud574\uc11c, \ubb35\uc2dc\uc801\uc778 \uc0c1\ud0dc(\ub808\uc9c0\uc2a4\ud130 \ud639\uc740 \uba54\ubaa8\ub9ac)\ub97c \uac00\uc9c8 \uc218\ub3c4 \uc788\ub2e4. // MIX \uc608\uc81c, \uc8fc\uc11d\uc744 \ubcc0\uacbd\ud558\uc600\uc74c // \uc790\uc138\ud55c \ub0b4\uc6a9\uc740 The Art of Computer Programming 1.4.2 \uc5d0 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF .","title":"\uc608\uc81c"},{"location":"articles/exploring-msvc-coroutine-kor/#_10","text":"","title":"\ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378"},{"location":"articles/exploring-msvc-coroutine-kor/#_11","text":"\"\ud568\uc815\uc774\ub2e4!\" - \uc544\ud06c\ubc14 \uc81c\ub3c5 \uc624\ub298\ub0a0 \ub110\ub9ac \uc0ac\uc6a9\ub418\uace0 \uc788\ub294 High-level \uc5b8\uc5b4\ub4e4\uc740 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c\ub2e4. \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc740 \uc5b8\uc5b4\uc801\uc73c\ub85c \uba85\ud655\ud558\uac8c \uc815\uc758\ub418\uace0, \uc790\ub3d9\uc73c\ub85c \uad00\ub9ac\ub418\uba70, \ud504\ub85c\uadf8\ub798\uba38\uac00 \uac1c\uc785\ud558\uc9c0 \uc54a\uc544\ub3c4 \ubb38\uc81c\uc5c6\uc774 \ub3d9\uc791\ud55c\ub2e4. \uad6c\uc870\uc801 \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc774\ub7f0 \uc2a4\ud0dd\uc911\uc2ec\uc758 \ubaa8\ub378\uacfc \uc870\ud654\ub97c \uc774\ub8e8\uc5b4\uc654\ub2e4. \uc774 \ubaa8\ub378\uc5d0\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uc218\ud559\uc801\uc73c\ub85c \ud45c\ud604\ud560 \uc218 \uc788\ub294 \uc218\uc2dd\ud2b8\ub9ac \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \uacb0\uacfc\uc801\uc73c\ub85c main \ud568\uc218\ub294 \uc885\ub8cc\ud558\uba70, \uc801\ub2f9\ud55c \uacb0\uacfc\uac12\uc744 \ubc18\ud658\ud55c\ub2e4. \uadf8\ub9bc\uc5d0\uc11c \ud45c\ud604\ud55c \uac83 \ucc98\ub7fc, \ud2b8\ub9ac\ud615 \ubaa8\ub378\uc5d0\uc11c \ud568\uc218\uc758 \ud750\ub984\uc740 \uc774 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uae4a\uc774-\uc6b0\uc120 \uc21c\uc11c\ub85c \uc21c\ud68c\ud558\uba70, \uc791\uc131\ud558\ub294 \uc2dc\uc810\ubd80\ud130 \uac01 \uad6c\ubb38(Statement)\ub4e4\uc758 \uc2e4\ud589 \uc21c\uc11c\uac00 \uc815\ud574\uc9c4\ub2e4. \uadf8\ub9bc\uc5d0\uc11c B \uad6c\ubb38\uc5d0 \ub3c4\ub2ec\ud558\uae30 \uc704\ud574\uc120, A \uad6c\ubb38\uc744 \ub9c8\uccd0\uc57c \ud55c\ub2e4. \uc774 \uc2dc\uc810\uc5d0 \ud504\ub85c\uadf8\ub7a8\uc758 \uc0c1\ud0dc\ub294 \uad6c\ubb38 A\uc758 \uc601\ud5a5\uc744 \ubc1b\uc544 \ubcc0\ud558\uac8c \ub418\uba70, \ub808\uc9c0\uc2a4\ud130/\uba54\ubaa8\ub9ac\ub294 \uc801\ub2f9\ud55c \uac12\uc744 \uac00\uc9c0\uace0 \uc788\uc744 \uac83\uc774\ub2e4.","title":"\uc2a4\ud0dd\uc774\ub2e4!"},{"location":"articles/exploring-msvc-coroutine-kor/#blocking","text":"\uc5ec\uae30\uc11c \ubb38\uc81c\uac00 \ub418\ub294 \uac83\uc740 \uc758\uc874\uc131\uc774\ub2e4. \ud2b8\ub9ac \ubaa8\ub378\uc740 \uc218\ud559\uc744 \ud504\ub85c\uadf8\ub7a8\uc73c\ub85c \uc62e\uaca8\ub193\uc740 \uac83\uc774\ub2e4. \uc218\uc2dd\uc5d0 \ud544\uc694\ud55c \ubaa8\ub4e0 \uac12\uc774 \uba54\ubaa8\ub9ac\uc5d0 \uc788\ub2e4\uba74, \ucef4\ud4e8\ud130\ub294 \uacc4\uc0b0\uc744 \ub3c4\uc911\uc5d0 \uba48\ucd94\uc9c0 \uc54a\uace0\ub3c4 \uc218\ud589\ud560 \uc218 \uc788\ub2e4. \ub2e4\ub9cc \uc6b0\ub9ac\uc758 \uc790\uc6d0\uc740 \ubb34\ud55c\ud558\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \ud504\ub85c\uadf8\ub7a8 \ud750\ub984\uc774 \uc2dc\uc791\ub418\ub294 \uc2dc\uc810\uc5d0 \ubaa8\ub4e0 \uac12\ub4e4\uc744 \uc900\ube44\ud560 \uc218\ub294 \uc5c6\ub2e4. \ub2e4\ub978 \uc6d0\uc778\ub3c4 \uc788\ub2e4. \uac12\uc774 \ubb3c\ub9ac\uc801\uc73c\ub85c \uac81\ub098 \uba3c \uacf3\uc5d0 \uc788\uc5b4\uc11c \uc2e4\uc2dc\uac04 \ud1b5\uc2e0\uc744 \ud574\uc57c\ud560\uc218\ub3c4 \uc788\ub2e4. \uacb0\uad6d \uc6b0\ub9ac\ub294 \ud544\uc5f0\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc744 \ud574\uc57c\ud55c\ub2e4. \uc804\ud1b5\uc801\uc73c\ub85c \uc785\ucd9c\ub825\uc740 \ub290\ub9ac\uace0, \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc11c \ud504\ub85c\uadf8\ub7a8\uc740 \uba48\ucdb0\uc57c \ud588\ub2e4. \ubc18\uc751\uc131(Responsiveness)\uc744 \uc704\ud574 \ud504\ub85c\uadf8\ub7a8\uc774 \uba48\ucd94\uae30\ub97c \uc6d0\ud558\uc9c0 \uc54a\ub294\ub2e4\uba74 \uc5b4\ub5a8\uae4c? Non-blocking\uacfc \ube44\ub3d9\uae30(Asynchronous) \ud504\ub85c\uadf8\ub798\ubc0d \ubaa8\ub378\uc740 \uc5ec\uae30\uc11c \uc2dc\uc791\ud55c\ub2e4. \uc774\ub294 \uc694\uc57d\ud558\uc790\uba74 \uae30\uc874\uc758 \uc218\uc2dd\ud2b8\ub9ac\ub97c \uc77c\ubc18\ud654 \ud574\uc11c, \ud558\ub098\uc758 \uadf8\ub798\ud504\ub97c \uc791\uc131\ud558\ub294 \uac83\uc774\ub2e4. \uc0c1\ud0dc\uae30\uacc4\uac00 \uadf8\ub798\ud504\ub85c \ud45c\ud604\ub41c\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud574\ubcf4\ub77c. \uc774 \uadf8\ub798\ud504 \ubaa8\ub378\uc5d0\uc120 \ud504\ub85c\uadf8\ub7a8\uc740 \uc0c1\ud0dc\ub4e4\ub85c \uc774\ub8e8\uc5b4\uc9c4 \uadf8\ub798\ud504 \uac00 \ub41c\ub2e4. \uadf8\ub9ac\uace0 \ud504\ub85c\uc138\uc11c\ub4e4\uc740 \uc774 \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\ub294 \uac83\uc774\ub2e4. \ud504\ub85c\uc138\uc11c\ub294 \uc6b4\uc601\uccb4\uc81c\uc758 \ud504\ub85c\uc138\uc2a4, \uc2a4\ub808\ub4dc\uc77c \uc218 \uc788\ub2e4. \ub610\ub294 \uc5b8\uc5b4\ub808\ubca8\uc5d0\uc11c \uc9c0\uc6d0\ud558\ub294 \ucd94\uc0c1\ud654, \uac00\ub839 Erlang\uc758 \ud504\ub85c\uc138\uc2a4\ub098 Go\uc5b8\uc5b4\uc758 Goroutine\uc77c \uc218 \uc788\ub2e4. \ub354 \uc774\uc0c1\uc758 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc0dd\ub7b5\ud55c\ub2e4.","title":"Blocking"},{"location":"articles/exploring-msvc-coroutine-kor/#_12","text":"\ud575\uc2ec\uc740, \uadf8\ub798\ud504\ub97c \uc21c\ud68c\ud558\uba74\uc11c \uc5b4\ub5bb\uac8c \uc815\uc810\uac04\uc758 \ubb38\ub9e5(context) \uad50\ud658\uc774 \uac00\ub2a5\ud560\uae4c \ud558\ub294 \uac83\uc774\ub2e4. \uc6b0\uc120 \uc11c\ube0c\ub8e8\ud2f4\uc740 return \uacfc \ub3d9\uc2dc\uc5d0 \ud30c\uad34\ub418\ubbc0\ub85c(\uc0ac\ub77c\uc9c0\ubbc0\ub85c) \uc774\uac83\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. \ub2ec\ub9ac \ub9d0\ud574 \uc11c\ube0c\ub8e8\ud2f4\uc740 \uc601\uc18d\uc131\uc774 \uc5c6\ub2e4. \uc774\ub294 \ub7f0\ud0c0\uc784 \uc2a4\ud0dd\uc774 \ub3d9\uc791\ud558\ub294 \ubc29\uc2dd\uc774\uc9c0\ub9cc, \ub3d9\uc2dc\uc5d0 \uc815\uc810(\ud504\ub85c\uadf8\ub7a8 \uc0c1\ud0dc)\uac04\uc758 \ubb38\ub9e5\uc804\ub2ec\uc744 \uc544\uc8fc \uc5b4\ub835\uac8c \ub9cc\ub4e4\uc5c8\ub2e4. \ucf5c\ubc31 \uc9c0\uc625 \ub3c4 \uacb0\uad6d\uc740 \ubb38\ub9e5\uc804\ub2ec\uc744 \ud558\uae30 \uc704\ud55c \uace0\uc721\uc9c0\ucc45\uc774\ub77c \ud560 \uc218 \uc788\ub2e4. \"\uc81c\uc784\uc2a4, \uc774 \ucf54\ub4dc\uc5d0\ub294 \ubc84\uadf8\uac00 \uc788\uc5b4\uc694. \uace0\uce60 \uc218 \uc788\uaca0\uc5b4\uc694?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); }","title":"\uc601\uc18d\uc131"},{"location":"articles/exploring-msvc-coroutine-kor/#_13","text":"\uc6b0\ub9ac\uc5d0\uac90 \uc601\uc18d\uc131 \uc788\ub294 \ud568\uc218\uac00 \ud544\uc694\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc(finalization)\ud558\uc9c0 \uc54a\uc73c\uba74\uc11c \uc911\ub2e8(suspend/yield)\uc774 \uac00\ub2a5\ud588\ub2e4\ub294 \uc810\uc744 \uc0dd\uac01\ud558\uba74, \ub2f5\uc740 \uba85\ud655\ud558\ub2e4. \ucf54\ub8e8\ud2f4\uc774 \uc788\uc73c\uba74 \uc774 \ubb38\uc81c\ub97c \ud574\uacb0\ud560 \uc218 \uc788\uc744 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc5b4\ub85c \uad6c\ud604\ud558\ub358 \uac1c\ub150\uc744 \uc5b4\ub5bb\uac8c \uc2a4\ud0dd \uc138\uc0c1\uc73c\ub85c \uac00\uc838\uc62c \uc218 \uc788\uc744\uae4c? \uc9c8\ubb38\uc744 \ubc14\uafd4\ubcf4\uc790. \ubb34\uc5c7\uc774 \uc601\uc18d\uc131\uc744 \uac00\uc838\uc57c \ud558\ub294\uac00?: \ubb38\ub9e5 \ubb38\ub9e5\uc740 \ubb34\uc5c7\uc778\uac00?: \ub8e8\ud2f4\uc758 \uc0c1\ud0dc \uc0c1\ud0dc\ub294 \ubb34\uc5c7\uc73c\ub85c \uc774\ub8e8\uc5b4\uc9c0\ub294\uac00?: \ud658\uacbd & \uba54\ubaa8\ub9ac \ud658\uacbd\uacfc \uba54\ubaa8\ub9ac\ub294 \uc5b4\ub514\uc5d0 \uc704\uce58\ud558\ub294\uac00?: \ud568\uc218 \ud504\ub808\uc784(Function Frame) \uc815\ub9ac\ud558\uc790\uba74, \uc9c8\ubb38\uc740 \uc5b4\ub5bb\uac8c \ud568\uc218 \ud504\ub808\uc784\ub4e4\uc744 \uc601\uc18d\uc131\uc788\uac8c \ub9cc\ub4e4 \uac83\uc778\uac00 \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc124\uba85\uc740 \uc790\uc138\ud788 \uae30\uc220\ud558\uc9c0\ub294 \uc54a\uaca0\uc9c0\ub9cc, \uc790\uc138\ud55c \uc124\uba85\uc744 \uc6d0\ud55c\ub2e4\uba74 \uc774 \ud398\uc774\uc9c0 \ub97c \ucc38\uace0\ud558\ub77c.","title":"\uc811\uadfc\ubc95"},{"location":"articles/exploring-msvc-coroutine-kor/#_14","text":"\"\uc65c \uc740\ud589\uc744 \ud130\ub098\uc694?\" \"\ub3c8\uc774 \uac70\uae30\uc5d0 \uc788\uc796\uc544\uc694\" - \uc5b4\ub290 \uc740\ud589 \uac15\ub3c4","title":"\uc2a4\ud0dd \uc548? \ubc16!"},{"location":"articles/exploring-msvc-coroutine-kor/#stack-ful","text":"\uc5b8\uc5b4\ub9c8\ub2e4 \ub2e4\ub974\uaca0\uc9c0\ub9cc, C++\ub294 \ud568\uc218 \ud504\ub808\uc784\uc744 \uc2a4\ud0dd\uc5d0 \ubc30\uce58\ud55c\ub2e4. \uc774\ub7f0 \uc0c1\ud669\uc5d0\uc11c \ud504\ub808\uc784\uc744 \ubcf4\uc874\ud558\ub824\uba74, \ud504\ub808\uc784\uc744 \uadf8\ub300\ub85c \ubcf5\uc0ac\ud574\uc11c \uc5b4\ub518\uac00\uc5d0 \uc800\uc7a5\ud574\ub450\ub294 \uc218 \ubc16\uc5d0 \uc5c6\ub2e4. \ub2e4\ub978 \ubc29\ubc95\uc73c\ub85c\ub294 \uc801\ub2f9\ud55c \uacf5\uac04\uc744 \ub530\ub85c \uc608\uc57d\ud574\uc11c \ub300\uccb4 \uc2a4\ud0dd(side stack)\uc73c\ub85c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc774 \uc788\uc744 \uac83\uc774\ub2e4. \uc774 \ubd80\ubd84\uc740 \uc9c0\ub098\uce58\ub3c4\ub85d \ud558\uaca0\ub2e4. MSVC\ub294 \uc2a4\ud0dd \uc678 \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4.","title":"\uc2a4\ud0dd \ub0b4(Stack-ful) \ucf54\ub8e8\ud2f4 / \ubd84\ud560 \uc2a4\ud0dd"},{"location":"articles/exploring-msvc-coroutine-kor/#stack-less","text":"N3858 \uc81c\uc548\uc11c\uc5d0\ub294 \uc774\ub978\ubc14 '\ub2e4\uc2dc \uc2dc\uc791\ud558\ub294 \ud568\uc218'(Resumable Function, \uc774\ud558 \uc7ac\uac1c\ud568\uc218)\uc758 \uad6c\ud604\uac00\ub2a5\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uadf8 \ubc29\ubc95\ub860 \uc911 \ud558\ub098\ub294 \ud799(Heap)\uc5d0 \ud568\uc218\uc758 \ud65c\uc131 \ud504\ub808\uc784(Activation Frame)\uc744 \ud560\ub2f9\ud558\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud504\ub808\uc784\uc740 \ub2e8\uc21c\ud558\uac8c\ub294 \uad6c\uc870\uccb4\uc77c \ubfd0\uc774\ub2e4. \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791 4\uac1c\ub294 \uc5b4\ub5bb\uac8c \ub41c \uac83\uc77c\uae4c? \uc774\ub4e4\uc740 Compiler Intrinsic \ud615\ud0dc\ub85c MSVC\uac00 \uc790\uccb4\uc801\uc73c\ub85c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... \uadf8\ub7ec\ub2c8 \uc774 \ubd80\ubd84\uc5d0 \ub300\ud574\uc11c\ub294 \uc190\ub308 \uc218 \uc788\ub294 \ubd80\ubd84\uc774 \uc5c6\ub2e4. \ub354 \uc790\uc138\ud55c \uc124\uba85\uc774 \ud544\uc694\ud558\ub2e4\uba74 \ucc38\uace0\uc790\ub8cc\uc5d0\uc11c CppCon \ubc1c\ud45c\ub4e4\uc744 \uc2dc\uccad\ud558\uae30\ub97c \uad8c\ud55c\ub2e4. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block \uc774 intrinsic\ub4e4 \uc911 Frame\uacfc Block\ub4e4\uc758 \uc5ed\ud560\uc5d0 \ub300\ud574\uc11c \uba85\ud655\ud558\uc9c0 \uc54a\uc740 \ubd80\ubd84\uc774 \ub0a8\uc544\uc788\ub294 \uac83 \uac19\uc2b5\ub2c8\ub2e4. \uae30\ud68c\uac00 \ub418\uba74 \uc5c5\ub370\uc774\ud2b8 \ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4.","title":"\uc2a4\ud0dd \uc678(Stack-less) \ucf54\ub8e8\ud2f4\uacfc \ud568\uc218 \ud504\ub808\uc784"},{"location":"articles/exploring-msvc-coroutine-kor/#the-c-coroutine-resumable-function","text":"\uc774 \uc2dc\uc810\uc5d0\uc11c \ub450 \uc6a9\uc5b4\ub97c \uc815\ub9ac\ud560 \ud544\uc694\uac00 \uc788\uc744 \uac83 \uac19\ub2e4. Coroutine : \uac1c\ub150 . \ub3d9\uc791 4\uac1c\ub97c \uc9c0\uc6d0\ud558\ub294 \ub8e8\ud2f4 Resumable Function : C++ \uc5b8\uc5b4\uc5d0\uc11c Coroutine\uc758 \uad6c\ud604 \ubc29\ubc95 \ucd94\uac00\ub85c \ub2e4\uc74c \ud45c\ub294 \ucf54\ub8e8\ud2f4\uc758 \ub3d9\uc791\ub4e4\uc744 \uc5b4\ub5bb\uac8c \uc0ac\uc6a9\ud558\ub294\uc9c0 \uc815\ub9ac\ud55c \uac83\uc774\ub2e4. Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return","title":"The C++ Coroutine : Resumable Function"},{"location":"articles/exploring-msvc-coroutine-kor/#invoke","text":"\ud568\uc218 \ud638\ucd9c\uc5d0 \ub300\ud574\uc11c\ub294 \ubcc0\uacbd\uc0ac\ud56d\uc774 \uc5c6\ub2e4. \ud558\uc9c0\ub9cc \uc7ac\uac1c\ud568\uc218\ub294 std::future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4.","title":"\ud638\ucd9c(Invoke)"},{"location":"articles/exploring-msvc-coroutine-kor/#finalize","text":"\uc11c\ube0c\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ubc18\ud658\uc9c0\uc810\uc740 \uc775\ud788 \uc54c\ub824\uc9c4 return \ud0a4\uc6cc\ub4dc\ub97c \uc0ac\uc6a9\ud558\uba74 \ub41c\ub2e4. \ucf54\ub8e8\ud2f4\uc774\ub77c\uba74 co_return \ud0a4\uc6cc\ub4dc\uac00 \uc774 \uc5ed\ud560\uc744 \ub300\uc2e0\ud55c\ub2e4.","title":"\uc885\ub8cc(Finalize)"},{"location":"articles/exploring-msvc-coroutine-kor/#suspend","text":"\ud568\uc218\ub97c \uc911\ub2e8\ud558\uace0 Control Flow\ub97c \uc591\ubcf4\ud558\ub294 \ubc29\ubc95\uc740 co_yield expression\uacfc co_await \uc5f0\uc0b0\uc790\ub97c \uc0ac\uc6a9\ud558\ub294 \uac83\uc774\ub2e4. \uc774 \ub458 \uc911 \ud558\ub098\ub77c\ub3c4 \uc0ac\uc6a9\ud558\uba74, \uadf8 \uc9c0\uc810\uc740 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc73c\ub85c \uc0ac\uc6a9\ub418\uba70 MSVC\ub294 \uadf8 \ud568\uc218\ub97c \uc7ac\uac1c\ud568\uc218\ub85c \ub9cc\ub4e4\uac8c \ub41c\ub2e4. (\ub354\ud574\uc11c co_return \uad6c\ubb38\ub3c4 \ud568\uc218 \ub0b4\uc5d0 \uc704\uce58\ud558\uba74 \uc7ac\uac1c\ud568\uc218\ub85c \uc778\uc2dd\ub41c\ub2e4.)","title":"\uc911\ub2e8(Suspend)"},{"location":"articles/exploring-msvc-coroutine-kor/#activate","text":"\uc911\ub2e8\ub41c \ud568\uc218\ub97c \ud65c\uc131\ud654 \ud560 \ub54c\ub294, coroutine_handle \uacfc \uba64\ubc84\ud568\uc218 .resume() \ub97c \uc0ac\uc6a9\ud55c\ub2e4. \uc774 \ud638\ucd9c\uc740 Compiler Intrinsic\uc778 _coro_resume \uc704\uc5d0 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc62c\ub9b0 \uac83\uc774\ub2e4.","title":"\ud65c\uc131\ud654(Activate)"},{"location":"articles/exploring-msvc-coroutine-kor/#code","text":"\uc608\uc81c \ucf54\ub4dc\uc640 \uad00\ub828\ud574 kirkshoop\uc758 \uc800\uc7a5\uc18c \uac00 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uc2b5\ub2c8\ub2e4. \ubbf8\ub9ac \uc694\uc57d\ud558\uc790\uba74, MSVC\uc758 \uc694\uad6c\uc0ac\ud56d\uc744 \ub530\ub974\uae30\ub9cc \ud55c\ub2e4\uba74 C++\uc5d0\uc11c\ub3c4 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. \uc81c\uc548\uc11c\uc758 \uc774\ub984\uc774 \uc7ac\uac1c (\ub530\ub77c\uc11c, \uc601\uc18d\uc131 \uc788\ub294) \ud568\uc218 \ub77c\ub294 \uc810\uc5d0 \uc8fc\ubaa9\ud558\ub77c. \uc7ac\uac1c\ud568\uc218\uc5d0\ub294 \uba87\uac00\uc9c0 \uc885\ub958\uac00 \uc788\ub294\ub370, \ud568\uc218\uc5d0 \uc5b4\ub5a4 \uc5ed\ud560\uc744 \ub9e1\uae30\uace0\uc790 \ud558\ub290\ub0d0\uc5d0 \ub530\ub77c \ub2ec\ub77c\uc9c4\ub2e4. \uadf8\ub7ec\uba74 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc694\uad6c\uc0ac\ud56d\uc774\ub780 \ubb34\uc5c7\uc77c\uae4c?","title":"Code"},{"location":"articles/exploring-msvc-coroutine-kor/#promise","text":"C++11\uc5d0 \ucd94\uac00\ub41c std::future<T> \uc640 std::promise<T> , \uadf8\ub9ac\uace0 \uc774 \ub450 \uc9dd\uad81\uc758 \uad00\uacc4\uc5d0 \ub300\ud574\uc11c \uc54c \uac83\uc774\ub77c \uc804\uc81c\ud558\uaca0\ub2e4. \uc77c\ubc18\uc801\uc73c\ub85c, future<T> \ub294 \" \ub098\uc911\uc5d0 \uac12\uc774\ub098 \uc608\uc678\ub97c \uc904\uac8c\"\ub77c\ub294 \uac83\uc744 \uc758\ubbf8\ud55c\ub2e4. ( std::async \ub97c \ucc38\uace0\ud558\ub77c) \uadf8\ub9ac\uace0 \uac12/\uc608\uc678\ub294 promise<T> \ub97c \ud1b5\ud574\uc11c \uc804\ub2ec\ub41c\ub2e4. \uc774\ub294 \"\uacb0\uacfc\ub97c \uc900\ub2e4\ub294 \uc57d\uc18d \uc744 \uc9c0\ucf30\ub2e4.\"\ub77c\ub294 \uac83\uc774\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\uac00 future<T> \ub97c \ubc18\ud658\ud55c\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \ub9d0 \uadf8\ub300\ub85c\ub2e4. \ucf54\ub8e8\ud2f4\uc740 \uc2a4\uc2a4\ub85c \uc911\ub2e8\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0 \ud65c\uc131\ud654\ud55c \ub8e8\ud2f4 \uc785\uc7a5\uc5d0\uc11c\ub294 \ucf54\ub8e8\ud2f4\uc774 \uc885\ub8cc\ud588\ub294\uc9c0 \uc54c \ubc29\ubc95\uc774 \uc5c6\ub2e4. \ubc18\ud658\uac12\uc774 \uc788\ub2e4\ub294 \uac83\uc744 \uc54c \uc218 \uc5c6\ub294 \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc \ud568\uc218\uc758 \uc2dc\uadf8\ub2c8\ucc98(Signature)\uc0c1\uc73c\ub85c\ub294, \ub098\uc911\uc5d0 \ub77c\ub294 \uc758\ubbf8\uac00 \ub2f4\uae34 \ud0c0\uc785 future \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud568\uc73c\ub85c\uc368 \uc77c\ubc18\uc801\uc778 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uace0 \uc788\ub2e4. \ub2e4\ub9cc \uae30\uc874\uacfc \ub2ec\ub9ac \uc5ec\uae30\uc11c\uc758 promise \ub294 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c\uac83\uc774\ub2e4. N4402 \ub294 \uc774 \ub0b4\uc6a9\uc5d0 \ub300\ud574 \uae30\uc220\ud558\uace0 \uc788\ub2e4. \uc5b4\uc9f8\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uac8c \uc57d\uc18d\uc774 \ud544\uc694\ud55c \uac83\uc77c\uae4c? \uc774\ub294 \uc7ac\uac1c\ud568\uc218\uac00 \ucd94\uc0c1\ud654 \ud55c \uacb0\uacfc\ubb3c\uc774\uae30 \ub54c\ubb38\uc774\ub2e4. \uc2a4\ud0dd \uae30\ubc18\uc758 \ud658\uacbd\ub54c\ubb38\uc5d0, \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud558\uae30\ub294 \ud588\uc9c0\ub9cc \uc5b4\uc148\ube14\ub9ac\uc640 \uac19\uc774 1\ucc28\uc6d0\uc73c\ub85c \ubc30\uce58\ub41c(flat) \uad6c\ubb38\uad6c\uc870\ub294 \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 \uacb0\uad6d \ud799\uc5d0\uc11c \uc0b4\uc544\uc788\uc73c\uba70, \ud799 \uc601\uc5ed(\ud568\uc218 \ud504\ub808\uc784)\uc5d0\uc11c \uc2a4\ud0dd \uc601\uc5ed( future \ub610\ub294 awaitable)\uc73c\ub85c \uac12\uc744 \uc804\ub2ec\ud574\uc57c \ud558\uace0, \uc774 \uacfc\uc815\uc740 \uc77c\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4 \ub97c \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9c0\ub3c4\ub85d \ud55c \uac83\uc774\ub2e4. \ubb3c\ub860 \uc778\ud130\ud398\uc774\uc2a4\ub294 \ucef4\ud30c\uc77c\ub7ec\uc640 \ud504\ub85c\uadf8\ub798\uba38 \uc591\ucabd \ubaa8\ub450\ub97c \uc704\ud55c \uac83\uc774\ub2e4.","title":"Promise : \ucef4\ud30c\uc77c\ub7ec\uac00 \uc6d0\ud558\ub294 \uac83"},{"location":"articles/exploring-msvc-coroutine-kor/#resumable-promise-requirement","text":"\uc7ac\uac1c\ud568\uc218\uc758 Promise \uc694\uad6c\uc0ac\ud56d \uadf8 \uc778\ud130\ud398\uc774\uc2a4\uac00 \uc5b4\ub5bb\uac8c \uc4f0\uc774\ub294\uc9c0\ub294 \uc7a0\uc2dc \ud6c4 \uae30\uc220\ud558\uace0, \uadf8\uc5d0 \uc55e\uc11c N4402 \ubb38\uc11c\ub97c \uc0b4\ud3b4\ubcf4\uc790. \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc0ac\uc6a9\ub420 \uc218 \uc788\ub294 Promise \ud0c0\uc785\uc740 \uc544\ub798 \ud45c\uc5d0 \uc5f4\uac70\ub41c \uba64\ubc84\ud568\uc218\ub4e4\uc744 \uc9c0\uc6d0\ud574\uc57c \ud55c\ub2e4. \uc81c\uc548\uc11c\ub97c \uc694\uc57d\ud55c \uac83\uc774\ubbc0\ub85c, \ubcf4\ub2e4 \uc790\uc138\ud55c \uc124\uba85\uc740 \uc81c\uc548\uc11c\ub97c \ucc38\uace0\ud558\uae30 \ubc14\ub780\ub2e4. Expression Note P{} \uc774 \ud0c0\uc785\uc740 default constructible \ud574\uc57c\ud55c\ub2e4. p.get_return_object() \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc744 \uacb0\uc815\ud55c\ub2e4. future<T> \ud639\uc740 \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud558\ub294 \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc774 \uc0ac\uc6a9\ub420 \uc218 \uc788\ub2e4. p.return_value(v) co_return \uad6c\ubb38. \uacb0\uacfc\uac12\uc73c\ub85c v \ub97c \uc804\ub2ec\ud558\uba70, \uadf8 \uac12\uc740 \ub098\uc911\uc5d0 \uc0ac\uc6a9(consume)\ub41c\ub2e4. p.return_value() co_return \uad6c\ubb38. void \ud0c0\uc785\uc5d0 \uc0ac\uc6a9\ub418\uba70, \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\uc744 \uc758\ubbf8\ud558\uae30\ub3c4 \ud55c\ub2e4. \uc7ac\uac1c\ud568\uc218\uac00 \uc885\ub8cc\ub420\ub54c \uc0ac\uc6a9\ub41c\ub2e4. \uc774 \ud568\uc218\uac00 \ud638\ucd9c\ub418\ub294 \uac83\uc740 \"\ub354\uc774\uc0c1 \uacb0\uacfc\uac12\uc774 \uc5c6\uc74c\"\uc744 \uc758\ubbf8\ud55c\ub2e4. p.set_exception(e) \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. Resumer \uce21\uc5d0\uc11c \uacb0\uacfc\uac12\uc744 \uc0ac\uc6a9\ud558\ub824\uace0 \ud560\ub54c throw \ub41c\ub2e4. p.yield_value(v) co_yield \ud45c\ud604\uc2dd. return_value(v) \uc640 \uc720\uc0ac\ud558\ub2e4. p.initial_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810(initial suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. p.final_suspend() true \ub97c \ubc18\ud658\ud560 \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810(final suspend point)\uc5d0\uc11c \uc911\ub2e8\ud55c\ub2e4. \uc5ec\uae30\uc11c \uc77c\ubd80 \ud568\uc218\ub4e4\uc740 coroutine_traits<T> \uc640 \uc5f0\uad00\ub418\uc5b4\uc788\ub294\ub370, \uc774\ud6c4\uc5d0 \uc774 \ud0c0\uc785\uc758 \uc720\ub3d9\uc131\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\uaca0\ub2e4. \uc774\uc81c C++ \ucf54\ub8e8\ud2f4\uc758 \uc0ac\uc6a9\ubc29\ubc95\uc73c\ub85c \ucd08\uc810\uc744 \uc62e\uaca8\ubcf4\uc790.","title":"Resumable Promise Requirement"},{"location":"articles/exploring-msvc-coroutine-kor/#generator","text":"","title":"Generator"},{"location":"articles/exploring-msvc-coroutine-kor/#_15","text":"Generator = Iterator + Resumable Function \ubc18\ubcf5\uc790\uac00 \ubcf4\uc774\ub294\uac00? generator<T> \ub294 \uac12\uc758 \uc218\uc5f4(sequence)\uc744 \ucd94\uc0c1\ud654 \ud55c \uac83\uc774\ub2e4. \uc774\ub54c \uac12\uc740 \uc7ac\uac1c\ud568\uc218\uc5d0 \uc758\ud574\uc11c \uc0dd\uc131\ub418\ub294\ub370, \uc7ac\uac1c\ud568\uc218\ub294 \uc0c8\ub85c \ud638\ucd9c\ub418\uba74 \ud568\uc218 \ud504\ub808\uc784\uc774 \ud799 \uc601\uc5ed\uc5d0 \uc720\uc9c0\ub418\ubbc0\ub85c, generator \ub9c8\ub2e4 \uace0\uc720\ud55c \ubb38\ub9e5\uc744 \uac00\uc9c0\uac8c \ub41c\ub2e4.","title":"\uac1c\ub150"},{"location":"articles/exploring-msvc-coroutine-kor/#example","text":"\ub2e4\uc74c \ucf54\ub4dc\ub294 N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator \ub97c \uc791\uc131\ud55c \uac83\uc774\ub2e4. #include <experimental/generator> // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc9c0\uc815(Set)\ud558\uace0 \uc911\ub2e8(Suspend)\ud55c\ub2e4. co_yield f1 ; // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uad6c\ud55c \ub4a4 Shift \ud55c\ub2e4. int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // \ub354\uc774\uc0c1 \uac12\uc744 \uc0dd\uc131\ud558\uc9c0 \uc54a\ub294\ub2e4. } void usecase () { // 10\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \ubc1b\ub294\ub2e4. for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc5b4\ub5bb\uac8c \uc774\uac8c \uac00\ub2a5\ud55c\uac78\uae4c? generator<T> \uc758 \uc815\uc758\ub97c \uc0b4\ud3b4\ubcf4\uc790.","title":"Example"},{"location":"articles/exploring-msvc-coroutine-kor/#detail","text":"\uac04\ub7b5\ud558\uac8c generator<T> \ub97c \uc62e\uaca8\uc654\ub2e4. iterator \uc640 promise_type \uc744 \uc9c0\uc6d0\ud558\ub294 \uac83\uc744 \ud655\uc778\ud560 \uc218 \uc788\ub2e4. \ub610\ud55c begin() / end() \ud568\uc218\ub85c Range-based for loop \ub97c \uc9c0\uc6d0\ud558\uace0 \uc788\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud578\ub4e4 coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc788\ub2e4\uba74 \uc7ac\uac1c\ud574\uc11c \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc788\ub2e4. if ( _Coro ) { _Coro . resume (); // \ud568\uc218\uac00 \ubc18\ud658\ub418\uc5c8\ub098? if ( _Coro . done ()) return { nullptr }; // return end(); } // \uc544\uc9c1 \ub05d\ub098\uc9c0 \uc54a\uc558\ub2e4. // \ub2e4\uc74c\uc5d0 \ub2e4\uc2dc resume\ud558\uc790... return { _Coro }; } iterator end () { // \ud568\uc218 \ud504\ub808\uc784\uc774 \uc5c6\ub2e4\uba74, \uac12\uc744 \ub354 \uac00\uc838\uc62c \uc218 \uc5c6\ub2e4. return { nullptr }; } ~ generator () { // RAII : \ud568\uc218 \ud504\ub808\uc784\uc744 \ud30c\uad34\ud55c\ub2e4. if ( _Coro ) { _Coro . destroy (); } } }; \uc774\ub97c \ubc14\ud0d5\uc73c\ub85c \uc2e4\uc81c\ub85c\ub294 \uc774\ub7f0 \ucf54\ub4dc\uac00 \ub9cc\ub4e4\uc5b4\uc9c8 \uac83\uc774\ub2e4. void usecase () { // N\uac1c\uc758 \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uc0dd\uc131\ud558\ub294 generator\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int > gen = fibonacci ( 10 ); // `iter++`\ub294 delete\ub418\uc5c8\uc73c\ubbc0\ub85c \uc0ac\uc6a9\uc774 \ubd88\uac00\ub2a5\ud558\ub2e4. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } \uc77c\ubc18\uc801\uc778 iterator-for \uad6c\ubb38\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. iterator \ub294 \uc5b4\ub5bb\uac8c \ub418\uc5b4\uc788\uc744\uae4c? template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // \ubc18\ubcf5\uc790 \uc778\ud130\ud398\uc774\uc2a4 struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // \ub2e4\uc74c\uc73c\ub85c \uc774\ub3d9\ud560\ub54c... iterator & operator ++ () { // \ud568\uc218\ub97c \uc7ac\uac1c\ud574\uc11c \uac12\uc744 yield\ud558\ub3c4\ub85d \ud55c\ub2e4. _Coro . resume (); // \ub9cc\uc57d \ud568\uc218\uac00 return\ud588\ub2e4\uba74, \uadf8 \ud578\ub4e4\uc740 generator\uac00 \uc18c\uba78\uc2dc\ud0ac \uac83\uc774\ub2e4. if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // MSVC\uc758 \ucf54\uba58\ud2b8\ub294, \uc694\uc57d\ud558\uc790\uba74, // \ud6c4\uc704\uc99d\uac00\uc2dd\uc740 iterator\ub97c \ub36e\uc5b4\uc4f8 \uc218 \uc788\uace0, // \uc774\ub85c\uc778\ud574 handle\uc774 nullptr\ub85c \ubc14\ub00c\uba74\uc11c // \ud568\uc218 \ud504\ub808\uc784 \ub0b4\uc5d0 \ub9c8\uc9c0\ub9c9 \uac12\uc744 \ubc1b\uc544\uc62c \uc218 \uc5c6\ub2e4\ub294 \uac83\uc774\ub2e4. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // `promise`\uc5d0 \ud3ec\uc778\ud130\uac00 \uc788\ub2e4. \ud3ec\uc778\ud130\ub97c \ucc38\uc870\ud574 \ud504\ub808\uc784 \uc548\uc758 \uac12\uc744 \uac00\uc838\uc628\ub2e4. _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; \uc774 \ucf54\ub4dc\ub97c \ubcf4\uba74 \ubc18\ubcf5\uc790\uac00 \ud568\uc218\ub97c \ubc18\ubcf5\uc801\uc73c\ub85c \uc7ac\uac1c\ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\ub2e4. \uadf8\ub9ac\uace0 generator<T> \uc758 promise_type \uc744 \ud1b5\ud574\uc11c \uac12\uc744 \ud68d\ub4dd\ud55c\ub2e4. \uc774 \uacbd\uc6b0\ub294 usecase \ud568\uc218\uac00 generator \uc758 \ud638\ucd9c\uc790\uba74\uc11c \uc7ac\uac1c\uc790\uc778 \uac83\uc774\ub2e4.","title":"\uc2e4\uccb4(Detail)"},{"location":"articles/exploring-msvc-coroutine-kor/#_16","text":"\uc774\uc81c \ud575\uc2ec\uc774 \ub418\ub294 promise_type \uc744 \ubcfc \ucc28\ub840\ub2e4. \uae30\uc220\ub41c \uac83 \ubcf4\ub2e4 \ucf54\ub4dc\uac00 \uc880 \ub354 \uc788\uc9c0\ub9cc \ub2e8\uc21c\ud654 \ud558\uc600\ub2e4. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } \uc774 promise_type \uc740 \uc694\uad6c\uc0ac\ud56d \uc911\uc5d0\uc11c 4\uac1c\uc758 \uba64\ubc84\ud568\uc218\ub97c \ub9cc\uc871\ud55c\ub2e4. get_return_object , initial_suspend , final_suspend , \uadf8\ub9ac\uace0 yield_value \uac00 \uc815\uc758\ub418\uc5b4 \uc788\ub2e4. co_yield \ub294 \"\uac12\uc744 \uc9c0\uc815\ud558\uace0 \uc911\ub2e8\ud558\ub77c\"\uc640 \uac19\uc740 \uc758\ubbf8\uc778\ub370, \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774\ub97c \uc774\ub807\uac8c \ubcc0\uacbd\ud55c\ub2e4. co_yield : co_await + p.yield_value(x) \ub530\ub77c\uc11c, co_yield \uc5d0 \uc778\uc790 \ud45c\ud604\uc2dd\uc774 \uc5c6\ub2e4\ub294 \uac83\uc740 \ubd88\uac00\ub2a5 \ud558\ub2e4. x \ub294 void \uac00 \ub420 \uc218 \uc5c6\uae30 \ub54c\ubb38\uc774\ub2e4. \uac19\uc740 \uc774\uc720\ub85c generator<void> \ub294 \ucef4\ud30c\uc77c \uc5d0\ub7ec\uac00 \ub418\uba70, \uc5f0\uc18d\ub41c \uac12\uc758 \ucd94\uc0c1\ud654\ub77c\ub294 \uc815\uc758\uc5d0\ub3c4 \uc704\ubc30\ub41c\ub2e4. \uc5c4\ubc00\ud788 \ub9d0\ud574 \uc5ec\uae30\uc11c co_await \ub294 suspend \ub97c \uc758\ubbf8\ud55c\ub2e4. \uc790\uc138\ud55c \uc124\uba85\uc740 \ud6c4\uc220\ud55c\ub2e4. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud45c\ud604\uc2dd\uc744 \uc544\ub798\uc640 \uac19\uc774 \ubc14\uafbc\ub2e4. // co_yield f1; p . yield_value ( f1 ); // \uac12\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc9c0\uc815\ud558\uace0 co_await suspend_always {}; // \uc911\ub2e8\ud55c\ub2e4. // ... } co_return ; // \ub354\uc774\uc0c1 \uac12\uc774 \uc5c6\ub2e4. } \uc774 \ucf54\ub4dc\uc5d0\ub294 promise_type p{} \uac19\uc740 \ubcc0\uc218 \uc120\uc5b8\uc774\ub098, \ub2e4\ub978 \ud568\uc218\ub4e4\uc758 \ud638\ucd9c\uc774 \uc5c6\ub2e4. \uadf8 \uc774\uc720\ub294 \ub2e4\uc74c \ub2e8\uc6d0\uc5d0\uc11c \ub2e4\ub8e8\uaca0\ub2e4.","title":"\ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810"},{"location":"articles/exploring-msvc-coroutine-kor/#resumable-function","text":"\uc7ac\uac1c \ud568\uc218 \uc774\ubc88\uc5d4 \uc880 \ub354 \uc0c1\ud5a5\uc2dd\uc73c\ub85c \uc54c\uc544\ubcf4\uc790. \uc608\uc81c\ucf54\ub4dc\ub294 Awaitable Concept\ub97c \uc774\ud574\ud55c \ub4a4\uc5d0 \ubd10\uc57c \ud55c\ub2e4.","title":"Resumable Function"},{"location":"articles/exploring-msvc-coroutine-kor/#_17","text":"Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> \ub294 \ub2e8\uc21c\ud55c \uc608\uc81c\uc600\ub2e4. generator \ub294 coroutine_handle \uc744 \uba64\ubc84\ubcc0\uc218\ub85c \uac00\uc9c0\uace0 \uc788\uc5c8\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ubb34\uc5c7\uc778\uc9c0 \uc0b4\ud3b4\ubd10\uc57c \ud55c\ub2e4. \uc0ac\uc2e4, coroutine_handle \uc758 \uc608\uc804 \uc774\ub984\uc740 resumable_handle \uc600\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 C++\uc0c1\uc5d0\uc11c \ucf54\ub8e8\ud2f4 \uac1c\ub150\uc744 \uad6c\ud604\ud55c \uac83\uc774\ub77c\uace0 \uc124\uba85\ud588\ub294\ub370, coroutine_handle \ub294 \ub2ec\ub9ac \ub9d0\ud558\uba74 \uc7ac\uac1c\ud568\uc218\uc5d0 \ub300\ud55c \ud578\ub4e4(Resumable Function Handle)\uc774\ub2e4. Windows API\ub97c \uc0ac\uc6a9\ud574\ubcf8 \uacbd\ud5d8\uc774 \uc788\ub2e4\uba74 Handle \uc774 \uacb0\uad6d void* \ub77c\ub294 \uac83\uc744 \uc54c \uac83\uc774\ub2e4. \uc5ec\uae30\uc11c\ub3c4 \ub3d9\uc77c\ud558\ub2e4. \uc55e\uc11c \uc124\uba85\ud588\ub358 \uac83 \ucc98\ub7fc MSVC\ub294 \ud799 \uc601\uc5ed\uc5d0 \ud504\ub808\uc784\uc744 \ub3d9\uc801\ud560\ub2f9\ud558\uace0, \uac70\uae30\uc5d0 \uc57d\uac04\uc758 intrinsic\uc744 \ub354\ud558\ub294 \ud615\ud0dc\ub85c \uc2a4\ud0dd \uc678(stack-less) \ucf54\ub8e8\ud2f4\uc744 \uad6c\ud604\ud558\uace0 \uc788\ub2e4. coroutine_handle \uc740 \uc774\ub4e4\uc744 \ud558\ub098\uc758 \ud0c0\uc785\uc73c\ub85c \ubb36\uc5b4\ub193\uc740 \uac83\uc774\ub2e4.","title":"\uac1c\ub150"},{"location":"articles/exploring-msvc-coroutine-kor/#_18","text":"\uadf8\ub7ec\uba74, Resumable Frame \uc740 \ub300\uccb4 \uc5b4\ub5bb\uac8c \uc0dd\uacbc\uc744\uae4c? \uc77c\ub2e8 \ud504\ub808\uc784\uc740 Head\uc640 Body\ub85c \ub098\ub25c\ub2e4. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Head // - Fn : \uc7ac\uac1c\ud560 \ub54c \uc218\ud589\ud560 \uba85\ub839\uc5b4\uc758 \uc8fc\uc18c // - cdecl : \uc774 Convention\uc5d0\uc11c \ud568\uc218 \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 Caller \uac00 \ub2f4\ub2f9\ud55c\ub2e4. // - Index : Resumption point\uc758 \uc778\ub371\uc2a4 // 0\ubc88\uc740 \ud568\uc218\uac00 \uc885\ub8cc\ub41c(`done()`) \uacbd\uc6b0\uc5d0 \uc0ac\uc6a9\ud55c\ub2e4. // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // \ud568\uc218 \ud504\ub808\uc784 Body \uc5d0\ub294... // - Promise \ud0c0\uc785 \uac1c\uccb4 // - \ud504\ub808\uc784\uc73c\ub85c \uc774\ub3d9\uc2dc\ud0a8 Arguments // - \ud568\uc218 Body // - \uc9c0\uc5ed/\uc784\uc2dc \ubcc0\uc218\ub4e4 // - Platform \uc804\uc6a9 // - \ub808\uc9c0\uc2a4\ud130 \ub4f1\ub4f1 // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : \uc774\ub984\ucc98\ub7fc _Resumable_frame_prefix \uac00 \ud568\uc218\ud504\ub808\uc784\uc758 \uc55e\ubd80\ubd84\uc774 \ub41c\ub2e4. MSVC \ub294 \uc774 \uacf5\uac04\uc5d0 sizeof(void *) * 2 (x64 \uc5d0\uc11c 16 \ubc14\uc774\ud2b8)\ub9cc\ud07c\uc758 \uace0\uc815\ub41c \ud06c\uae30\ub97c \uc0ac\uc6a9\ud55c\ub2e4. Fn : cdecl \ud638\ucd9c \uaddc\uc57d\uc73c\ub85c \uc120\uc5b8\ub418\uc5b4\uc788\ub2e4\ub294 \uc810\uc774 \ud2b9\uc774\ud55c\ub370, cdecl \uc5d0\uc11c \ud504\ub808\uc784\uc758 \uc815\ub9ac\ub294 \ud638\ucd9c\uc790\uc758 \uc5ed\ud560\uc774\uba70, \ub530\ub77c\uc11c Fn \uc744 \ud638\ucd9c\ud558\ub294 \uac83\uc740 \uadf8 \uc2dc\uc810\uc758 \uc2a4\ud0dd\uacfc \ud568\uc218 \ud504\ub808\uc784\uc5d0 \uc601\ud5a5\uc744 \ubbf8\uce58\uc9c0 \uc54a\ub294\ub2e4. Index : \uc7ac\uac1c\ud568\uc218\ub294 \ub2e4\uc218\uc758 \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\ub4e4\uc744 \uac00\uc9c0\uace0 \uc788\uace0, Index \ub294 \uac01 \uc9c0\uc810\ub4e4\ub85c switch \ud558\ub294\ub370 \uc0ac\uc6a9\ub41c\ub2e4. Flag : ??? \uc774\uac74 \ub300\uccb4 \ubb58\uae4c ??? Body : N4402\uc5d0 \ud568\uc218 \ud504\ub808\uc784\uc758 \uad6c\uc131\uc5d0 \ub300\ud574 \uae30\uc220\ub418\uc5b4\uc788\ub2e4. James McNellis\uc758 \ubc1c\ud45c\uc790\ub8cc\uc5d0 \uc758\ud558\uba74, \ucef4\ud30c\uc77c\ub7ec\uac00 \uc0dd\uc131\ud558\ub294 \ud504\ub808\uc784\uc740 \ub2e4\uc74c\uc744 \ud3ec\ud568\ud55c\ub2e4. \uc77c\ubc18\uc801\uc778 \uc2a4\ud0dd \ud504\ub808\uc784\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\ub2e4. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // `fibonacci` \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784(\uc608\uc2dc) struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci\ub294 `generator<int>`\ub97c \ubc18\ud658\ud55c\ub2e4. generator < int >:: promise_type _p ; // \ud504\ub808\uc784\uc5d0 \uc778\uc790\ub97c \uc800\uc7a5\ud55c\ub2e4. int _n ; // fibonacci(n); int _f1 , _f2 ; // \uc9c0\uc5ed \ubcc0\uc218 int _i , _f3 ; // \uc784\uc2dc \ubcc0\uc218 // Platform \uc804\uc6a9 \uc800\uc7a5\uc18c // \ub808\uc9c0\uc2a4\ud130\ub098 \uc774\uac83\uc800\uac83... };","title":"\uc7ac\uac1c\ud568\uc218\uc758 \ud504\ub808\uc784"},{"location":"articles/exploring-msvc-coroutine-kor/#coroutine-traits","text":"p.get_return_object() \uc5d0 \ub300\ud574\uc11c \ub2e4\ub8e8\uc9c0 \uc54a\uc558\uc5c8\ub294\ub370, \uc5ec\uae30\uc11c \uac19\uc774 \ub2e4\ub8e8\uace0\uc790 \ud55c\ub2e4. \uba3c\uc800 coroutine_traits \ub97c \ub208\uc5ec\uaca8\ubd10\uc57c \ud55c\ub2e4. // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; \uad49\uc7a5\ud788 \ub2e8\uc21c\ud55c\ub370, coroutine_traits \uc774 \uc694\uad6c\ud558\ub294 \uac83\uc740 \uacb0\uad6d promise_type \ub97c \uad6c\ud604\ud558\ub77c\ub294 \uac83\uc774\ub2e4. \uc774\uc5d0 \ub300\ud55c \uac80\uc0ac\ub294 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uc774\ub8e8\uc5b4\uc9c0\uace0, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement \ub97c \ub9cc\uc871\uc2dc\ucf1c\uc57c \ud55c\ub2e4. \uc55e\uc11c \uc7ac\uac1c\ud568\uc218\ub294 future<T> \ub97c \ubc18\ud658\ud560 \uc218 \uc788\ub2e4\uace0 \uc124\uba85\ud588\ub294\ub370, \uc0ac\uc2e4 \uadf8\uac83\uc740 \ubd80\uc815\ud655\ud55c \uc124\uba85\uc774\uc5c8\ub2e4. coroutine_traits \ub97c \ub9cc\uc871\uc2dc\ud0a4\uae30\ub9cc \ud55c\ub2e4\uba74, \uadf8 \ud0c0\uc785\uc740 \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc774 \ub420 \uc218 \uc788\ub2e4. std::future<T> \ub97c \uc704\ud55c coroutine_traits \uc758 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 \ubc84\uc804\uc744 \uc62e\uaca8\uc654\ub2e4. generator<T> \uc758 \uacbd\uc6b0\ub294 \ub0b4\ubd80\uc5d0 promise_type \uc744 \uad6c\ud604\ud558\uace0 \uc788\uc5c8\ub294\ub370, \uc608\uc804\ubd80\ud130 \uc0ac\uc6a9\ud558\ub358 \ud0c0\uc785\ub4e4\uc774\ub098 \ucee4\uc2a4\ud140 \ud0c0\uc785\ub4e4\uc740 \uc774\ub7f0 \ud2b8\ub9ad\uc744 \uc0ac\uc6a9\ud574\uc11c \uc7ac\uac1c\ud568\uc218\uc5d0\uc11c \uc720\uc5f0\ud558\uac8c \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. // <future> \ud5e4\ub354 #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // `std::future<T>`\ub97c \uc704\ud55c \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654 template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // `future<_Ty>`\ub97c \ubc18\ud658\ud558\ub294 \uc7ac\uac1c\ud568\uc218\ub4e4\uc744 \uc704\ud55c \ud0c0\uc785\uc815\uc758 struct promise_type { // `std::promise<T>`\ub97c \uadf8\ub300\ub85c \uc0ac\uc6a9\ud55c\ub2e4. promise < _Ty > _MyPromise ; // \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658 \ud0c0\uc785\uc740 `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // `false`\uc77c \uacbd\uc6b0, \ucd08\uae30 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool initial_suspend () const { return ( false ); } // `false`\uc77c \uacbd\uc6b0, \ucd5c\uc885 \uc911\ub2e8\uc810\uc5d0\uc11c \uba48\ucd98\ub2e4. bool final_suspend () const { return ( false ); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // `std::promise<T>`\ub97c \ud1b5\ud574 \uc608\uc678\ub97c \uc804\ub2ec\ud55c\ub2e4. void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif MSVC\ub294 co_await / co_yield / co_return \ud0a4\uc6cc\ub4dc \uc911 \ud558\ub098\ub97c \ud655\uc778\ud558\uba74, coroutine_traits \ub97c \uc0ac\uc6a9\ud574 \ucef4\ud30c\uc77c \uc2dc\uac04\uc5d0 \uac80\uc0ac\ub97c \uc218\ud589\ud560 \uc218 \uc788\ub3c4\ub85d \ucf54\ub4dc\ub974 \uc0dd\uc131\ud55c\ub2e4. MSVC\uac00 \ud558\ub294 \uc77c\uc744 \ud655\uc778\ud558\uae30 \uc704\ud574 fibonacci \uc608\uc81c\ub85c \ub2e4\uc2dc \uac00\ubcf4\uc790. \uc774 \ucf54\ub4dc\ub294 \ud2c0\ub9b0 \ud615\ud0dc\uc77c \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc815\ud655\ud55c \uba54\ucee4\ub2c8\uc998\uc744 \ud655\uc778\ud558\uac8c \ub418\uba74 \uac31\uc2e0\ud558\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // \ubcc4\uce6d : \ubc18\ud658\ud0c0\uc785 using return_type = generator < int > ; // \ubc18\ud658\ud0c0\uc785\uc774 Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294\uac00? using traits = coroutine_traite < return_type > ; // \uc694\uad6c\uc0ac\ud56d\uc744 \ub9cc\uc871\ud55c\ub2e4\uba74 \uc774 \uc7ac\uac1c\ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4. // fibonacci \ud568\uc218\ub97c \uc704\ud55c \uac00\uc0c1\uc758 \ud504\ub808\uc784. \uc704\uc640 \ub3d9\uc77c\ud558\ub2e4. struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // \ud504\ub808\uc784\uc744 \ub3d9\uc801\uc73c\ub85c \ud560\ub2f9\ud55c\ub2e4. context(ctx)\ub77c\uace0 \ud558\uaca0\ub2e4. // \ud2b9\uc815\ud55c Allocator\ub97c \uc0ac\uc6a9\ud574 \ucee4\uc2a4\ud130\ub9c8\uc774\uc988 \ud560 \uc218\ub3c4 \uc788\uc9c0\ub9cc \uc5ec\uae30\uc120 \ub2e8\uc21c\ud788 new\ub85c \uc124\uba85\ud55c\ub2e4. __frame * ctx = new __frame { std :: move ( n )}; // \ubc18\ud658 \uac1c\uccb4\ub97c \uc0dd\uc131\ud55c\ub2e4. return_type __return = ctx -> _promise . get_return_object (); // true\uc77c \uacbd\uc6b0 \uc911\ub2e8, false\uc77c \uacbd\uc6b0 \uc9c4\ud589\ud55c\ub2e4. if ( ctx -> _promise . initial_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __initial_suspend_point : } // \uc0ac\uc6a9\uc790 \ucf54\ub4dc\ub294 \ud504\ub808\uc784\uc744 \uc0ac\uc6a9\ud558\ub3c4\ub85d \ubcc0\uacbd\ub41c\ub2e4. // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // promise\ub97c \ud1b5\ud574 \uac12\uc744 \uc804\ub2ec\ud55c\ub2e4. // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // `ctx->_prefix`\uc758 Index\ub97c \uc870\uc815\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4. // co_await suspend_always{}; __suspend_resume_point_1 : // \ub2e4\uc74c \ud53c\ubcf4\ub098\uce58 \uc218\ub97c \uacc4\uc0b0\ud558\uace0 Shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // \ud56d\uc0c1 true // \uc911\ub2e8\ud55c\ub2e4... __final_suspend_point : } // \uc815\ub9ac\uc791\uc5c5... } \uc0dd\uac01\ubcf4\ub2e4 \ucef4\ud30c\uc77c\ub7ec\uac00 \ub9ce\uc740 \uc791\uc5c5\uc744, \ud558\uc9c0\ub9cc \uae30\uc874\uc5d0 \uc2a4\ud0dd \ud504\ub808\uc784\uc5d0 \ub300\ud574\uc11c \ud558\ub358\uac83\uacfc \uc720\uc0ac\ud55c \uc791\uc5c5\uc744 \ud558\ub294 \uac83\uc744 \uc54c \uc218 \uc788\uc5c8\ub2e4. ctx \uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ud799\uc601\uc5ed\uc5d0 \uc704\uce58\ud55c \ubcc0\uc218\ub97c \uc0ac\uc6a9\ud558\ub294 \ubc29\ubc95\uc740 this \ud3ec\uc778\ud130\uc758 \uc0ac\uc6a9\uacfc \ub2e4\ub974\uc9c0 \uc54a\uae30 \ub54c\ubb38\uc5d0, \uc774\ub7f0 \ud504\ub808\uc784 \uae30\ubc18 \uad6c\ud604\uc758 \ube44\uc6a9\uc740 \ucd94\uac00\uc801\uc778 co_await \uad00\ub828 \ube44\uc6a9\uc774\uc678\uc5d0\ub294 \ubb34\uc2dc\ud560 \uc218 \uc788\ub294 \uc218\uc900\uc77c \uac83\uc774\ub2e4. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend;","title":"Coroutine Traits"},{"location":"articles/exploring-msvc-coroutine-kor/#_19","text":"co_return \uacfc co_yield \uc5d0 \ub300\ud574\uc11c generator<T> \uc608\uc81c\ub97c \ud1b5\ud574 \uc0b4\ud3b4\ubd24\ub2e4. Generator\ub294 \ubc18\ubcf5\uc790\uc640 \uc7ac\uac1c\ud568\uc218\ub97c \ud569\uce5c \uac83\uc774\uc5c8\ub2e4. \uc7ac\uac1c\ud568\uc218\ub294 coroutine_handle \uc744 \uc0ac\uc6a9\ud558\ub294\ub370, \uc774 \ud0c0\uc785\uc740 \ud568\uc218 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130\uc640 \ucef4\ud30c\uc77c\ub7ec Intrinsic\uc744 \ud569\uccd0\ub193\uc740 \uac83\uc774\ub2e4. \ud504\ub808\uc784 \uae30\ubc18\uc758 \uad6c\ud604\uc740 this \ud3ec\uc778\ud130\ub97c \uc0ac\uc6a9\ud574 \ubcc0\uc218\ub97c \uc870\uc791\ud558\ub294 \uac83\uacfc \uc720\uc0ac\ud558\ub2e4. \ucef4\ud30c\uc77c \uc2dc\uac04(\uc815\uc801) \uac80\uc0ac\ub97c \uc704\ud574 coroutine_traits<T> \uac00 \uc0ac\uc6a9\ub41c\ub2e4. \uc774\ub97c \ud1b5\ud574 promise_type \uc744 \uad6c\ud604\ud558\ub3c4\ub85d \uac15\uc81c\ud558\uba70, \uc774 \ud0c0\uc785\uc740 Resumable Promise Requirement\ub97c \ub9cc\uc871\ud574\uc57c \ud55c\ub2e4. std::future<T> \uc758 \uacbd\uc6b0 \ud15c\ud50c\ub9bf \ud2b9\uc218\ud654\uac00 \uae30\ubcf8\uc801\uc73c\ub85c \uc9c0\uc6d0\ub41c\ub2e4.","title":"\uc7a0\uae50 \uc815\ub9ac"},{"location":"articles/exploring-msvc-coroutine-kor/#_20","text":"operator co_await = Syntactic Sugar + Resumable Function \uc7ac\uac1c\ud568\uc218\uc758 \ub9c8\uc9c0\ub9c9 \ud575\uc2ec\uc740 \ub2e8\ud56d \uc5f0\uc0b0\uc790 co_await \ub77c\uace0 \ud560 \uc218 \uc788\ub2e4. \ubb38\ub9e5\uc0c1\uc73c\ub85c, await\ub294 suspend\uc640 \uac19\uc740\uc758\ubbf8\ub2e4 . \uadf8\ub9ac\uace0 \uc774 \uc911\ub2e8 \ub54c\ubb38\uc5d0, \uc7ac\uac1c\ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \uc790\uc5f0\uc2a4\ub7fd\uac8c \ube44\ub3d9\uae30 \uac00 \ub41c\ub2e4. \uba58\ud0c8 \ubaa8\ub378 \uc0c1\uc5d0\uc11c \uc774\ub7f0 \ud2b9\uc131\uc740 \uaf64 \uc911\uc694\ud55c \uc810\uc778\ub370, C# \uc5b8\uc5b4\uc758 async & await \uae30\ub2a5\uacfc \uc720\uc0ac\ud558\ub2e4\uace0 \ubcfc \uc218 \uc788\ub2e4. C++ \uc138\uc0c1\uc5d0\uc11c \ub2e4\ub978\uc810\uc740, \ud504\ub85c\uadf8\ub798\uba38\uc758 \ucf54\ub4dc\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc9c0\uc6d0\uc744 \uc0ac\uc6a9\ud574\uc11c \uc218\ub3d9\uc73c\ub85c \uad00\ub9ac\ud560 \uc218 \uc788\ub2e4\ub294 \uc810\uc774\ub2e4.","title":"\"\uae30\ub2e4\ub9b4 \uc218 \uc788\ub2e4\"\ub294 \uac1c\ub150\uc5d0 \ub300\ud574\uc11c"},{"location":"articles/exploring-msvc-coroutine-kor/#example_1","text":"MSVC \ube14\ub85c\uadf8\uc758 \uc608\uc81c\ub97c \uac00\uc838\uc654\ub2e4. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // \uc5f0\uc0b0\uc790 \uc624\ubc84\ub85c\ub4dc // co_await \ub294 \uae30\ubcf8 \ud0c0\uc785(primitive type) \uc778\uc790\ub294 \ubc1b\uc9c0 \uc54a\ub294\ub2e4. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // \uae30\ub2e4\ub9ac\uae30 \uc704\ud574\uc120 \ud568\uc218 3\uac1c\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback\uc744 \uc218\ud589\ud558\ub294 Thread\uc5d0\uc11c Resume\ud55c\ub2e4. coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // \uc900\ube44\uac00 \uc548\ub418\uc5c8\uc73c\uba74 (`false`), `await_suspend`\ub97c \ud638\ucd9c\ud55c\ub2e4. // \uac12\uc774 \uc900\ube44\ub418\uc5c8\uc73c\uba74 (`true`), `await_resume`\ub97c \ubc14\ub85c \ud638\ucd9c\ud55c\ub2e4. bool await_ready () const { return duration . count () <= 0 ; } // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc740 \ubb34\uc2dc\ub420 \uc218 \uc788\ub2e4. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // \ud0c0\uc774\uba38\ub97c \uc138\ud305\ud558\uace0 \uc911\ub2e8\ud55c\ub2e4.... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // \uc7ac\uac1c\ub41c \ud6c4\uc5d0\ub294 T \ud0c0\uc785 \uac12\uc744 \ubc18\ud658\ud55c\ub2e4. // `void`\ub3c4 \uac00\ub2a5\ud558\ub2e4. void await_resume () {} }; return awaiter { duration }; } // \ucf54\ub8e8\ud2f4(\uc7ac\uac1c\ud568\uc218) future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // 1 \ubc00\ub9ac\ucd08\ub97c \uae30\ub2e4\ub9b0\ub2e4... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // \ud3c9\ubc94\ud55c \uc11c\ube0c\ub8e8\ud2f4 void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } \uc774 \ucf54\ub4dc\ub294 \ub300\ub7b5 \uc774\ub7f0 \uc2dd\uc73c\ub85c \uc9c4\ud589\ub41c\ub2e4.","title":"Example"},{"location":"articles/exploring-msvc-coroutine-kor/#_21","text":"co_await \ub294 \ub3d9\uc791\ud558\uae30 \uc704\ud574\uc11c \ud2b9\uc815\ud55c \uc778\ud130\ud398\uc774\uc2a4\ub97c \uc694\uad6c\ud55c\ub2e4. \uc704\uc5d0\uc11c \ubcf8 \uac83 \ucc98\ub7fc, Awaitable Interface\ub294 3\uac00\uc9c0 \ud568\uc218\ub97c \uad6c\ud604\ud574\uc57c\ub9cc \ud55c\ub2e4. await_ready await_suspend await_resume \uc774\ub4e4\uc740 \uba64\ubc84\ud568\uc218\uc77c \uc218\ub3c4 \uc788\uace0, \uc77c\ubc18 \ud568\uc218\ub85c\ub3c4 \uac00\ub2a5\ud558\ub2e4. future<T> \uc5ed\uc2dc \uc774 \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uace0 \uc788\ub2e4. \ub2ec\ub9ac\ub9d0\ud574, future<T> \uac00 co_await \uc758 \uc778\uc790\uac00 \ub420\uc218\ub3c4 \uc788\ub2e4\ub294 \uc758\ubbf8\ub2e4. \uc544\ub798 \ucf54\ub4dc\ucc98\ub7fc \ube44\ud6a8\uc728\uc801\uc77c \uc218\ub3c4 \uc788\uaca0\uc9c0\ub9cc, \uc0ac\uc6a9\uc790 \uc815\uc758 \ud0c0\uc785\uc5d0 \ub300\ud574\uc11c \uac04\ub2e8\ud55c \uc624\ubc84\ub85c\ub4dc \ub9cc\uc73c\ub85c\ub3c4 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4\ub294 \uc7a5\uc810\uc774 \uc788\ub2e4. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // future\ub97c await\ud558\uba74 \uc2a4\ub808\ub4dc\ub97c \ub9cc\ub4e4\uc5b4\uc11c detach\uc2dc\ud0a8\ub2e4. // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std \ucef4\ud30c\uc77c\ub7ec \ucabd\uc740 \uc5b4\ub5a8\uae4c? \uc774 \ucf54\ub4dc\uac00 \uc5b4\ub5bb\uac8c \ubc14\ub014\uae4c?","title":"\uae30\ub2e4\ub9ac\uae30 \uc704\ud55c \uc778\ud130\ud398\uc774\uc2a4"},{"location":"articles/exploring-msvc-coroutine-kor/#_22","text":"operator co_await = Syntactic Sugar + Resumable Function co_await \ub294 \ud45c\ud604\uc744 \ubc14\uafbc\ub2e4\ub294 \uc810\uc5d0\uc11c \uacb0\uad6d syntatic sugar\ub77c\uace0 \ud560\uc218 \uc788\ub2e4. \uc778\uc790\ud0c0\uc785\uc774 Awaitable Interface\ub97c \uc54c\ub9de\uac8c \uad6c\ud604\ud558\uae30\ub9cc \ud55c\ub2e4\uba74, \ucef4\ud30c\uc77c\ub7ec\ub294 \ucf54\ub4dc\ub97c \ubc14\uafd4\uc900\ub2e4. \uc880\uc804\uc758 \uc608\uc81c\ucf54\ub4dc\ub97c \uc880\ub354 \uc790\uc138\ud558\uac8c \uc0b4\ud3b4\ubcf4\uaca0\ub2e4. // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // `co_await`\ud0a4\uc6cc\ub4dc\uac00 \uc788\uc73c\ubbc0\ub85c \uc7ac\uac1c\ud568\uc218\uac00 \ub41c\ub2e4. future < void > test () { // \ucef4\ud30c\uc77c\ub7ec\ub294 \uc774 \ud568\uc218\ub97c \uc704\ud55c \ud504\ub808\uc784\uc744 \uc0dd\uc131\ud55c\ub2e4... __frame * context ; // ... // Awaitable interface\ub97c \uad6c\ud604\ud558\uc600\ub2e4. // \uc815\ud655\ud558\uac8c\ub294 \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc774 \ubcc0\uc218\uac00 \uc0dd\uc131\ub420 \uac83\uc774\ub2e4. awaiter aw = operator co_await ( 1 ms ); // \uac12\uc774 \uc900\ube44\ub418\uc5b4 \uc788\ub294\uac00? if ( aw . await_ready () == false ) // await_ready(aw); { // \uac12\uc774 \uc5c6\uc73c\ubbc0\ub85c \uae30\ub2e4\ub824\uc57c \ud55c\ub2e4. // \ud568\uc218 \ud504\ub808\uc784\uc744 `coroutine_handle` \ud0c0\uc785\uc73c\ub85c \uac10\uc2f8\uace0... coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); // suspend \ud568\uc218\ub97c \ud638\ucd9c\ud55c\ub2e4. aw . await_suspend ( resume_cb ); // \uc911\ub2e8 \uc9c1\uc804\uc5d0 \ud504\ub808\uc784\uc5d0 Index\ub97c \ubcc0\uacbd\ud558\uace0...... __suspend_resume_point_1 : // \uc911\ub2e8/\uc7ac\uac1c \uc9c0\uc810\uc774 \uc5ec\uae30\uc5d0 \uc788\uc73c\ubbc0\ub85c ready\uc5d0\uc11c true\ub97c \ubc18\ud658\ud558\uba74 // \ud568\uc218\ub294 \uba48\ucd94\uc9c0 \uc54a\uace0 \uc9c4\ud589\ud55c\ub2e4. } // await_resume\uc774 \ubc18\ud658\ud0c0\uc785\uc774 \uc788\ub2e4\uba74 value\uc5d0 \uac12\uc744 \uc800\uc7a5\ud55c\ub2e4. // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } \uc774\uc81c \uc778\ud130\ud398\uc774\uc2a4\uc758 \uac01 \ud568\uc218\ub4e4\uc5d0 \ub300\ud574\uc11c \uc9da\uc5b4\ubcfc \uc218 \uc788\uaca0\ub2e4. await_ready : \"\uc9c0\uae08 \uac12\uc774 \uc788\ub294\uac00?\" await_ready \uc740 \ubd84\uae30\uc810\uc774 \ub41c\ub2e4. \uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\uba74 await_resume \uc5d0\uc11c \ubc14\ub85c \uadf8 \uac12\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uaca0\uc9c0\ub9cc, \uadf8\ub807\uc9c0 \uc54a\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc73c\ub85c \ubd84\uae30\ud574 \ud568\uc218\ub97c \uc911\ub2e8\ud55c\ub2e4. await_ready \ud568\uc218\uac00 \uc5b8\uc81c\ub098 true \ub97c \ubc18\ud658\ud55c\ub2e4\uba74 if \uad6c\ubb38 \uc548\ucabd\uc740 Dead Code\uac00 \ub418\uace0, \ucef4\ud30c\uc77c\ub7ec\uc758 \ucd5c\uc801\ud654 \uacfc\uc815\uc5d0\uc11c \uc18c\uba78\ub420 \uac83\uc774\ub2e4. \uc774 \uacbd\uc6b0\ub294 \ud504\ub808\uc784\uae4c\uc9c0 \uc18c\uba78\ub418\uace0 \uc77c\ubc18 \uc11c\ube0c\ub8e8\ud2f4\ucc98\ub7fc \ucd5c\uc801\ud654\ub420 \uc218 \ub3c4 \uc788\ub2e4. \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8 \ubc94\uc704\ub85c \uc9c4\uc785\ud558\uba74, \ud568\uc218 \ud504\ub808\uc784\uc744 coroutine_handle<> \ub85c \uac10\uc2f8\uc11c \uc778\uc790\ub85c \ub118\uaca8\uc900\ub2e4. coroutine_handle<>::from_address \ud568\uc218\uac00 \uc774 \uc5ed\ud560\uc744 \ud574\uc900\ub2e4. await_suspend : \"\uace7 \ub8e8\ud2f4\uc774 \uba48\ucda5\ub2c8\ub2e4. \ud574\uc57c\ud560 \uc77c\uc774\ub77c\ub3c4?\" await_suspend \ub294 coroutine_handle<> \uc744 \uc778\uc790\ub85c \ubc1b\uace0, \uc911\ub2e8\ud558\uae30 \uc804\uc5d0 \ud574\uc57c\ud560 \ub0b4\uc6a9\uc744 \ucf54\ub4dc\ub85c \ub07c\uc6cc\ub123\uc744 \uc218 \uc788\uac8c \ub41c\ub2e4. // Windows Thread Pool Timer\ub97c \uc0ac\uc6a9\ud55c\ub2e4. // Timer Callback\uc5d0 \ud504\ub808\uc784\uc758 \uc8fc\uc18c\ub97c \ub118\uaca8\uc8fc\ub294 \ubc29\uc2dd\uc73c\ub85c \ucf54\ub8e8\ud2f4\uc744 \ub9c8\ubb34\ub9ac\ud55c\ub2e4. class awaiter { bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // \ud3ec\uc778\ud130\ub85c \ubcc0\ud658\ud55c\ub2e4. resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Windows Thread Pool\uc5d0 \uc788\ub294 \uc2a4\ub808\ub4dc\uac00 Callback\uc744 \ud638\ucd9c\ud558\uac8c \ub41c\ub2e4. // \uc790\uc5f0\uc2a4\ub7fd\uac8c Resumer Thread\uac00 \ub41c\ub2e4. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // \ud504\ub808\uc784 \ud3ec\uc778\ud130\ub97c \ud578\ub4e4\ub85c \ubcc0\ud658, \uadf8\ub9ac\uace0 \uc7ac\uac1c. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"\uc5ec\uae30 \uacb0\uacfc\uac12\uacfc \uc2e4\ud589 \ud750\ub984\uc774\uc694.\" \ud568\uc218\ub97c \uc7ac\uac1c\ud558\uba74 \uc911\ub2e8\uc9c0\uc810\uc73c\ub85c \uc810\ud504\ud558\uba70, \uc911\ub2e8\uc810\uc774 \uc788\ub294 \uc720\ud6a8\ubc94\uc704\ub97c \ubc97\uc5b4\ub098 await_resume \uc744 \ud638\ucd9c\ud55c\ub2e4. \uc911\ub2e8\ud558\ub358 \uc2dc\uc810\uc5d0\ub294 \uacb0\uacfc\uac12\uc774 \uc5c6\uc5c8\uae30 \ub54c\ubb38\uc5d0, \ud568\uc218\uac00 \uc7ac\uac1c\ub418\uc5c8\ub2e4\ub294 \uac83\uc740 \uacb0\uacfc\uac12\uc774 \uc900\ube44\ub418\uc5c8\ub2e4\ub294 \uc758\ubbf8\uac00 \ub41c\ub2e4. \ub9cc\uc57d void\ub77c\uba74 co_await \uc544\ub798\uc5d0 \uc788\ub294 \ucf54\ub4dc\ub97c \uc2e4\ud589\ud574\uc57c \ud558\ub3c4\ub85d \uc2e4\ud589\ud750\ub984\uc744 \ub118\uaca8\uc900\ub2e4\ub294 \uc758\ubbf8\uc77c \uac83\uc774\ub2e4.","title":"\ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810"},{"location":"articles/exploring-msvc-coroutine-kor/#co_await-tricks","text":"Kenny Kerr \uc640 James Mcnellis \ub294 \uc774\ub7f0 \uba54\ucee4\ub2c8\uc998\uc744 \uc0ac\uc6a9\ud55c \ud2b8\ub9ad\ub4e4\uc5d0 \ub300\ud574\uc11c \uc124\uba85\ud558\ub294\ub370, \uc2dc\uac04\uc801 \uc5ec\uc720\uac00 \uc788\ub2e4\uba74 \uaf2d \ubcf4\uae30\ub97c \uad8c\ud55c\ub2e4. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\"","title":"co_await Tricks"},{"location":"articles/exploring-msvc-coroutine-kor/#async-generator","text":"","title":"Async Generator"},{"location":"articles/exploring-msvc-coroutine-kor/#_23","text":"Async Generator = Awaitable iterator + Resumable function Generator\uc640 \ub9e4\uc6b0 \uc720\uc0ac\ud558\uc9c0\ub9cc, \ub2e4\ub978\uc810\uc740 \ubc18\ubcf5\uc790\uac00 Awaitable\ud558\ub2e4 \ub294 \uac83\uc774\ub2e4. \ub2ec\ub9ac \ub9d0\ud558\uba74, Awaitable iterator \uc5d0 \ub300\ud574\uc11c for co_await \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4. Kirkshoop\uc758 \uc124\uba85 \uc774 \ub3c4\uc6c0\uc774 \ub420 \uac83\uc774\ub2e4.","title":"\uac1c\ub150"},{"location":"articles/exploring-msvc-coroutine-kor/#example_2","text":"\uc774 \uae30\ub2a5\uc744 \uc81c\ub300\ub85c \uc0ac\uc6a9\ud574\ubcf4\uc9c0 \ubabb\ud574 \uc81c\ub300\ub85c \ub41c \uc608\uc81c\ub97c \uc801\uc9c0 \ubabb\ud588\ub2e4. \ud558\uc9c0\ub9cc \uc9c0\uae08\uae4c\uc9c0\uc758 \uc608\uc81c\uc640 \ucef4\ud30c\uc77c\ub7ec\uc758 \uc2dc\uc810\uc5d0 \ub300\ud55c \uc124\uba85\uc744 \uc77d\uc5c8\ub2e4\uba74 \uc774 \ucf54\ub4dc\uac00 \uc774\ud574\ub420 \uac83\uc774\ub77c \uc0dd\uac01\ud55c\ub2e4. // \ubb34\ud55c\ud55c \uc815\uc218 \uc218\uc5f4 async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await \uad6c\ubb38 for co_await ( int v : infinite ()) { // `v`\ub85c \ubb34\uc5b8\uac00 \ud55c\ub2e4... } } iterator \uac00 Awaitable\ud558\ub2e4\uace0 \ud588\ub294\ub370, \uc774\ub294 usecase \uac00 \ub2e4\uc74c\uacfc \uac19\ub2e4\ub294 \uc758\ubbf8\ub2e4. std :: future < void > usecase () { // \uae30\ub2e4\ub9b4 \uc218 \uc788\ub294 \ubc18\ubcf5\uc790 : awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `begin()` \uc5d0 // `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. iter != gen . end (); // `end()` \ub294 nullptr\uc640 \uac19\ub2e4. co_await ++ iter ) // `operator++()`\uc5d0 `co_await`\uac00 \uc801\uc6a9\ub41c\ub2e4. { int v = * iter ; // ... } } generator<T> \uc608\uc81c\uc640 \ub2e4\ub978 \uc810\uc740 \ud568\uc218\uac00 2\uac1c \uc9c0\uc810\uc5d0\uc11c \ubc18\ubcf5\uc790\ub97c \uae30\ub2e4\ub9ac\uace0 \uc788\ub2e4\ub294 \uac83\uc774\ub2e4. \ub530\ub77c\uc11c begin() \uacfc operator++() \ub294 usecase \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8/\uc7ac\uac1c\uc9c0\uc810\uc774 \ub41c\ub2e4. \uc5ec\uae30\uc120 value_type \uc740 \uae30\ubcf8 \uc790\ub8cc\ud615 int \ub77c\uc11c \uc5b4\ub824\uc6b4 \ucf54\ub4dc\ub294 \uc5c6\ub2e4. Awaitable iterator \ucf54\ub4dc\ub294 \ub2e4\uc74c\ucc98\ub7fc \ub9cc\ub4e4 \uc218 \uc788\ub2e4. \uc0ac\uc2e4 std::experimental::generator<T> \uc758 \ucf54\ub4dc\ub97c \uac70\uc758 \uadf8\ub300\ub85c \uac00\uc838\uc628 \uac83\uc774\ub2e4. // generator\uac00 \uc544\ub2c8\ub77c iterator\uac00 \ube44\ub3d9\uae30\ub85c \ub3d9\uc791\ud55c\ub2e4.(awaitable). template < typename T > struct async_generator { struct promise_type ; // Awaitable interface\ub97c \uad6c\ud604\ud574\uc57c \ud55c\ub2e4. struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // \uc9c0\uae08\uc740 \uc608\uc81c\uc774\ubbc0\ub85c, \uc5b8\uc81c\ub098 \uac12\uc774 \uc874\uc7ac\ud55c\ub2e4. \ub530\ub77c\uc11c \uc911\ub2e8\ud558\uc9c0\ub3c4 \uc54a\ub294\ub2e4. bool await_ready () const { return true ; } // \uc911\ub2e8\ud558\uc9c0 \uc54a\uc73c\ubbc0\ub85c \ub0b4\uc6a9\uc774 \uc5c6\ub2e4. void await_suspend ( coroutine_handle <> hcoro ) {} // \uc774 \ud568\uc218\uc758 \ubc18\ud658\uac12\uc774 `co_await`\uc5d0\uac8c \uc804\ub2ec\ub41c\ub2e4. iterator await_resume () const { return * this ; } }; // iterator }; // async_generator \uba64\ubc84\ud568\uc218 3\uac1c\ub97c iterator \uc5d0 \ucd94\uac00\ud568\uc73c\ub85c\uc368, awaitable \uc778\ud130\ud398\uc774\uc2a4\ub97c \uad6c\ud604\ud558\uc600\uace0 for co_await \uad6c\ubb38\uc744 \uc4f8 \uc218 \uc788\uc5c8\ub2e4. \ud558\uc9c0\ub9cc Awaitable Interface \ub2e8\ub77d\uc5d0\uc11c \uc124\uba85\ud588\ub4ef \uad73\uc774 \uba64\ubc84\ud568\uc218\uc77c \ud544\uc694\ub294 \uc5c6\ub2e4. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } \uc774\ub807\uac8c \ubcf4\uc870 \ud568\uc218\ub97c \uc815\uc758\ud558\ub294 \uac83 \ub9cc\uc73c\ub85c\ub3c4 \uae30\uc874\uc5d0 \uc0ac\uc6a9\ud558\ub358 iterator \ud0c0\uc785\ub4e4\uc744 \uc7ac\ud65c\uc6a9\ud560 \uc218 \uc788\ub2e4.","title":"Example"},{"location":"articles/exploring-msvc-coroutine-kor/#_24","text":"MSVC \ucf54\ub8e8\ud2f4\uc758 \uac1c\ub150\uacfc \ucf54\ub4dc\ub97c \ud6d1\uc5b4\ubd24\ub2e4. \uadf8\uac8c \uc804\ubd80\ub2e4. \ubd80\ub514 \ub3c4\uc6c0\uc774 \ub418\uc5c8\uae30\ub97c. \uc0ac\uc2e4 \uc774 Feature\uc758 \ub514\uc2a4\uc5b4\uc148\ube14\ub9ac \uacb0\uacfc\uc5d0 \ub300\ud574\uc11c\ub3c4 \uc4f0\uace0 \uc2f6\uc5c8\ub294\ub370, \uad00\ub828\ud574\uc11c\ub294 \uc544\uc9c1 \ucd08\ubcf4\uc790 \ub2e8\uacc4\ub77c \uc81c\ub300\ub85c \uc124\uba85\ud560 \uc218\uac00 \uc5c6\uc5c8\ub2e4. \uae30\ud68c\uac00 \ub41c\ub2e4\uba74 \ucc28\ud6c4\uc5d0 \ub2e4\uc2dc \uae00\uc744 \uc368\ubcf4\uace0 \uc2f6\ub2e4. \ub098\uc911\uc5d0 \ub354\uc6b1 \uac1c\uc120\ud560 \uae30\ud68c\uac00 \uc788\uae30\ub97c. :D","title":"\ub05d! \ud6c4\uae30"},{"location":"articles/exploring-msvc-coroutine/","text":"Exploring MSVC Coroutine Written in 2017/02/17 \ud55c\uad6d\uc5b4 Reference Proposal N3858 N3977 N4134 N4402 Visual C++ Team Blog Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++ Video CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\" GitHub kirkshoop/ await Caution To try this feature, you need 3 things. Visual Studio 2015 Up3 or later. /await Compiler option <experimental/*> header files to include. Definition So, what is coroutine? Old Fashion : The Machine Level For me, the story starts from The Art of Computer Programming , written by Donald Knuth. Basically, the procedure call is goto . But, goto where? As you know, program can be thought as a sequence of states. And program's state, which is defined by programmer, is composition of machine environment and memory. It can be finite, or infinite. Program State = Environment X Memory (Cartesian Product) Here, instructions are transition between states. And routine is a ordered group of instructions. Instruction : Transition between states Routine : Ordered group of instructions Now, let's go to subroutine & coroutine. Concept : Relation All programmers have their own mental model for codes. Lets start from the point. Mental model for subroutine and coroutine. Subroutine : Caller-Callee Caller expects some states (Pre-condition). And it knows which routine is required. Callee, with specified (in other words, well-defined) codes, do its work without consideration of its caller. It can be impure with side-effect. But it's about work, not the relation. Coroutine : Activator-Activator Coroutine is cooperative routine. In other worlds, it is aware of the other routines. Notice that both are activated and activating by each other. Coroutine is activated by Invoker and Resuming routine. And by suspending or returning, coroutine activates its peer. In real, these activations are equal to jump( goto / jmp ) instruction. So some suspension can be considered as invocation. Or there might not be significant difference between suspension and finalization. If the point is entry(prologue) of routine, it is invocation ( call ). If the flow goes to the middle of procedure, then it's activation ( resume ). Invocation: Jump to start the routine Activation: Jump into a point of the routine Like subroutine, coroutines has specification for its pre-condition and post-condition. Therefore it must be designed with consideration of modification on program state. But after its work, it preserves the state and goto another point. This is suspension ( yield ). Of course, this can be return. In that case, it just finalizes and then return to its caller. (Since they have activation records) Suspension: Jump to another point without finalization Finalization: Destroy(cleanup) all function resources Difference? So, the major difference of coroutine/subroutine is that coroutine supports more operations. This is why Knuth summarized in his book. \"Subroutines are special cases of ... coroutines\" - Donald Knuth Let's see that in table form. Operation Subroutine Coroutine Invoke o o General procedure start Activate x o goto a specific point of procedure Suspend x o Yield current control flow Finalize o o Cleanup and return Clearly, subroutine is limited but easy and simple in relationship. However, coroutine have more operations, but might be complex because it suspension and activation should be managed. Routine: Group of instructions that modify the program state to another with defined statements Subroutine: Routine that supports 2 operations Invoke Finalize Coroutine: Routine that supports 4 operations Invoke Activate Suspend Finalize Example Knuth wrote how this is expressed in code. You don't have to understand all MIX instructions. Unlike theseday's subroutine, operations are usually JMP without abstraction. What I want to explain is that there is a gap between High-level and Assembly languages. The key point is coroutine has multiple points for entry and exit . Also, they have some implicit states. // MIX example, modified // The Art of Computer Programming 1.4.2. // For detail, read the book. :D // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF . Motivation : Programming Model It's a stack! \"It's A Trap!\" - Admiral Ackbar These days, we are familiar with high-level languages with runtime stack. It's fancy, well-defined, and automated. Think of structured, stack-ful program's model. In the model, the program is basically a mathematical expression tree that flows in depth-first order. For instance, main function finished at some time point and then it returns a value. Like figure, functions in this model embeds a sequence of statements when it is written. To reach the statement B, we have to finish the traversal for statement A. Then, the program state is affected by statement A. Memory locations will containing result values. Environments like registers will be set as defined. Blocking But the dependency became a problem. Remind that tree model follows mathematics. If we have all values in the expression, the calculation can be processed without blocking. Since we don't have infinite resource, we can't prepare all values when the flow starts. So, we need some In/Out operations. which is extremely slow. Waiting its result blocks our control flow. We don't want to stop our program. We want responsiveness. That's why we started to use non-blocking operations and to apply some asynchronous programming models. We generalized the program tree to a graph form. Which is another notation for state machine. Now, the program is graph of states . And our processors traverse over it. Processor can be OS Process, OS Thread, or some language supported abstraction such as Goroutine and Erlang process. But, Let me skip them, we are thinking about coroutine now. Persistence The point is, we have to deliver some context between vertices of the graph. But subroutine can't do this. Because it always destroyes(finalizes) itself. Subroutine is lack of persistence. It returns to caller. That's how runtime stack works. But it disabled us to pass contexts between states. Think of callback hell to enable that context forwarding. \"James. This code has a bug. Can you fix it?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); } Approach We need some persistent function. Reminding coroutine suspend/yield its control without finalization, the answer is crystal clear. Coroutine can take the role. But how can we migrate that assembly concept into our stack world? Let's change the question. What should be persistent?: Context What is context?: The routine's state What makes the state?: Environment & Memory Where are they?: Function Frame Henceforce, our migration starts from how to make those frames persistent . If you can't get what it is, visit this page . Stackful? Stackless! \"Why do you rob banks?\" \"That's where the money is.\" - Bank robber Stackful or Segmented Stack It differes upon language, but C++ places function frames in runtime stack. To preserve some frame, we have to dump it and store it in some location. Or we can make a smaller chunk of space and use it as a side(alternantive) stack for function. But let's bypass them. Our focus, MSVC coroutine is stackless. Stackless - Function Frame N3858 wrote about resumable function's implementability. It suggested heap-allocated activation frames. But frame is just a structure. Remind that we need 4 operations for coroutine. Those are declared as compiler intrinsic. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... So there is nothing we can touch.(Unless you are in MSVC team... right?) But if you want more detail, follow the references above and watch CppCon talks. you may noticed there are 2 kinds of concept. Frame and Block. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block It is not clear for me now. Let me update this section later. In my opinion, the frame is activation record for the function (In the case, resumable function). And block is space for function code. Therefore, it will contain local/captured arguments, And it's size will depends on maximum stack size of the function. ... Probably. The C++ Coroutine : Resumable Function At this point, we have to define 2 terms. Coroutine : Concept . Routine that supports 4 operations Resumable Function : Implementation of coroutine concept in C++ world And the following table is about how to use its operations Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return Invoke For function call, there is no change. But the resumable function returns std::future<T> . Finalize Cleanup and return point can be specified the well-known keyword, return . For same purpose, in resumable function, co_return statement is used. Suspend When you wan to suspend funtion and yield its control, co_yield expression and co_await operator can do that. By adding 1 of them, the suspend/resume point is specified and MSVC will treat the function as coroutine. (Also, co_return statement can be used) Activate When we have to activate suspended function, we will use coroutine_handle and its memeber function, .resume() . This is an interface to compiler intrinsic _coro_resume above. Code Example codes are inspired by kirkshoop's repository . In short, if we follows MSVC's requirement, we can use C++ coroutine. But notice that the title of proposal is resumable (therefore, persistent) function. However, its category differs to which meaning you want to carry with. Before that, let's start with compiler's requirement. Promise : Compiler's Requirement You may already know about std::future<T> and std::promise<T> , and relation of the pair. Usually, future<T> is something like \"I will return value or exception later \" (See std::async() ). And the value/exception is transferred via promise<T> . It is, \"I kept the promise for the value\". And I already explained that resumable returns future<T> . Literally, This is not weird because coroutine can suspends itself and therefore its activator can't sure that it has returned. However, with the signature, programmer can still explicitly specify for return type just like conventional subroutine. But here, the promise is for resumable function. See N4402 . You may ask why this is necessary. The answer is that resumable function is abstraction . Because of stack, we had migrated the coroutine concept but not assembly-like flat code. Our resumable function lives in heap and to pass value from heap space(from function frame) to stack space(to future or awaitable), there must be some interface . For both compiler and programmer. Resumable Promise Requirement I will explain how this interface is used soon. According to N4402, the promise type for resumable function should support operations in the table below. I summarized note column. For detail, please read the document. Expression Note P{} Promise must be default constructible p.get_return_object() The return value of funtion. It can be future<T> , or some user-defined type. p.return_value(v) co_return statement. Pass the value v and the value will be consumed later. p.return_value() co_return statement. Pass void . Can be invoked when the coroutine returns. And calling this can be thought as \"No more value\". p.set_exception(e) Pass the exception. It will throw when the resumer activates the function with this context. p.yield_value(v) co_yield expression. Similar to return_value(v) . p.initial_suspend() If return true , suspends at initial suspend point. p.final_suspend() If return true , suspends at final suspend point. Some operations are related to coroutine_traits<T> . Later section will describe its flexibility. It is pretty abstract for now, but we are in progress. Lets move our focus to usecases of C++ coroutine. Generator Concept Generator = Iterator + Resumable Function See? There is an iterator. generator<T> is abstraction for sequence of values, which are generated by resumable function. The function is persistent, and contains some unique context in its frame. Example The following code is simple generator for fibonacci numbers. #include <experimental/generator> // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // Set the value and suspend co_yield f1 ; // Calculate next fibo and shift int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // No more value } void usecase () { // A sequence of 10 fibo numbers for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } How this can be possible? Well, lets see the definition of generator<T> . Detail Here is a skeleton of generator<T> . We can see that it supports iterator and promise_type . and begin() / end() function to support Range-based for loop template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // Handle for Resumable Funtion coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // If we have handle, we can resume it to get the value. if ( _Coro ) { _Coro . resume (); // The function returned? if ( _Coro . done ()) return { nullptr }; // return end(); } // The function is not finished. // Will be reused later... return { _Coro }; } iterator end () { // No handle, No more value. return { nullptr }; } ~ generator () { // RAII : Destroy function frame if ( _Coro ) { _Coro . destroy (); } } }; So, the actual usecase function will be like this. void usecase () { // A generator for 10 fibo numbers generator < int > gen = fibonacci ( 10 ); // We cannot use `iter++` because it is deleted. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } Pretty simple with the iterator! Let's hack the iterator then... template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Iterator interface struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // When we move next... iterator & operator ++ () { // Make the function yield next value _Coro . resume (); // If done, just release. // Generator will destroy it later... if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // This is MSVC comment.... // In short, post increment can overlap the handle in iterator. // And it can leak the last value in coroutine frame. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // We use `promise` to get the value. // It is pointing the value in function frame _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; At this point, we can understand that iterator is resuming the function repetitively. And acquiring value from generator<T> 's promise_type . So in this case, usecase function is both invoker and resumer for the generator . Compiler's View Now, the keystone promise_type is on the stage. It has more codes but I will skip them for simplicity. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } The promise_type supports 4 functions in requirement. get_return_object , initial_suspend , final_suspend , and yield_value . In short, co_yield is equal to \"Set the value and suspend\". Compiler will change the expression like following. co_yield : co_await + p.yield_value(x) Therefore, co_yield with empty expression is impossible . Because x can't be void . Since generator is abstraction of sequence, this is natural constraint. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // Compiler changes the expression to... // co_yield f1; p . yield_value ( f1 ); // Set the value pointer co_await suspend_always {}; // And suspend. // ... } co_return ; // No more value } Notice that there is no promise_type p{} or something else. Its secret will be covered in next section. Resumable Function This section starts from detail. The example code will be seen after explanation of awaitable concept. Concept Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> was simple example. And you may remember that it contains coroutine_handle . Let's cover the type. coroutine_handle was resumable_handle . Remembering that resumable function is C++ implementation of coroutine concept, it is alias of resumable function handle. If you have an experience of Windows API, you probably know what handle means. It is void * . We already talked about how stackless coroutine can be implemented. MSVC uses heap allocated function frame and supports several intrinsics. With the pointer to frame in heap, coroutine_handle adds some operation over it. Resumable Frame Then, how does the frame look like? As I commented above, the frame of resumable function. It has head and body. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // Head of function frame // - Fn : Instruction address for resume operation // - cdecl : Caller manages the frame. Callee won't touch it. // - Index : Index to resumption point. // 0 is special value for `done()` // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // Coroutine Frame will include... // - Promise // - Captured arguments // - Function body // - Local Variables and Temporaries // - Platform context // - Registers // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : Like its name, _Resumable_frame_prefix is head of coroutine frame. MSVC uses fixed size of sizeof(void *) * 2 (16 bytes in x64) for this struct. Fn : Note that this is declared as cdecl convention. Since cdecl specifies stack cleanup (in the case, frame destruction) is up to caller, the call of Fn won't destroy the frame. Index : Resumable function can have multiple resumption point. This is a index for the point. Flag : ??? Who are you ??? Body : N4402 describes what frame includes. Based on James McNellis's PPT, the compiler-generated frame body will be like the following code. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // Possible frame for fibonacci function struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _p ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; Coroutine Traits We didn't cover p.get_return_object() yet. This is the section for the topic. Let me explain coroutine_traits first... // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; It's pretty simple. coroutine_traits requires promise_type to be implemented at compile time. And it must follow Resumable Promise Requirement . I explaind that resumable function returns future<T> , but that was not correct. If there is a type that fulfills the coroutine_traits , it can be return type of Resumable function. Let't go to template specialization of coroutine_traits for std::future<T> . Previous example, generator<T> implemented promise type in itself, but with the specialization trick, we can reuse some old types or try some custom type. // <future> #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // Template Specialization for `std::future<T>` template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // defines resumable traits for functions returning future<_Ty> struct promise_type { // `std::promise<T>` promise < _Ty > _MyPromise ; // Resumable function can return `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // if `false`, we skip the initial suspend point. bool initial_suspend () const { return ( false ); } // if `false`, we skip the final suspend point. bool final_suspend () const { return ( false ); } // Pass the value through `std::promise<T>` template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // Pass the exception through `std::promise<T>` void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif When MSVC meets co_await / co_yield / co_return , it applies coroutine_traits to enable compile-time check. Let's see the fibonacci example again. It will show what MSVC does. The code might be wrong. I will update it as I find correct mechanism. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { using return_type = generator < int > ; // At this point, compiler will generate code // and check `return_type` fulfills promise requirement. using traits = coroutine_traite < return_type > ; // Requirement : OK. // We can generate unique frame type for this function. // Possible frame for fibonacci function struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // We are forwarding arguments to frame! // Let's call it context(ctx) __frame * ctx = new __frame { std :: move ( n )}; // Generate return objet // In this case, `generator<int>` return_type __return = ctx -> _promise . get_return_object (); // if true, suspend. // if false, keep move... if ( ctx -> _promise . initial_suspend () ){ // always true // suspend... __initial_suspend_point : } // User code : use variables in frame(ctx)... // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // Pass value through promise // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // instructions for suspension with `ctx->_prefix`... // co_await suspend_always{}; __suspend_resume_point_1 : // Calculate next fibo and shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // always true // suspend... __final_suspend_point : } // Instructions for clean up... } So we could find out that compiler do a lot of job instead of us. And using frame pointer ctx is not that different from this pointer for memeber functions. Therefore, the cost for frame-based code will be negligible. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend; Section Summary We covered co_return and co_yield with generator<T> example. Generator was a combination of iterator and resumable function. Resumable functions use coroutine_handle , which is basically raw pointer to function frame and some operations that rely on compiler intrinsics. The mechanism for frame-based approach was pretty similar to this pointer approach. For compile-time(static) assertion, coroutine_traits<T> is used. It enforce the return type to support promise_type that fulfills resumable promise requirement. And there was a specialization especially for std::future<T> . The Awaitable Concept operator co_await = Syntactic Sugar + Resumable Function The last core of resumable function is co_await . It is unary operator. In this semantics, await is synonym of suspend . And because of suspension, its return value becomes asynchronous . This is the important point for our mental model. You may thought async & await of C# language, The difference in C++ world is that we can manage them manually , with our code and compiler support. Example The code is sample from MSVC blog. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // operator overload. // co_await can't use primitive type parameter. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // Awaitable must implements 3 function. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback Thread will resume the function coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // If not ready (`false`), invoke `await_suspend` // If ready (`true`), go to `await_resume` directly. bool await_ready () const { return duration . count () <= 0 ; } // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // Set the timer and then suspend... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Return T type's value after resumed. // T can be `void`. void await_resume () {} }; return awaiter { duration }; } // Resumable Function future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // await for 1 millisecond... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // This is normal subroutine void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } It's flow is like the figure. Awaitable Interface co_await requires some interface for its operation. As we can see in code above, Awaitable interface should implement at least 3 functions. await_ready await_suspend await_resume It can be both member and normal function. future<T> also implements this interface. so future can be an argument for co_await . But just like the code await_suspend , it can be inefficient. For user-defined type, simple overload is enough. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std How about compiler's view? How does it change our code? Compiler's View operator co_await = Syntactic Sugar + Resumable Function I explained that co_await is syntatic sugar. If operator's argument type implements awaitable concept appropriately, the code will be modified by compiler. Revisiting previous example, test function which awaits for 1 millisecond, let's see how it works... // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // With `co_await` keyword in function body, // compiler will make this function to resumable. future < void > test () { // Compiler-generated coroutine frame... __frame * context ; // ... // Awaitable type implements awaitable interface. // Precisely, this will be temporary variable in frame. awaiter aw = operator co_await ( 1 ms ); // Do we have expected value now? // If not, suspend. // If ready, skip the suspend and resume directly. if ( aw . await_ready () == false ) // await_ready(aw); { // Wrap the function frame to `coroutine_handle` type coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); aw . await_suspend ( resume_cb ); // some instructions.... __suspend_resume_point_1 : // Since resume point is in this scope, // there won't be suspension if ready()==true. } // If await_resume has return type... // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } So there are some points for each of interface functions. await_ready : \"Do we have return value now?\" await_ready makes the branch. It asks value for await_resume is ready. If not, the control flows into the scope of if statement. If it's ready, await_ready returns true and await_resume will be invoked directly. Compiler can optimize the code if it returns false always. In the case, we don't need suspension and therefore frame wrapping becomes unnecessary. The coroutine will become normal subroutine after optimization steps. In suspension scope, we must ready for suspension. Since coroutine_handle<> is just a raw pointer to frame, we can wrap it easily with static function coroutine_handle<>::from_address . await_suspend : \"The routine will suspend soon. Do what you have to do!\" await_suspend receives coroutine_handle<> for its argument. With this function, we can interleave our code for suspension handling. // The example code set the Windows Thread Pool Timer // and forward frame's address as callback argument. class awaiter { // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // Unwrap the handle resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // A thread in Windows Thread Pool will invoke this callback. // And it will be resumer for the function. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Wrap the frame to handle again. And resume. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"Now, here is the return value and control flow\" Suspend/resume point is created for resume operation. When the coroutine handle's .resume() is invoked, the function will set the context(frame pointer) and jump to it. The flow then exits the scope and call await_resume . Notice that we did suspend because the value wasn't ready( await_ready ). When the function is resumed, there should be return value. If await_resume 's return type is void, it means control flow is back. co_await Tricks Kenny Kerr and James Mcnellis introduced several tricks with this mechanism. I strongly recommend you to watch the video. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Async Generator Concept Async Generator = Awaitable iterator + Resumable function This is similar to Generator's concept, but it has awaitable iterator . In other words, we can use for co_await statement for it. Kirkshoop will give you clear explanation for this. Example I won't write hard example since I hadn't try this feature. But previous examples and explanations will help your understanding. // Infinite sequence of interger. async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await statement for co_await ( int v : infinite ()) { // do something with `v`... } } I sad iterator is awaitable. So real code of usecase will be like following. std :: future < void > usecase () { // generator with awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `co_await` + `begin()` iter != gen . end (); // `end()` has nullptr co_await ++ iter ) // `co_await` + `operator++()` { int v = * iter ; // ... } } The only difference form generator<T> example is that the function is awaiting iterator at 2 points. begin() and operator++() . These are points for resume operation. Here, value type is primitive type int . So there won't be complex code here. The following code shows how to make awaitable iterator. The other code for generator body and promise_type is exactly same with std::experimental::generator<T> // Actually, generator is not async. Its iterator is async(awaitable). template < typename T > struct async_generator { struct promise_type ; // Same with experimental generator // We will implement awaitable interface... struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // Since this is syntactic example, there is no suspension. bool await_ready () const { return true ; } // With no suspension, there is nothing to do with handle. void await_suspend ( coroutine_handle <> hcoro ) {} // Return awaitable iterator at resume point iterator await_resume () const { return * this ; } }; // iterator }; // async_generator By adding 3 member functions for iterator , we could make it awaitable and became available to use for co_await statement. But as I mentioned at Awaitable Interface section, you don't have to add member function. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } Adding these helper functions for old types will work fine. Conclusion So, we have traveled MSVC coroutine from concept to code. That's all. I wish I made helpful description. I'd like to add disassembly experience about this feature, but I can't make it because I'm a beginner for that ability. I will try that topic later. I couldn't make this article in more detail. Maybe there could be a chance to update this...! :D","title":"Exploring MSVC Coroutine"},{"location":"articles/exploring-msvc-coroutine/#exploring-msvc-coroutine","text":"Written in 2017/02/17 \ud55c\uad6d\uc5b4","title":"Exploring MSVC Coroutine"},{"location":"articles/exploring-msvc-coroutine/#reference","text":"","title":"Reference"},{"location":"articles/exploring-msvc-coroutine/#proposal","text":"N3858 N3977 N4134 N4402","title":"Proposal"},{"location":"articles/exploring-msvc-coroutine/#visual-c-team-blog","text":"Coroutines in Visual Studio 2015\u2013 Update 1 More about resumable functions in C++","title":"Visual C++ Team Blog"},{"location":"articles/exploring-msvc-coroutine/#video","text":"CppCon 2016 : Gor Nishanov \"C++ Coroutines: Under the covers\" CppCon 2016 : James McNellis \"Introduction to C++ Coroutines\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" CppCon 2016 : John Bandela \u201cChannels - An alternative to callbacks and futures\" CppCon 2015 : Gor Nishanov \"C++ Coroutines - a negative overhead abstraction\" Meeting C++ 2015 : James McNellis \"An Introduction to C++ Coroutines\" Meeting C++ 2015 : Grigory Demchenko \"Asynchrony and Coroutines\" CppCon 2014 : Gor Nishanov \"await 2.0: Stackless Resumable Functions\"","title":"Video"},{"location":"articles/exploring-msvc-coroutine/#github","text":"kirkshoop/ await","title":"GitHub"},{"location":"articles/exploring-msvc-coroutine/#caution","text":"To try this feature, you need 3 things. Visual Studio 2015 Up3 or later. /await Compiler option <experimental/*> header files to include.","title":"Caution"},{"location":"articles/exploring-msvc-coroutine/#definition","text":"So, what is coroutine?","title":"Definition"},{"location":"articles/exploring-msvc-coroutine/#old-fashion-the-machine-level","text":"For me, the story starts from The Art of Computer Programming , written by Donald Knuth. Basically, the procedure call is goto . But, goto where? As you know, program can be thought as a sequence of states. And program's state, which is defined by programmer, is composition of machine environment and memory. It can be finite, or infinite. Program State = Environment X Memory (Cartesian Product) Here, instructions are transition between states. And routine is a ordered group of instructions. Instruction : Transition between states Routine : Ordered group of instructions Now, let's go to subroutine & coroutine.","title":"Old Fashion : The Machine Level"},{"location":"articles/exploring-msvc-coroutine/#concept-relation","text":"All programmers have their own mental model for codes. Lets start from the point. Mental model for subroutine and coroutine.","title":"Concept : Relation"},{"location":"articles/exploring-msvc-coroutine/#subroutine-caller-callee","text":"Caller expects some states (Pre-condition). And it knows which routine is required. Callee, with specified (in other words, well-defined) codes, do its work without consideration of its caller. It can be impure with side-effect. But it's about work, not the relation.","title":"Subroutine : Caller-Callee"},{"location":"articles/exploring-msvc-coroutine/#coroutine-activator-activator","text":"Coroutine is cooperative routine. In other worlds, it is aware of the other routines. Notice that both are activated and activating by each other. Coroutine is activated by Invoker and Resuming routine. And by suspending or returning, coroutine activates its peer. In real, these activations are equal to jump( goto / jmp ) instruction. So some suspension can be considered as invocation. Or there might not be significant difference between suspension and finalization. If the point is entry(prologue) of routine, it is invocation ( call ). If the flow goes to the middle of procedure, then it's activation ( resume ). Invocation: Jump to start the routine Activation: Jump into a point of the routine Like subroutine, coroutines has specification for its pre-condition and post-condition. Therefore it must be designed with consideration of modification on program state. But after its work, it preserves the state and goto another point. This is suspension ( yield ). Of course, this can be return. In that case, it just finalizes and then return to its caller. (Since they have activation records) Suspension: Jump to another point without finalization Finalization: Destroy(cleanup) all function resources","title":"Coroutine : Activator-Activator"},{"location":"articles/exploring-msvc-coroutine/#difference","text":"So, the major difference of coroutine/subroutine is that coroutine supports more operations. This is why Knuth summarized in his book. \"Subroutines are special cases of ... coroutines\" - Donald Knuth Let's see that in table form. Operation Subroutine Coroutine Invoke o o General procedure start Activate x o goto a specific point of procedure Suspend x o Yield current control flow Finalize o o Cleanup and return Clearly, subroutine is limited but easy and simple in relationship. However, coroutine have more operations, but might be complex because it suspension and activation should be managed. Routine: Group of instructions that modify the program state to another with defined statements Subroutine: Routine that supports 2 operations Invoke Finalize Coroutine: Routine that supports 4 operations Invoke Activate Suspend Finalize","title":"Difference?"},{"location":"articles/exploring-msvc-coroutine/#example","text":"Knuth wrote how this is expressed in code. You don't have to understand all MIX instructions. Unlike theseday's subroutine, operations are usually JMP without abstraction. What I want to explain is that there is a gap between High-level and Assembly languages. The key point is coroutine has multiple points for entry and exit . Also, they have some implicit states. // MIX example, modified // The Art of Computer Programming 1.4.2. // For detail, read the book. :D // Subroutine for character input READER EQU 16 INPUT ORIG *+16 NETCHAR STJ 9F JXNZ 3F // ---> (3H) 1H J6N 2F // ---> (2H) IN INPUT(READER) JBUS *(READER) ENN6 16 2H LDX INPUT+16,6 // <--- (1H) J6N 2F INC6 1 3H ENTA 0 // <--- JXNZ 3F SLAX 1 9H JANZ * JMP NEXTCHAR+1 // First coroutine 2H INCA 30 // <--- JGE 2B JMP OUT // ---> OUT1 IN1 JMP NEXTCHAR // ---> NETCHAR // <-- DECA 30 JAN 2B // ---> (2H) CMPA =10= JGE 2B // ---> (2H) STA *,1(0:2) ENT5 * JMP NEXTCHAR // ---> NETCHAR // <-- JMP OUT // ---> OUT1 // <--- J5NN *-2 DEC5 1 J5NN *-2 // ---> JMP OUT JMP IN1 // ---> (IN1) // Second coroutine ALF OUTPUT ORIG *+16 PUNCH EQU 17 OUT1 ENT4 -16 // <--- JMP OUT MOVE -1,1(16) 1H JMP IN // ---> IN1 STA OUTPUT+16,4(1:1) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) JMP IN // ---> IN1 STA OUTPUT+16,4(2:2) CMPA PERIOD JE 9F // ---> (9H) INC4 1 J4N 1B // ---> (1H) 9H OUT OUTPUT(PUNCH) JBUS *(PUNCH) JNE OUT1 // ---> OUT1 HLT PERIOD ALF .","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#motivation-programming-model","text":"","title":"Motivation : Programming Model"},{"location":"articles/exploring-msvc-coroutine/#its-a-stack","text":"\"It's A Trap!\" - Admiral Ackbar These days, we are familiar with high-level languages with runtime stack. It's fancy, well-defined, and automated. Think of structured, stack-ful program's model. In the model, the program is basically a mathematical expression tree that flows in depth-first order. For instance, main function finished at some time point and then it returns a value. Like figure, functions in this model embeds a sequence of statements when it is written. To reach the statement B, we have to finish the traversal for statement A. Then, the program state is affected by statement A. Memory locations will containing result values. Environments like registers will be set as defined.","title":"It's a stack!"},{"location":"articles/exploring-msvc-coroutine/#blocking","text":"But the dependency became a problem. Remind that tree model follows mathematics. If we have all values in the expression, the calculation can be processed without blocking. Since we don't have infinite resource, we can't prepare all values when the flow starts. So, we need some In/Out operations. which is extremely slow. Waiting its result blocks our control flow. We don't want to stop our program. We want responsiveness. That's why we started to use non-blocking operations and to apply some asynchronous programming models. We generalized the program tree to a graph form. Which is another notation for state machine. Now, the program is graph of states . And our processors traverse over it. Processor can be OS Process, OS Thread, or some language supported abstraction such as Goroutine and Erlang process. But, Let me skip them, we are thinking about coroutine now.","title":"Blocking"},{"location":"articles/exploring-msvc-coroutine/#persistence","text":"The point is, we have to deliver some context between vertices of the graph. But subroutine can't do this. Because it always destroyes(finalizes) itself. Subroutine is lack of persistence. It returns to caller. That's how runtime stack works. But it disabled us to pass contexts between states. Think of callback hell to enable that context forwarding. \"James. This code has a bug. Can you fix it?\" - Gor Nishanov, CppCon2015 std :: future < int64_t > tcp_reader ( int64_t total ) { struct reader_state { std :: array < char , 4096 > _buffer ; int64_t _total ; tcp :: connection _connection ; explicit reader_state ( int64_t total ) : _total ( total ) {} }; auto state = std :: make_shared < reader_state > ( total ); return tcp :: connect ( \"127.0.0.1\" , 1337 ). then ( [ state ]( std :: future < tcp :: connection > the_connection ) { state -> _connection = std :: move ( the_connection . get ()); return do_while ([ state ]() -> std :: future < bool > { if ( state -> _total <= 0 ) { return std :: make_ready_future ( false ); } return state -> conn . read ( state -> _buffer . data (), sizeof ( state -> _buffer )). then ( [ state ]( std :: future < int64_t > bytes_read_future ) { int64_t bytes_read = bytes_read_future . get (); if ( bytes_read == 0 ) { return std :: make_ready_future ( false ); } state -> _total -= bytes_read ; return std :: make_ready_future ( true ); }); }); }); }","title":"Persistence"},{"location":"articles/exploring-msvc-coroutine/#approach","text":"We need some persistent function. Reminding coroutine suspend/yield its control without finalization, the answer is crystal clear. Coroutine can take the role. But how can we migrate that assembly concept into our stack world? Let's change the question. What should be persistent?: Context What is context?: The routine's state What makes the state?: Environment & Memory Where are they?: Function Frame Henceforce, our migration starts from how to make those frames persistent . If you can't get what it is, visit this page .","title":"Approach"},{"location":"articles/exploring-msvc-coroutine/#stackful-stackless","text":"\"Why do you rob banks?\" \"That's where the money is.\" - Bank robber","title":"Stackful? Stackless!"},{"location":"articles/exploring-msvc-coroutine/#stackful-or-segmented-stack","text":"It differes upon language, but C++ places function frames in runtime stack. To preserve some frame, we have to dump it and store it in some location. Or we can make a smaller chunk of space and use it as a side(alternantive) stack for function. But let's bypass them. Our focus, MSVC coroutine is stackless.","title":"Stackful or Segmented Stack"},{"location":"articles/exploring-msvc-coroutine/#stackless-function-frame","text":"N3858 wrote about resumable function's implementability. It suggested heap-allocated activation frames. But frame is just a structure. Remind that we need 4 operations for coroutine. Those are declared as compiler intrinsic. // Header File : <experimental/resumable> // ... // intrinsics used in implementation of coroutine_handle extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); #pragma intrinsic(_coro_resume) #pragma intrinsic(_coro_destroy) #pragma intrinsic(_coro_done) // ... // resumable functions support intrinsics extern \"C\" size_t _coro_frame_size (); extern \"C\" void * _coro_frame_ptr (); extern \"C\" void _coro_init_block (); extern \"C\" void * _coro_resume_addr (); extern \"C\" void _coro_init_frame ( void * ); extern \"C\" void _coro_save ( size_t ); extern \"C\" void _coro_suspend ( size_t ); extern \"C\" void _coro_cancel (); extern \"C\" void _coro_resume_block (); #pragma intrinsic(_coro_frame_size) #pragma intrinsic(_coro_frame_ptr) #pragma intrinsic(_coro_init_block) #pragma intrinsic(_coro_resume_addr) #pragma intrinsic(_coro_init_frame) #pragma intrinsic(_coro_save) #pragma intrinsic(_coro_suspend) #pragma intrinsic(_coro_cancel) #pragma intrinsic(_coro_resume_block) // ... So there is nothing we can touch.(Unless you are in MSVC team... right?) But if you want more detail, follow the references above and watch CppCon talks. you may noticed there are 2 kinds of concept. Frame and Block. Coroutine _coro_resume _coro_destroy _coro_done _coro_save _coro_suspend _coro_cancel _coro_resume_addr Frame _coro_frame_ptr _coro_frame_size _coro_init_frame Block _coro_init_block _coro_resume_block It is not clear for me now. Let me update this section later. In my opinion, the frame is activation record for the function (In the case, resumable function). And block is space for function code. Therefore, it will contain local/captured arguments, And it's size will depends on maximum stack size of the function. ... Probably.","title":"Stackless - Function Frame"},{"location":"articles/exploring-msvc-coroutine/#the-c-coroutine-resumable-function","text":"At this point, we have to define 2 terms. Coroutine : Concept . Routine that supports 4 operations Resumable Function : Implementation of coroutine concept in C++ world And the following table is about how to use its operations Operation Subroutine Coroutine Invoke func(args) func(args) Activate x resume() Suspend x co_yield / co_await Finalize return co_return","title":"The C++ Coroutine : Resumable Function"},{"location":"articles/exploring-msvc-coroutine/#invoke","text":"For function call, there is no change. But the resumable function returns std::future<T> .","title":"Invoke"},{"location":"articles/exploring-msvc-coroutine/#finalize","text":"Cleanup and return point can be specified the well-known keyword, return . For same purpose, in resumable function, co_return statement is used.","title":"Finalize"},{"location":"articles/exploring-msvc-coroutine/#suspend","text":"When you wan to suspend funtion and yield its control, co_yield expression and co_await operator can do that. By adding 1 of them, the suspend/resume point is specified and MSVC will treat the function as coroutine. (Also, co_return statement can be used)","title":"Suspend"},{"location":"articles/exploring-msvc-coroutine/#activate","text":"When we have to activate suspended function, we will use coroutine_handle and its memeber function, .resume() . This is an interface to compiler intrinsic _coro_resume above.","title":"Activate"},{"location":"articles/exploring-msvc-coroutine/#code","text":"Example codes are inspired by kirkshoop's repository . In short, if we follows MSVC's requirement, we can use C++ coroutine. But notice that the title of proposal is resumable (therefore, persistent) function. However, its category differs to which meaning you want to carry with. Before that, let's start with compiler's requirement.","title":"Code"},{"location":"articles/exploring-msvc-coroutine/#promise-compilers-requirement","text":"You may already know about std::future<T> and std::promise<T> , and relation of the pair. Usually, future<T> is something like \"I will return value or exception later \" (See std::async() ). And the value/exception is transferred via promise<T> . It is, \"I kept the promise for the value\". And I already explained that resumable returns future<T> . Literally, This is not weird because coroutine can suspends itself and therefore its activator can't sure that it has returned. However, with the signature, programmer can still explicitly specify for return type just like conventional subroutine. But here, the promise is for resumable function. See N4402 . You may ask why this is necessary. The answer is that resumable function is abstraction . Because of stack, we had migrated the coroutine concept but not assembly-like flat code. Our resumable function lives in heap and to pass value from heap space(from function frame) to stack space(to future or awaitable), there must be some interface . For both compiler and programmer.","title":"Promise : Compiler's Requirement"},{"location":"articles/exploring-msvc-coroutine/#resumable-promise-requirement","text":"I will explain how this interface is used soon. According to N4402, the promise type for resumable function should support operations in the table below. I summarized note column. For detail, please read the document. Expression Note P{} Promise must be default constructible p.get_return_object() The return value of funtion. It can be future<T> , or some user-defined type. p.return_value(v) co_return statement. Pass the value v and the value will be consumed later. p.return_value() co_return statement. Pass void . Can be invoked when the coroutine returns. And calling this can be thought as \"No more value\". p.set_exception(e) Pass the exception. It will throw when the resumer activates the function with this context. p.yield_value(v) co_yield expression. Similar to return_value(v) . p.initial_suspend() If return true , suspends at initial suspend point. p.final_suspend() If return true , suspends at final suspend point. Some operations are related to coroutine_traits<T> . Later section will describe its flexibility. It is pretty abstract for now, but we are in progress. Lets move our focus to usecases of C++ coroutine.","title":"Resumable Promise Requirement"},{"location":"articles/exploring-msvc-coroutine/#generator","text":"","title":"Generator"},{"location":"articles/exploring-msvc-coroutine/#concept","text":"Generator = Iterator + Resumable Function See? There is an iterator. generator<T> is abstraction for sequence of values, which are generated by resumable function. The function is persistent, and contains some unique context in its frame.","title":"Concept"},{"location":"articles/exploring-msvc-coroutine/#example_1","text":"The following code is simple generator for fibonacci numbers. #include <experimental/generator> // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { int f1 = 0 ; int f2 = 1 ; for ( int i = 0 ; i < n ; ++ i ) { // Set the value and suspend co_yield f1 ; // Calculate next fibo and shift int f3 = f1 + f2 ; f1 = f2 ; f2 = f3 ; } co_return ; // No more value } void usecase () { // A sequence of 10 fibo numbers for ( int fibo : fibonacci ( 10 )) { // 0, 1, 1, 2, 3, 5, 8 ... 34 } } How this can be possible? Well, lets see the definition of generator<T> .","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#detail","text":"Here is a skeleton of generator<T> . We can see that it supports iterator and promise_type . and begin() / end() function to support Range-based for loop template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement struct promise_type ; private : // Handle for Resumable Funtion coroutine_handle < promise_type > _Coro = nullptr ; public : struct promise_type { /*...*/ }; struct iterator { /*...*/ }; iterator begin () { // If we have handle, we can resume it to get the value. if ( _Coro ) { _Coro . resume (); // The function returned? if ( _Coro . done ()) return { nullptr }; // return end(); } // The function is not finished. // Will be reused later... return { _Coro }; } iterator end () { // No handle, No more value. return { nullptr }; } ~ generator () { // RAII : Destroy function frame if ( _Coro ) { _Coro . destroy (); } } }; So, the actual usecase function will be like this. void usecase () { // A generator for 10 fibo numbers generator < int > gen = fibonacci ( 10 ); // We cannot use `iter++` because it is deleted. for ( auto iter = gen . begin (); iter != gen . end (); ++ iter ) { int fibo = * iter ; // 0, 1, 1, 2, 3, 5, 8 ... 34 } } Pretty simple with the iterator! Let's hack the iterator then... template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Iterator interface struct iterator : _STD iterator < input_iterator_tag , _Ty > { // Resumable function handle coroutine_handle < promise_type > _Coro ; iterator ( nullptr_t ); iterator ( coroutine_handle < promise_type > _CoroArg ); // When we move next... iterator & operator ++ () { // Make the function yield next value _Coro . resume (); // If done, just release. // Generator will destroy it later... if ( _Coro . done ()) _Coro = nullptr ; return * this ; } // This is MSVC comment.... // In short, post increment can overlap the handle in iterator. // And it can leak the last value in coroutine frame. // ---- ---- ---- ---- ---- // generator iterator current_value // is a reference to a temporary on the coroutine frame // implementing post increment will require storing a copy // of the value in the iterator. iterator operator ++ ( int ) = delete ; //{ // auto _Result = *this; // ++(*this); // return _Result; //} // We use `promise` to get the value. // It is pointing the value in function frame _Ty const & operator * () const { return * _Coro . promise (). _CurrentValue ; } _Ty const * operator -> () const ; bool operator == ( iterator const & _Right ) const ; bool operator != ( iterator const & _Right ) const ; }; }; At this point, we can understand that iterator is resuming the function repetitively. And acquiring value from generator<T> 's promise_type . So in this case, usecase function is both invoker and resumer for the generator .","title":"Detail"},{"location":"articles/exploring-msvc-coroutine/#compilers-view","text":"Now, the keystone promise_type is on the stage. It has more codes but I will skip them for simplicity. template < typename _Ty , typename _Alloc = allocator < char >> struct generator { // Resumable Promise Requirement for `generator` struct promise_type { // it knows where the value is... in frame. _Ty const * _CurrentValue ; // It returns `promise_type`. // The reason will be explained in next section. promise_type & get_return_object () { return * this ; } // If return `true`, suspends at initial suspend point. // So we suspends at *some* point bool initial_suspend () { return ( true ); } // If return `true`, suspends at final suspend point. // So we suspends at *some* point bool final_suspend () { return ( true ); } // Support `co_yield` expression void yield_value ( _Ty const & _Value ) { // point the value _CurrentValue = _STD addressof ( _Value ); } // ... } // ... } The promise_type supports 4 functions in requirement. get_return_object , initial_suspend , final_suspend , and yield_value . In short, co_yield is equal to \"Set the value and suspend\". Compiler will change the expression like following. co_yield : co_await + p.yield_value(x) Therefore, co_yield with empty expression is impossible . Because x can't be void . Since generator is abstraction of sequence, this is natural constraint. #include <experimental/generator> auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { // ... for ( int i = 0 ; i < n ; ++ i ) { // Compiler changes the expression to... // co_yield f1; p . yield_value ( f1 ); // Set the value pointer co_await suspend_always {}; // And suspend. // ... } co_return ; // No more value } Notice that there is no promise_type p{} or something else. Its secret will be covered in next section.","title":"Compiler's View"},{"location":"articles/exploring-msvc-coroutine/#resumable-function","text":"This section starts from detail. The example code will be seen after explanation of awaitable concept.","title":"Resumable Function"},{"location":"articles/exploring-msvc-coroutine/#concept_1","text":"Resumable Function : Heap Allocated Frame + Operation Operation : call | co_await | co_return | resume() generator<T> was simple example. And you may remember that it contains coroutine_handle . Let's cover the type. coroutine_handle was resumable_handle . Remembering that resumable function is C++ implementation of coroutine concept, it is alias of resumable function handle. If you have an experience of Windows API, you probably know what handle means. It is void * . We already talked about how stackless coroutine can be implemented. MSVC uses heap allocated function frame and supports several intrinsics. With the pointer to frame in heap, coroutine_handle adds some operation over it.","title":"Concept"},{"location":"articles/exploring-msvc-coroutine/#resumable-frame","text":"Then, how does the frame look like? As I commented above, the frame of resumable function. It has head and body. // TEMPLATE CLASS coroutine_handle template < typename _PromiseT = void > struct coroutine_handle ; // TEMPLATE CLASS coroutine_handle<void> - no promise access template <> struct coroutine_handle < void > { // ---- ---- ---- ---- ---- // Head of function frame // - Fn : Instruction address for resume operation // - cdecl : Caller manages the frame. Callee won't touch it. // - Index : Index to resumption point. // 0 is special value for `done()` // - Flag : ??? struct _Resumable_frame_prefix { typedef void ( __cdecl * _Resume_fn )( void * ); _Resume_fn _Fn ; uint16_t _Index ; uint16_t _Flags ; }; // ---- ---- ---- ---- ---- // Coroutine Frame will include... // - Promise // - Captured arguments // - Function body // - Local Variables and Temporaries // - Platform context // - Registers // ---- ---- ---- ---- ---- protected : _Resumable_frame_prefix * _Ptr ; public : coroutine_handle () noexcept = default ; coroutine_handle ( std :: nullptr_t ) noexcept ; coroutine_handle & operator = ( nullptr_t ) noexcept ; // Import : the pointer to resumable handle static coroutine_handle from_address ( void * _Addr ) noexcept { coroutine_handle _Result ; _Result . _Ptr = reinterpret_cast < _Resumable_frame_prefix *> ( _Addr ); return _Result ; } // Export : return the frame address void * address () const noexcept { return _Ptr ; } explicit operator bool () const noexcept ; void resume () const ; void destroy (); bool done () const { // REVISIT: should return _coro_done() == 0; when intrinsic is // hooked up return ( _Ptr -> _Index == 0 ); } // ... }; Head : Like its name, _Resumable_frame_prefix is head of coroutine frame. MSVC uses fixed size of sizeof(void *) * 2 (16 bytes in x64) for this struct. Fn : Note that this is declared as cdecl convention. Since cdecl specifies stack cleanup (in the case, frame destruction) is up to caller, the call of Fn won't destroy the frame. Index : Resumable function can have multiple resumption point. This is a index for the point. Flag : ??? Who are you ??? Body : N4402 describes what frame includes. Based on James McNellis's PPT, the compiler-generated frame body will be like the following code. Promise Captured arguments Function body Local Variables and Temporaries Platform context Registers // Possible frame for fibonacci function struct __frame_fibonacci { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _p ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. };","title":"Resumable Frame"},{"location":"articles/exploring-msvc-coroutine/#coroutine-traits","text":"We didn't cover p.get_return_object() yet. This is the section for the topic. Let me explain coroutine_traits first... // <experimental/resumable> // TEMPLATE CLASS coroutine_traits template < typename _Ret , typename ... _Ts > struct coroutine_traits { using promise_type = typename _Ret :: promise_type ; }; It's pretty simple. coroutine_traits requires promise_type to be implemented at compile time. And it must follow Resumable Promise Requirement . I explaind that resumable function returns future<T> , but that was not correct. If there is a type that fulfills the coroutine_traits , it can be return type of Resumable function. Let't go to template specialization of coroutine_traits for std::future<T> . Previous example, generator<T> implemented promise type in itself, but with the specialization trick, we can reuse some old types or try some custom type. // <future> #ifdef _RESUMABLE_FUNCTIONS_SUPPORTED namespace std :: experimental { // Template Specialization for `std::future<T>` template < class _Ty , class ... _ArgTypes > struct coroutine_traits < future < _Ty > , _ArgTypes ... > { // defines resumable traits for functions returning future<_Ty> struct promise_type { // `std::promise<T>` promise < _Ty > _MyPromise ; // Resumable function can return `std::future<T>`... future < _Ty > get_return_object () { return ( _MyPromise . get_future ()); } // if `false`, we skip the initial suspend point. bool initial_suspend () const { return ( false ); } // if `false`, we skip the final suspend point. bool final_suspend () const { return ( false ); } // Pass the value through `std::promise<T>` template < class _Ut > void return_value ( _Ut && _Value ) { _MyPromise . set_value ( _STD forward < _Ut > ( _Value )); } // Pass the exception through `std::promise<T>` void set_exception ( exception_ptr _Exc ) { _MyPromise . set_exception ( _STD move ( _Exc )); } }; // struct promise_type }; // coroutine_traits<T, Args...> // ... } // namespace std::experimental #endif When MSVC meets co_await / co_yield / co_return , it applies coroutine_traits to enable compile-time check. Let's see the fibonacci example again. It will show what MSVC does. The code might be wrong. I will update it as I find correct mechanism. #include <experimental/generator> using namespace std ; using namespace std :: experimental ; // Make a generator for `N` fibonacci numbers auto fibonacci ( int n ) noexcept -> std :: experimental :: generator < int > { using return_type = generator < int > ; // At this point, compiler will generate code // and check `return_type` fulfills promise requirement. using traits = coroutine_traite < return_type > ; // Requirement : OK. // We can generate unique frame type for this function. // Possible frame for fibonacci function struct __frame { // `_Resumable_frame_prefix` Frame_Prefix _prefix ; // Resumable Promise Requirement // fibonacci returns `generator<int>` generator < int >:: promise_type _promise ; // Captured arguments int _n ; // fibonacci(n); int _f1 , _f2 ; // Local variable int _i , _f3 ; // Temporaries // Platform dependent storage // for registers, etc. }; // We are forwarding arguments to frame! // Let's call it context(ctx) __frame * ctx = new __frame { std :: move ( n )}; // Generate return objet // In this case, `generator<int>` return_type __return = ctx -> _promise . get_return_object (); // if true, suspend. // if false, keep move... if ( ctx -> _promise . initial_suspend () ){ // always true // suspend... __initial_suspend_point : } // User code : use variables in frame(ctx)... // ---- ---- ---- ---- ---- { ctx -> _f1 = 0 ; ctx -> _f2 = 1 ; for ( ctx -> _i = 0 ; ctx -> _i < ctx -> _n ; ctx -> _i ++ ) { // Pass value through promise // co_yield f1; ctx -> _promise . yield_value ( ctx -> _f1 ); // instructions for suspension with `ctx->_prefix`... // co_await suspend_always{}; __suspend_resume_point_1 : // Calculate next fibo and shift ctx -> _f3 = ctx -> _f1 + ctx -> _f2 ; ctx -> _f1 = ctx -> _f2 ; ctx -> _f2 = ctx -> _f3 ; } // co_return; ctx -> _promise . set_result (); goto __final_suspend_point ; } // ---- ---- ---- ---- ---- if ( ctx -> _promise . final_suspend () ){ // always true // suspend... __final_suspend_point : } // Instructions for clean up... } So we could find out that compiler do a lot of job instead of us. And using frame pointer ctx is not that different from this pointer for memeber functions. Therefore, the cost for frame-based code will be negligible. co_yield : co_await + p.yield_value(x) co_return : p.set_result(x) + goto final_suspend;","title":"Coroutine Traits"},{"location":"articles/exploring-msvc-coroutine/#section-summary","text":"We covered co_return and co_yield with generator<T> example. Generator was a combination of iterator and resumable function. Resumable functions use coroutine_handle , which is basically raw pointer to function frame and some operations that rely on compiler intrinsics. The mechanism for frame-based approach was pretty similar to this pointer approach. For compile-time(static) assertion, coroutine_traits<T> is used. It enforce the return type to support promise_type that fulfills resumable promise requirement. And there was a specialization especially for std::future<T> .","title":"Section Summary"},{"location":"articles/exploring-msvc-coroutine/#the-awaitable-concept","text":"operator co_await = Syntactic Sugar + Resumable Function The last core of resumable function is co_await . It is unary operator. In this semantics, await is synonym of suspend . And because of suspension, its return value becomes asynchronous . This is the important point for our mental model. You may thought async & await of C# language, The difference in C++ world is that we can manage them manually , with our code and compiler support.","title":"The Awaitable Concept"},{"location":"articles/exploring-msvc-coroutine/#example_2","text":"The code is sample from MSVC blog. #include <iostream> #include <chrono> #include <future> #include <windows.h> // Windows Threadpool API using namespace std ; using namespace std :: literals ; // operator overload. // co_await can't use primitive type parameter. auto operator co_await ( chrono :: system_clock :: duration duration ) { using namespace std :: experimental ; // Awaitable must implements 3 function. // - bool await_ready(); // - auto await_suspend(); // - T await_resume(); class awaiter { static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Callback Thread will resume the function coroutine_handle <>:: from_address ( Context ). resume (); } PTP_TIMER timer = nullptr ; chrono :: system_clock :: duration duration ; public : explicit awaiter ( chrono :: system_clock :: duration d ) : duration ( d ) {} ~ awaiter () { if ( timer ) CloseThreadpoolTimer ( timer ); } // If not ready (`false`), invoke `await_suspend` // If ready (`true`), go to `await_resume` directly. bool await_ready () const { return duration . count () <= 0 ; } // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , resume_cb . address (), nullptr ); // Set the timer and then suspend... SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // Return T type's value after resumed. // T can be `void`. void await_resume () {} }; return awaiter { duration }; } // Resumable Function future < void > test () { cout << this_thread :: get_id () << \": sleeping\u2026 \\n \" ; // await for 1 millisecond... co_await 1 ms ; cout << this_thread :: get_id () << \": woke up \\n \" ; } // This is normal subroutine void usecase () { test (). get (); cout << this_thread :: get_id () << \": back in main \\n \" ; } It's flow is like the figure.","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#awaitable-interface","text":"co_await requires some interface for its operation. As we can see in code above, Awaitable interface should implement at least 3 functions. await_ready await_suspend await_resume It can be both member and normal function. future<T> also implements this interface. so future can be an argument for co_await . But just like the code await_suspend , it can be inefficient. For user-defined type, simple overload is enough. // <future> namespace std { template < class _Ty > bool await_ready ( future < _Ty >& _Fut ) { return ( _Fut . _Is_ready ()); } template < class _Ty > void await_suspend ( future < _Ty >& _Fut , experimental :: coroutine_handle <> _ResumeCb ) { // change to .then when future gets .then thread _WaitingThread ( [ & _Fut , _ResumeCb ]{ _Fut . wait (); _ResumeCb (); }); _WaitingThread . detach (); } template < class _Ty > auto await_resume ( future < _Ty >& _Fut ) { return ( _Fut . get ()); } } // namespace std How about compiler's view? How does it change our code?","title":"Awaitable Interface"},{"location":"articles/exploring-msvc-coroutine/#compilers-view_1","text":"operator co_await = Syntactic Sugar + Resumable Function I explained that co_await is syntatic sugar. If operator's argument type implements awaitable concept appropriately, the code will be modified by compiler. Revisiting previous example, test function which awaits for 1 millisecond, let's see how it works... // Before... // ---- ---- ---- ---- ---- future < void > test () { // ... co_await 1 ms ; // ... } // After... // ---- ---- ---- ---- ---- // With `co_await` keyword in function body, // compiler will make this function to resumable. future < void > test () { // Compiler-generated coroutine frame... __frame * context ; // ... // Awaitable type implements awaitable interface. // Precisely, this will be temporary variable in frame. awaiter aw = operator co_await ( 1 ms ); // Do we have expected value now? // If not, suspend. // If ready, skip the suspend and resume directly. if ( aw . await_ready () == false ) // await_ready(aw); { // Wrap the function frame to `coroutine_handle` type coroutine_handle <> resume_cb = coroutine_handle <>:: from_address ( context ); aw . await_suspend ( resume_cb ); // some instructions.... __suspend_resume_point_1 : // Since resume point is in this scope, // there won't be suspension if ready()==true. } // If await_resume has return type... // auto value = aw.await_resume(); aw . await_resume (); // await_resume(aw); // ... } So there are some points for each of interface functions. await_ready : \"Do we have return value now?\" await_ready makes the branch. It asks value for await_resume is ready. If not, the control flows into the scope of if statement. If it's ready, await_ready returns true and await_resume will be invoked directly. Compiler can optimize the code if it returns false always. In the case, we don't need suspension and therefore frame wrapping becomes unnecessary. The coroutine will become normal subroutine after optimization steps. In suspension scope, we must ready for suspension. Since coroutine_handle<> is just a raw pointer to frame, we can wrap it easily with static function coroutine_handle<>::from_address . await_suspend : \"The routine will suspend soon. Do what you have to do!\" await_suspend receives coroutine_handle<> for its argument. With this function, we can interleave our code for suspension handling. // The example code set the Windows Thread Pool Timer // and forward frame's address as callback argument. class awaiter { // Return might be ignored. bool await_suspend ( coroutine_handle <> resume_cb ) { int64_t relative_count = - duration . count (); timer = CreateThreadpoolTimer ( TimerCallback , // Unwrap the handle resume_cb . address (), nullptr ); SetThreadpoolTimer ( timer , ( PFILETIME ) & relative_count , 0 , 0 ); return timer != 0 ; } // A thread in Windows Thread Pool will invoke this callback. // And it will be resumer for the function. static void CALLBACK TimerCallback ( PTP_CALLBACK_INSTANCE , void * Context , PTP_TIMER ) { // Wrap the frame to handle again. And resume. coroutine_handle <>:: from_address ( Context ). resume (); } } await_resume : \"Now, here is the return value and control flow\" Suspend/resume point is created for resume operation. When the coroutine handle's .resume() is invoked, the function will set the context(frame pointer) and jump to it. The flow then exits the scope and call await_resume . Notice that we did suspend because the value wasn't ready( await_ready ). When the function is resumed, there should be return value. If await_resume 's return type is void, it means control flow is back.","title":"Compiler's View"},{"location":"articles/exploring-msvc-coroutine/#co_await-tricks","text":"Kenny Kerr and James Mcnellis introduced several tricks with this mechanism. I strongly recommend you to watch the video. CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\"","title":"co_await Tricks"},{"location":"articles/exploring-msvc-coroutine/#async-generator","text":"","title":"Async Generator"},{"location":"articles/exploring-msvc-coroutine/#concept_2","text":"Async Generator = Awaitable iterator + Resumable function This is similar to Generator's concept, but it has awaitable iterator . In other words, we can use for co_await statement for it. Kirkshoop will give you clear explanation for this.","title":"Concept"},{"location":"articles/exploring-msvc-coroutine/#example_3","text":"I won't write hard example since I hadn't try this feature. But previous examples and explanations will help your understanding. // Infinite sequence of interger. async_generator < int > infinite () { for ( int i = 0 ;; ++ i ) { co_yield i ; } } std :: future < void > usecase () { // for co_await statement for co_await ( int v : infinite ()) { // do something with `v`... } } I sad iterator is awaitable. So real code of usecase will be like following. std :: future < void > usecase () { // generator with awaitable(async) iterator async_generator < int > gen = infinite (); for ( auto iter = co_await gen . begin (); // `co_await` + `begin()` iter != gen . end (); // `end()` has nullptr co_await ++ iter ) // `co_await` + `operator++()` { int v = * iter ; // ... } } The only difference form generator<T> example is that the function is awaiting iterator at 2 points. begin() and operator++() . These are points for resume operation. Here, value type is primitive type int . So there won't be complex code here. The following code shows how to make awaitable iterator. The other code for generator body and promise_type is exactly same with std::experimental::generator<T> // Actually, generator is not async. Its iterator is async(awaitable). template < typename T > struct async_generator { struct promise_type ; // Same with experimental generator // We will implement awaitable interface... struct iterator : std :: iterator < input_iterator_tag , T > { coroutine_handle < promise_type > chp = nullptr ; // ... iterator operator ++ ( int ) = delete ; iterator & operator ++ (); // ... T const * operator -> () const ; T const & operator * () const { // promise_type has constant pointer to value const promise_type & prom = chp . promise (); return * prom . pvalue ; } // ... // Since this is syntactic example, there is no suspension. bool await_ready () const { return true ; } // With no suspension, there is nothing to do with handle. void await_suspend ( coroutine_handle <> hcoro ) {} // Return awaitable iterator at resume point iterator await_resume () const { return * this ; } }; // iterator }; // async_generator By adding 3 member functions for iterator , we could make it awaitable and became available to use for co_await statement. But as I mentioned at Awaitable Interface section, you don't have to add member function. using iter_type = async_generator < int >:: iterator ; bool await_ready ( iter_type ) { return true ; } void await_suspend ( iter_type & iter , coroutine_handle <> hcoro ) { // do for suspension... } iter_type & await_resume ( iter_type & it ) { return it ; // forward the reference } Adding these helper functions for old types will work fine.","title":"Example"},{"location":"articles/exploring-msvc-coroutine/#conclusion","text":"So, we have traveled MSVC coroutine from concept to code. That's all. I wish I made helpful description. I'd like to add disassembly experience about this feature, but I can't make it because I'm a beginner for that ability. I will try that topic later. I couldn't make this article in more detail. Maybe there could be a chance to update this...! :D","title":"Conclusion"},{"location":"articles/russian-roulette-kor/","text":"Russian Roulette and C++ Coroutines English \uc774\ubc88\uc5d0\ub294 \uc5ec\ub7ec \ucf54\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc5d0 \uc9d1\uc911\ud558\uace0 \uc774\ub4e4\uc758 \uc9c4\ud589\uc744 \ud558\ub098\uc758 \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uc218\ud589\ud558\ub294 \ucf54\ub4dc\ub97c \ud558\ub098 \uc791\uc131\ud574\ubcf4\uace0\uc790 \ud569\ub2c8\ub2e4. \uc608\uc2dc\ub85c\ub294 \uad49\uc7a5\ud788 \uc720\uba85\ud55c \uaddc\uce59\uc744 \uac00\uc9c4 \ub7ec\uc2dc\uc548 \ub8f0\ub81b\uacfc \uadf8 \uac8c\uc784\uc758 \ucc38\uac00\uc790\ub4e4\uc744 \uc0ac\uc6a9\ud574 \ubd24\uc2b5\ub2c8\ub2e4. \ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 1: \uc57d\uc2e4/\ubc29\uc544\uc1e0 \uc6b0\uc120 \ub9ac\ubcfc\ubc84\ub97c \ub9cc\ub4dc\ub294 \uac83\ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \ucc38\uac00 \uc778\uc6d0\uc774 \uc5bc\ub9c8\ub098 \uc788\uc744\uc9c0 \ubaa8\ub974\uae30 \ub54c\ubb38\uc5d0, uint32_t \ub97c \uc0ac\uc6a9\ud574 \ucda9\ubd84\ud788 \ub9ce\uc740 \uc57d\uc2e4(chamber)\uc744 \uc900\ube44\ud560 \uac81\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \uc784\uc758\uc758 \uc57d\uc2e4\uc744 \uc120\ud0dd\ud558\ub294 select_chamber \ub97c \uc544\ub798\uc640 \uac19\uc774 \uc815\uc758\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } \uacbd\uc6b0\uc5d0 \ub530\ub77c\uc11c\ub294 \uc778\uc790\ub97c \ubc1b\uc544 \uc0c1\ud669\uc5d0 \ub530\ub77c \uc57d\uc2e4\uc744 \uc120\ud0dd\ud560\uc9c0 \ubaa8\ub974\uc9c0\ub9cc, \uc774 \uc608\uc2dc\uc5d0\uc11c\ub294 \uac00\uc7a5 \ub2e8\uc21c\ud55c \ubc29\ubc95(\ubb34\uc791\uc704)\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc57d\uc2e4\uc774 \uc788\uc73c\ub2c8 \uc774\uc81c \ubc29\uc544\uc1e0(trigger)\ub97c \uc900\ube44\ud574\uc57c\uaca0\uad70\uc694. \ubc29\uc544\uc1e0\ub294 \ub2f9\uae38( pull ) \uc218 \uc788\uc73c\uba70, \ud604\uc7ac \uacf5\uc774\uac00 \ub9de\ubb3c\ub9b0 \uc57d\uc2e4( current )\uacfc \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud574\uc11c \uc54c\uace0 \uc788\uc2b5\ub2c8\ub2e4. \ud55c\ubc88 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uba74 \uc57d\uc2e4\uc774 \ud68c\uc804\ud560\ud14c\ub2c8, \uc5ec\uae30\uc11c\ub294 \uac04\ub2e8\ud788 chamber_t \uc758 \uac12\uc744 1 \uac10\uc18c \uc2dc\ud0a4\ub294 \uac83\uc73c\ub85c \uc57d\uc2e4\uc744 \ud68c\uc804\uc2dc\ud0a4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... }; \ucc38\uac00\uc790 \ud589\ub3d9 \uc815\uc758\ud558\uae30 \uc5ec\uae30\uc11c \ubc29\uc544\uc1e0\ub294 Awaitable \ud0c0\uc785\uc73c\ub85c \uc815\uc758\ud574\uc11c, \uac8c\uc784 \ucc38\uac00\uc790\ub4e4\uc774 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae34 \ud6c4 \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\ub3c4\ub85d \ub9cc\ub4e4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; \uc774\ub807\uac8c \uc815\uc758\ud55c \uc774\uc720\ub294 \ucc38\uac00\uc790(player)\ub4e4\uc774 3\uac00\uc9c0 \uc0c1\ud0dc\ub97c \uac00\uc9c0\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4. \ubc29\uc544\uc1e0\ub97c \ub2f9\uacbc\uc9c0\ub9cc, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc9c0 \uc54a\uc558\ub2e4 (\uc0b4\uc558\ub2e4!) \ubc29\uc544\uc1e0\ub97c \ub2f9\uaca8\uc11c, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc5c8\ub2e4 (X\ub97c \ub20c\ub7ec \uc870\uc758\ub97c \ud45c\ud558\uc2ed\uc2dc\uc624.) \ucc28\ub840\ub97c \uae30\ub2e4\ub9ac\ub358 \uc911 \ub2e4\ub978 \uc0ac\ub78c\uc774 \uc774\ubbf8 \ucd1d\uc54c\uc744 \ubc1b\uc558\ub2e4 \ucf54\ub4dc\ub85c \ud45c\ud604\ud558\uc790\uba74 \uc544\ub798\uc640 \uac19\uc2b5\ub2c8\ub2e4. index \ub97c \uc0ac\uc6a9\ud574 \uac01 player \ub4e4\uc744 \uad6c\ubd84\ud558\uace0, \ucf54\ub8e8\ud2f4 \uc678\ubd80\uc5d0 \uc704\uce58\ud55c fired (\ubd88\uc774\uc57c!)\uc758 \uac12\uc744 \ubcc0\uacbd\ud558\ub294 \ubc29\ubc95\uc73c\ub85c \ucd1d\uc54c\uc774 \ubc1c\uc0ac\ub418\uc5c8\uc744 \ub54c \ub2e4\ub978 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \uc774\ub97c \ud655\uc778\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. \ubaa8\ub450\uac00 \uac19\uc740 \ub9ac\ubcfc\ubc84\uc758 \ubc29\uc544\uc1e0\ub97c \uc0ac\uc6a9\ud558\ubbc0\ub85c, trigger \ub294 \ucc38\uc870\ub97c \uc0ac\uc6a9\ud558\uc600\uc2b5\ub2c8\ub2e4. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } \uc774\ub807\uac8c \ud558\uba74 \uc2e4\uc81c\ub85c\ub294 \ubaa8\ub4e0 \ucc38\uac00\uc790 \ucf54\ub8e8\ud2f4\ub4e4\uc740 \ubc29\uc544\uc1e0\ub97c \ubbf8\ub9ac \ub2f9\uaca8\ub193\uace0 \uae30\ub2e4\ub9ac\uac8c(suspend) \ub429\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \ubc29\uc544\uc1e0\ub97c \ud55c\ubc88\uc529 \ub2f9\uae30\uba74\uc11c \ucc28\ub840\ub300\ub85c \uae68\uc6cc\ubcf4\ub294(resume) \uac83\uc774\uc8e0. \ucc28\ub840\uac00 \ub418\uba74(resumed) trigger_t \uc740 await_resume \uc758 \ubc18\ud658\uac12\uc744 \ud1b5\ud574 \uacb0\uacfc( fired )\ub97c \uc804\ub2ec\ud560 \uac83\uc774\uace0 \uadf8 \uac12\uc5d0 \ub530\ub77c\uc11c player \uc758 \ub3d9\uc791\uc774 \ub2ec\ub77c\uc9c0\uac8c \ub429\ub2c8\ub2e4. \ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 2 \uc774\uc81c \ub9ac\ubcfc\ubc84\ub97c \ub9c8\uc800 \uc644\uc131\ud558\uace0, user_behavior_t \uc5d0 \ub300\ud574 \uc124\uba85\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc774\ubbf8 \uc704\uc5d0\uc11c trigger_t \ub97c \uc815\uc758 \ud588\uc73c\ubbc0\ub85c, revolver_t \ub294 1\uac1c\uc758 \ubc29\uc544\uc1e0\uc640 \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud55c \uc815\ubcf4\ub97c \uac00\uc9c0\uace0 \uc788\uc5b4\uc57c \ud569\ub2c8\ub2e4. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; \ubb3c\ub860 \ub204\uad70\uac00\ub294 \ub2f9\ucca8 \ub418\uc5b4\uc57c \ud558\uae30 \ub54c\ubb38\uc5d0, \ubaa8\ub4c8\ub85c \uc5f0\uc0b0\uc744 \ud558\ub294 \uac83\ub3c4 \uc78a\uc9c0 \uc54a\uc558\uc2b5\ub2c8\ub2e4. \uac8c\uc784 \uc9c4\ud589\uacfc\uc815 \uc774\uc81c \ucc38\uac00\uc790\uc640 \ub3c4\uad6c(\ub9ac\ubcfc\ubc84)\uac00 \ubaa8\ub450 \uc815\uc758\ub418\uc5c8\uc73c\ub2c8, \uac8c\uc784 \uc9c4\ud589\uacfc\uc815\uc744 \ud45c\ud604\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \uc774 \uac8c\uc784\uc5d0\uc11c\ub294 \ucd1d 6\uba85\uc758 \ucc38\uac00\uc790\uac00 \uc788\ub2e4\uace0 \uac00\uc815\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } \ucc38\uac00\uc790\uc640 \ub3c4\uad6c\uac00 \uc900\ube44\ub418\uba74, russian_roulette \uc744 \ud638\ucd9c\ud558\uc5ec \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. GSL(C++ \ud575\uc2ec \uac00\uc774\ub4dc\ub77c\uc778 \uc9c0\uc6d0 \ub77c\uc774\ube0c\ub7ec\ub9ac)\uc5d0 \uc775\uc219\ud558\uc9c0 \uc54a\uc73c\uc2dc\ub354\ub77c\ub3c4 \uc77d\ub294\ub370 \ubb38\uc81c\ub294 \uc5c6\uc744 \uac83\uc785\ub2c8\ub2e4. \ubaa8\ub974\ub294 \ubd84\ub4e4\uc744 \uc704\ud574 \uc124\uba85\ud558\uc790\uba74, gsl::span \uc740 \ubc94\uc704\ub97c \ud45c\ud604\ud558\uc5ec range- for \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uac8c \ud574\uc8fc\uace0, gsl::finally \ub294 \uac1c\uccb4\uac00 \uc18c\uba78\ud558\ub294 \uc2dc\uc810\uc5d0 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uae30\ub2a5\uc744 \ud569\ub2c8\ub2e4. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } \ubaa8\ub4e0 player \ub4e4\uc774 fired \uc640 revolver \ub97c \uacf5\uc720\ud558\uba70 \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. \uc774\ub4e4\uc758 \ud589\ub3d9\uc740 \ucf54\ub8e8\ud2f4\uc73c\ub85c \uc815\uc758\ud558\uc600\uc2b5\ub2c8\ub2e4. \ucc38\uac00\uc790\ub4e4\uc758 \uc218\uc640 \ubb34\uad00\ud558\uac8c, russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc740 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uac00 \ub418\uc5b4 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \ucc28\ub840\ub300\ub85c \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uac8c \ub9cc\ub4e4\uac83\uc785\ub2c8\ub2e4. \uc774\ub294 task.resume() \uc744 \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9d1\ub2c8\ub2e4. \uac8c\uc784\uc740 fired \uac00 true \uac00 \ub420 \ub54c\uae4c\uc9c0 \uacc4\uc18d\ub429\ub2c8\ub2e4. \uac8c\uc784\uc774 \ub05d\ub098\uba74 on_finish \uac1c\uccb4\uac00 \ubaa8\ub4e0 \ucc38\uac00\uc790\ub4e4\uc774 \uc0ac\uc6a9\ud55c \uba54\ubaa8\ub9ac(\ucf54\ub8e8\ud2f4 \ud504\ub808\uc784)\ub97c \ud68c\uc218\ud560 \uac83\uc785\ub2c8\ub2e4. \uac04\ub2e8\ud788 frame.destroy() \ud558\ub294 \uac83\uc73c\ub85c \uc774\ub97c \ucc98\ub9ac\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. Player \ucf54\ub8e8\ud2f4\uc744 \uc704\ud55c \ubc18\ud658 \ud0c0\uc785 C++ 20 Coroutines\uc5d0\uc11c \ucf54\ub8e8\ud2f4\uc744 \uc815\uc758\ud558\ub824\uba74, Coroutine Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294 \ubc18\ud658 \ud0c0\uc785\uc744 \uac00\uc838\uc57c \ud569\ub2c8\ub2e4. \uc774 \uc870\uac74\uc5d0 \ub9de\ucdb0\uc11c user_behavior_t \ub97c \uc815\uc758\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. Promise\uc5d0 \ub300\ud55c \uc0c1\uc138\ud55c \uc124\uba85\uc740 Lewiss Baker\uac00 \ub2e4\ub8ec \ubc14 \uc788\uc2b5\ub2c8\ub2e4 . \ud55c\uae00 \uc790\ub8cc\ub294 C++ Korea 5\ud68c \uc138\ubbf8\ub098\uc758 \ubc1c\ud45c\uc790\ub8cc \ub97c \ucc38\uace0\ud574\uc8fc\uc2dc\uae38 \ubc14\ub78d\ub2c8\ub2e4. \uc6b0\uc120 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc744 \uad00\ub9ac\ud558\ub294 user_behavior_t::promise_type \uc744 \uc815\uc758\ud574\uc57c \ud569\ub2c8\ub2e4. \uc5c4\ubc00\ud558\uac8c\ub294 coroutine_traits<user_behavior_t, ...>::promise_type \uc774\uc9c0\ub9cc, \uc5ec\uae30\uc11c\ub294 \uac00\uc7a5 \uac04\ub2e8\ud55c \ubc29\ubc95\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; \uac01 \ud568\uc218\ub4e4\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 \uc5ed\ud560\uc744 \ud569\ub2c8\ub2e4. initial_suspend : \ucf54\ub8e8\ud2f4\uc774 \ud638\ucd9c(invoke)\ub418\uc5b4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc774 \uc0dd\uc131\ub41c \uc9c1\ud6c4 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 final_suspend : \ucf54\ub8e8\ud2f4\uc774 \ubc18\ud658( co_return )\ub41c \uc774\ud6c4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 unhandled_exception : \ucf54\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ucc98\ub9ac\ub418\uc9c0 \ubabb\ud55c Exception\uc774 \ubc1c\uc0dd\ud560\ub54c \ud638\ucd9c suspend_always \ud0c0\uc785 \uac1c\uccb4\ub97c \ubc18\ud658\ud558\ub294 \ud589\uc704\ub294 \ub2e8\uc21c\ud788 \ud604\uc7ac \ucf54\ub8e8\ud2f4\uc744 \uc911\ub2e8\ud558\uaca0\ub2e4\ub294 \uc758\ubbf8\uc785\ub2c8\ub2e4. \ub9cc\uc57d \uc911\ub2e8\ud558\uc9c0 \uc54a\uace0 \ubc14\ub85c \uc9c4\ud589\ud55c\ub2e4\uba74 suspend_never \ub97c \ubc18\ud658\ud558\uba74 \ub429\ub2c8\ub2e4. \uc704\uc5d0\uc11c \uc791\uc131\ud55c \uc608\uc2dc\uc5d0\uc11c player \ucf54\ub8e8\ud2f4\ub4e4\uc758 \uc9c4\ud589(suspend, resume) \uc5ec\ubd80\ub294 \ubaa8\ub450 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uc778 russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uad00\ub9ac\ud558\ubbc0\ub85c \ub450 \uacbd\uc6b0 \ubaa8\ub450 suspend_always \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. Player \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc811\uadfc user_behavior_t::promise_type \ub294 promise_manual_control \ub97c \uc0c1\uc18d\ubc1b\uc73c\uba74\uc11c, 2\uac00\uc9c0 \uba64\ubc84 \ud568\uc218\ub97c \uc815\uc758\ud569\ub2c8\ub2e4. return_void : co_return \uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4 get_return_object : \ucf54\ub8e8\ud2f4\uc758 \ubc18\ud658\ud0c0\uc785\uc744 \uc0dd\uc131\ud560 \uc218 \uc788\ub3c4\ub85d \uc784\uc758\uc758 \uac1c\uccb4\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4. \uc774 \uacbd\uc6b0\ub294 user_behavior_t \ub97c \ubc14\ub85c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; user_behavior_t \ub294 coroutine_handle<void> \ub97c \uc0c1\uc18d \ubc1b\uc544 resume , done , destroy \uc640 \uac19\uc774 \ucf54\ub8e8\ud2f4\uc744 \uc81c\uc5b4\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. \uc774\ub97c \uc704\ud574\uc11c\ub294 promise_type \uc73c\ub85c\ubd80\ud130 coroutine_handle<void> \ub97c \uc5bb\uc744 \ubc29\ubc95\uc774 \ud544\uc694\ud55c\ub370, \uc774\ub294 coroutine_handle<promise_type> \uc744 \uc0ac\uc6a9\ud558\uc5ec \ud574\uacb0\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc81c\uc5b4\ub294 russian_roulette \uc5d0\uc11c \uc9c1\uc811 \uc774\ub8e8\uc5b4\uc9c0\ubbc0\ub85c \uc9c0\uae08\uacfc \uac19\uc740 \ucf54\ub4dc\ub85c\ub3c4 \ubb38\uc81c\uac00 \uc5c6\uc2b5\ub2c8\ub2e4. \ud558\uc9c0\ub9cc coroutine_handle<void> \ub294 \ub9c8\uce58 void* \ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0, \ubd80\uc8fc\uc758\ud55c \uc2e4\uc218\ub97c \uc608\ubc29\ud558\ub824\uba74 \ubcf5\uc0ac/\uc774\ub3d9 \uc0dd\uc131\uc790, \ubcf5\uc0ac/\uc774\ub3d9 \ub300\uc785 \uc5f0\uc0b0\uc790, \uc18c\uba78\uc790\ub97c \ucd94\uac00\ub85c \uc815\uc758\ud574\uc57c \ud560 \uac83\uc785\ub2c8\ub2e4. \uacb0\ub860 All-in-one \ucf54\ub4dc\ub294 Compiler Explorer\uc5d0\uc11c \uc2e4\ud589\ud574\ubcfc \uc218 \uc788\uc2b5\ub2c8\ub2e4. https://github.com/Naios/continuable \ucc98\ub7fc future<T> \ub97c \ub354 \ud3b8\ub9ac\ud558\uac8c \uc0ac\uc6a9\ud558\uae30 \uc704\ud574 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560\uc218\ub3c4 \uc788\uc9c0\ub9cc, \uc774\ub294 \ud55c\uac00\uc9c0 \ubc29\ubc95\uc77c \ubfd0\uc785\ub2c8\ub2e4. \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc911\ub2e8 \uc9c0\uc810\uc5d0 \ub300\ud55c \uc815\ubcf4(index)\uac00 \uc788\uae30 \ub54c\ubb38\uc5d0 \uad6c\ud604\ub808\ubca8\uc5d0\uc11c\ub294 \uc0c1\ud0dc \ud328\ud134\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ub2e4\ub9cc \ucc28\uc774\uc810\uc774 \uc788\ub2e4\uba74 \uc0c1\ud0dc \ud328\ud134\uc774 \ucd94\uac00\uc801\uc778 \ud0c0\uc785\uc744 \uc791\uc131\ud574\uc57c \ud558\uc9c0\ub9cc, \ucf54\ub8e8\ud2f4\uc5d0\uc11c\ub294 \uc911\ub2e8(suspend)\uacfc \uc7ac\uac1c(resume)\ub97c \uc790\uc5f0\uc2a4\ub7fd\uac8c \uae30\uc220\ud558\ub294\ub370 \uc880 \ub354 \ucd08\uc810\uc744 \ub458 \uc218 \uc788\uc8e0. \uc774\ub294 \uc911\ub2e8\uacfc \uc7ac\uac1c\ud558\ub294 \uacfc\uc815\uc774 \ucf54\ub4dc\uc758 \uad6c\uc870\uc5d0 \uc601\ud5a5\uc744 \uc8fc\ub294 \uc77c\uc774 \uc904\uc5b4\ub4e0\ub2e4\uace0 \uc694\uc57d\ud560 \uc218 \uc788\uaca0\uc2b5\ub2c8\ub2e4.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette-kor/#russian-roulette-and-c-coroutines","text":"English \uc774\ubc88\uc5d0\ub294 \uc5ec\ub7ec \ucf54\ub8e8\ud2f4\uc740 \ub3d9\uc791\uc5d0 \uc9d1\uc911\ud558\uace0 \uc774\ub4e4\uc758 \uc9c4\ud589\uc744 \ud558\ub098\uc758 \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uc218\ud589\ud558\ub294 \ucf54\ub4dc\ub97c \ud558\ub098 \uc791\uc131\ud574\ubcf4\uace0\uc790 \ud569\ub2c8\ub2e4. \uc608\uc2dc\ub85c\ub294 \uad49\uc7a5\ud788 \uc720\uba85\ud55c \uaddc\uce59\uc744 \uac00\uc9c4 \ub7ec\uc2dc\uc548 \ub8f0\ub81b\uacfc \uadf8 \uac8c\uc784\uc758 \ucc38\uac00\uc790\ub4e4\uc744 \uc0ac\uc6a9\ud574 \ubd24\uc2b5\ub2c8\ub2e4.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette-kor/#1","text":"\uc6b0\uc120 \ub9ac\ubcfc\ubc84\ub97c \ub9cc\ub4dc\ub294 \uac83\ubd80\ud130 \uc2dc\uc791\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \ucc38\uac00 \uc778\uc6d0\uc774 \uc5bc\ub9c8\ub098 \uc788\uc744\uc9c0 \ubaa8\ub974\uae30 \ub54c\ubb38\uc5d0, uint32_t \ub97c \uc0ac\uc6a9\ud574 \ucda9\ubd84\ud788 \ub9ce\uc740 \uc57d\uc2e4(chamber)\uc744 \uc900\ube44\ud560 \uac81\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \uc784\uc758\uc758 \uc57d\uc2e4\uc744 \uc120\ud0dd\ud558\ub294 select_chamber \ub97c \uc544\ub798\uc640 \uac19\uc774 \uc815\uc758\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } \uacbd\uc6b0\uc5d0 \ub530\ub77c\uc11c\ub294 \uc778\uc790\ub97c \ubc1b\uc544 \uc0c1\ud669\uc5d0 \ub530\ub77c \uc57d\uc2e4\uc744 \uc120\ud0dd\ud560\uc9c0 \ubaa8\ub974\uc9c0\ub9cc, \uc774 \uc608\uc2dc\uc5d0\uc11c\ub294 \uac00\uc7a5 \ub2e8\uc21c\ud55c \ubc29\ubc95(\ubb34\uc791\uc704)\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc57d\uc2e4\uc774 \uc788\uc73c\ub2c8 \uc774\uc81c \ubc29\uc544\uc1e0(trigger)\ub97c \uc900\ube44\ud574\uc57c\uaca0\uad70\uc694. \ubc29\uc544\uc1e0\ub294 \ub2f9\uae38( pull ) \uc218 \uc788\uc73c\uba70, \ud604\uc7ac \uacf5\uc774\uac00 \ub9de\ubb3c\ub9b0 \uc57d\uc2e4( current )\uacfc \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud574\uc11c \uc54c\uace0 \uc788\uc2b5\ub2c8\ub2e4. \ud55c\ubc88 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uba74 \uc57d\uc2e4\uc774 \ud68c\uc804\ud560\ud14c\ub2c8, \uc5ec\uae30\uc11c\ub294 \uac04\ub2e8\ud788 chamber_t \uc758 \uac12\uc744 1 \uac10\uc18c \uc2dc\ud0a4\ub294 \uac83\uc73c\ub85c \uc57d\uc2e4\uc744 \ud68c\uc804\uc2dc\ud0a4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... };","title":"\ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 1: \uc57d\uc2e4/\ubc29\uc544\uc1e0"},{"location":"articles/russian-roulette-kor/#_1","text":"\uc5ec\uae30\uc11c \ubc29\uc544\uc1e0\ub294 Awaitable \ud0c0\uc785\uc73c\ub85c \uc815\uc758\ud574\uc11c, \uac8c\uc784 \ucc38\uac00\uc790\ub4e4\uc774 \ubc29\uc544\uc1e0\ub97c \ub2f9\uae34 \ud6c4 \uacb0\uacfc\ub97c \uae30\ub2e4\ub9ac\ub3c4\ub85d \ub9cc\ub4e4\uaca0\uc2b5\ub2c8\ub2e4. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; \uc774\ub807\uac8c \uc815\uc758\ud55c \uc774\uc720\ub294 \ucc38\uac00\uc790(player)\ub4e4\uc774 3\uac00\uc9c0 \uc0c1\ud0dc\ub97c \uac00\uc9c0\uae30 \ub54c\ubb38\uc785\ub2c8\ub2e4. \ubc29\uc544\uc1e0\ub97c \ub2f9\uacbc\uc9c0\ub9cc, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc9c0 \uc54a\uc558\ub2e4 (\uc0b4\uc558\ub2e4!) \ubc29\uc544\uc1e0\ub97c \ub2f9\uaca8\uc11c, \ucd1d\uc774 \ubc1c\uc0ac\ub418\uc5c8\ub2e4 (X\ub97c \ub20c\ub7ec \uc870\uc758\ub97c \ud45c\ud558\uc2ed\uc2dc\uc624.) \ucc28\ub840\ub97c \uae30\ub2e4\ub9ac\ub358 \uc911 \ub2e4\ub978 \uc0ac\ub78c\uc774 \uc774\ubbf8 \ucd1d\uc54c\uc744 \ubc1b\uc558\ub2e4 \ucf54\ub4dc\ub85c \ud45c\ud604\ud558\uc790\uba74 \uc544\ub798\uc640 \uac19\uc2b5\ub2c8\ub2e4. index \ub97c \uc0ac\uc6a9\ud574 \uac01 player \ub4e4\uc744 \uad6c\ubd84\ud558\uace0, \ucf54\ub8e8\ud2f4 \uc678\ubd80\uc5d0 \uc704\uce58\ud55c fired (\ubd88\uc774\uc57c!)\uc758 \uac12\uc744 \ubcc0\uacbd\ud558\ub294 \ubc29\ubc95\uc73c\ub85c \ucd1d\uc54c\uc774 \ubc1c\uc0ac\ub418\uc5c8\uc744 \ub54c \ub2e4\ub978 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \uc774\ub97c \ud655\uc778\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uaca0\uc2b5\ub2c8\ub2e4. \ubaa8\ub450\uac00 \uac19\uc740 \ub9ac\ubcfc\ubc84\uc758 \ubc29\uc544\uc1e0\ub97c \uc0ac\uc6a9\ud558\ubbc0\ub85c, trigger \ub294 \ucc38\uc870\ub97c \uc0ac\uc6a9\ud558\uc600\uc2b5\ub2c8\ub2e4. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } \uc774\ub807\uac8c \ud558\uba74 \uc2e4\uc81c\ub85c\ub294 \ubaa8\ub4e0 \ucc38\uac00\uc790 \ucf54\ub8e8\ud2f4\ub4e4\uc740 \ubc29\uc544\uc1e0\ub97c \ubbf8\ub9ac \ub2f9\uaca8\ub193\uace0 \uae30\ub2e4\ub9ac\uac8c(suspend) \ub429\ub2c8\ub2e4. \uadf8\ub9ac\uace0 \ubc29\uc544\uc1e0\ub97c \ud55c\ubc88\uc529 \ub2f9\uae30\uba74\uc11c \ucc28\ub840\ub300\ub85c \uae68\uc6cc\ubcf4\ub294(resume) \uac83\uc774\uc8e0. \ucc28\ub840\uac00 \ub418\uba74(resumed) trigger_t \uc740 await_resume \uc758 \ubc18\ud658\uac12\uc744 \ud1b5\ud574 \uacb0\uacfc( fired )\ub97c \uc804\ub2ec\ud560 \uac83\uc774\uace0 \uadf8 \uac12\uc5d0 \ub530\ub77c\uc11c player \uc758 \ub3d9\uc791\uc774 \ub2ec\ub77c\uc9c0\uac8c \ub429\ub2c8\ub2e4.","title":"\ucc38\uac00\uc790 \ud589\ub3d9 \uc815\uc758\ud558\uae30"},{"location":"articles/russian-roulette-kor/#2","text":"\uc774\uc81c \ub9ac\ubcfc\ubc84\ub97c \ub9c8\uc800 \uc644\uc131\ud558\uace0, user_behavior_t \uc5d0 \ub300\ud574 \uc124\uba85\ud558\uaca0\uc2b5\ub2c8\ub2e4. \uc774\ubbf8 \uc704\uc5d0\uc11c trigger_t \ub97c \uc815\uc758 \ud588\uc73c\ubbc0\ub85c, revolver_t \ub294 1\uac1c\uc758 \ubc29\uc544\uc1e0\uc640 \uc7a5\uc804\ub41c \uc57d\uc2e4( loaded )\uc5d0 \ub300\ud55c \uc815\ubcf4\ub97c \uac00\uc9c0\uace0 \uc788\uc5b4\uc57c \ud569\ub2c8\ub2e4. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; \ubb3c\ub860 \ub204\uad70\uac00\ub294 \ub2f9\ucca8 \ub418\uc5b4\uc57c \ud558\uae30 \ub54c\ubb38\uc5d0, \ubaa8\ub4c8\ub85c \uc5f0\uc0b0\uc744 \ud558\ub294 \uac83\ub3c4 \uc78a\uc9c0 \uc54a\uc558\uc2b5\ub2c8\ub2e4.","title":"\ub9ac\ubcfc\ubc84 \uc900\ube44\ud558\uae30 2"},{"location":"articles/russian-roulette-kor/#_2","text":"\uc774\uc81c \ucc38\uac00\uc790\uc640 \ub3c4\uad6c(\ub9ac\ubcfc\ubc84)\uac00 \ubaa8\ub450 \uc815\uc758\ub418\uc5c8\uc73c\ub2c8, \uac8c\uc784 \uc9c4\ud589\uacfc\uc815\uc744 \ud45c\ud604\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. \uc774 \uac8c\uc784\uc5d0\uc11c\ub294 \ucd1d 6\uba85\uc758 \ucc38\uac00\uc790\uac00 \uc788\ub2e4\uace0 \uac00\uc815\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } \ucc38\uac00\uc790\uc640 \ub3c4\uad6c\uac00 \uc900\ube44\ub418\uba74, russian_roulette \uc744 \ud638\ucd9c\ud558\uc5ec \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. GSL(C++ \ud575\uc2ec \uac00\uc774\ub4dc\ub77c\uc778 \uc9c0\uc6d0 \ub77c\uc774\ube0c\ub7ec\ub9ac)\uc5d0 \uc775\uc219\ud558\uc9c0 \uc54a\uc73c\uc2dc\ub354\ub77c\ub3c4 \uc77d\ub294\ub370 \ubb38\uc81c\ub294 \uc5c6\uc744 \uac83\uc785\ub2c8\ub2e4. \ubaa8\ub974\ub294 \ubd84\ub4e4\uc744 \uc704\ud574 \uc124\uba85\ud558\uc790\uba74, gsl::span \uc740 \ubc94\uc704\ub97c \ud45c\ud604\ud558\uc5ec range- for \uad6c\ubb38\uc744 \uc0ac\uc6a9\ud560 \uc218 \uc788\uac8c \ud574\uc8fc\uace0, gsl::finally \ub294 \uac1c\uccb4\uac00 \uc18c\uba78\ud558\ub294 \uc2dc\uc810\uc5d0 \ud568\uc218\ub97c \ud638\ucd9c\ud558\ub294 \uae30\ub2a5\uc744 \ud569\ub2c8\ub2e4. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } \ubaa8\ub4e0 player \ub4e4\uc774 fired \uc640 revolver \ub97c \uacf5\uc720\ud558\uba70 \uac8c\uc784\uc744 \uc2dc\uc791\ud569\ub2c8\ub2e4. \uc774\ub4e4\uc758 \ud589\ub3d9\uc740 \ucf54\ub8e8\ud2f4\uc73c\ub85c \uc815\uc758\ud558\uc600\uc2b5\ub2c8\ub2e4. \ucc38\uac00\uc790\ub4e4\uc758 \uc218\uc640 \ubb34\uad00\ud558\uac8c, russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc740 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uac00 \ub418\uc5b4 \ucf54\ub8e8\ud2f4\ub4e4\uc774 \ucc28\ub840\ub300\ub85c \ubc29\uc544\uc1e0\ub97c \ub2f9\uae30\uac8c \ub9cc\ub4e4\uac83\uc785\ub2c8\ub2e4. \uc774\ub294 task.resume() \uc744 \ud1b5\ud574\uc11c \uc774\ub8e8\uc5b4\uc9d1\ub2c8\ub2e4. \uac8c\uc784\uc740 fired \uac00 true \uac00 \ub420 \ub54c\uae4c\uc9c0 \uacc4\uc18d\ub429\ub2c8\ub2e4. \uac8c\uc784\uc774 \ub05d\ub098\uba74 on_finish \uac1c\uccb4\uac00 \ubaa8\ub4e0 \ucc38\uac00\uc790\ub4e4\uc774 \uc0ac\uc6a9\ud55c \uba54\ubaa8\ub9ac(\ucf54\ub8e8\ud2f4 \ud504\ub808\uc784)\ub97c \ud68c\uc218\ud560 \uac83\uc785\ub2c8\ub2e4. \uac04\ub2e8\ud788 frame.destroy() \ud558\ub294 \uac83\uc73c\ub85c \uc774\ub97c \ucc98\ub9ac\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.","title":"\uac8c\uc784 \uc9c4\ud589\uacfc\uc815"},{"location":"articles/russian-roulette-kor/#player","text":"C++ 20 Coroutines\uc5d0\uc11c \ucf54\ub8e8\ud2f4\uc744 \uc815\uc758\ud558\ub824\uba74, Coroutine Promise Requirement\ub97c \ub9cc\uc871\ud558\ub294 \ubc18\ud658 \ud0c0\uc785\uc744 \uac00\uc838\uc57c \ud569\ub2c8\ub2e4. \uc774 \uc870\uac74\uc5d0 \ub9de\ucdb0\uc11c user_behavior_t \ub97c \uc815\uc758\ud574\ubcf4\uaca0\uc2b5\ub2c8\ub2e4. Promise\uc5d0 \ub300\ud55c \uc0c1\uc138\ud55c \uc124\uba85\uc740 Lewiss Baker\uac00 \ub2e4\ub8ec \ubc14 \uc788\uc2b5\ub2c8\ub2e4 . \ud55c\uae00 \uc790\ub8cc\ub294 C++ Korea 5\ud68c \uc138\ubbf8\ub098\uc758 \ubc1c\ud45c\uc790\ub8cc \ub97c \ucc38\uace0\ud574\uc8fc\uc2dc\uae38 \ubc14\ub78d\ub2c8\ub2e4. \uc6b0\uc120 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc744 \uad00\ub9ac\ud558\ub294 user_behavior_t::promise_type \uc744 \uc815\uc758\ud574\uc57c \ud569\ub2c8\ub2e4. \uc5c4\ubc00\ud558\uac8c\ub294 coroutine_traits<user_behavior_t, ...>::promise_type \uc774\uc9c0\ub9cc, \uc5ec\uae30\uc11c\ub294 \uac00\uc7a5 \uac04\ub2e8\ud55c \ubc29\ubc95\uc744 \uc0ac\uc6a9\ud558\uaca0\uc2b5\ub2c8\ub2e4. #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; \uac01 \ud568\uc218\ub4e4\uc740 \ub2e4\uc74c\uacfc \uac19\uc740 \uc5ed\ud560\uc744 \ud569\ub2c8\ub2e4. initial_suspend : \ucf54\ub8e8\ud2f4\uc774 \ud638\ucd9c(invoke)\ub418\uc5b4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \ud504\ub808\uc784\uc774 \uc0dd\uc131\ub41c \uc9c1\ud6c4 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 final_suspend : \ucf54\ub8e8\ud2f4\uc774 \ubc18\ud658( co_return )\ub41c \uc774\ud6c4 \ud574\ub2f9 \ucf54\ub8e8\ud2f4\uc758 \uc911\ub2e8 \uc5ec\ubd80\ub97c \uacb0\uc815 unhandled_exception : \ucf54\ub8e8\ud2f4 \ub0b4\uc5d0\uc11c \ucc98\ub9ac\ub418\uc9c0 \ubabb\ud55c Exception\uc774 \ubc1c\uc0dd\ud560\ub54c \ud638\ucd9c suspend_always \ud0c0\uc785 \uac1c\uccb4\ub97c \ubc18\ud658\ud558\ub294 \ud589\uc704\ub294 \ub2e8\uc21c\ud788 \ud604\uc7ac \ucf54\ub8e8\ud2f4\uc744 \uc911\ub2e8\ud558\uaca0\ub2e4\ub294 \uc758\ubbf8\uc785\ub2c8\ub2e4. \ub9cc\uc57d \uc911\ub2e8\ud558\uc9c0 \uc54a\uace0 \ubc14\ub85c \uc9c4\ud589\ud55c\ub2e4\uba74 suspend_never \ub97c \ubc18\ud658\ud558\uba74 \ub429\ub2c8\ub2e4. \uc704\uc5d0\uc11c \uc791\uc131\ud55c \uc608\uc2dc\uc5d0\uc11c player \ucf54\ub8e8\ud2f4\ub4e4\uc758 \uc9c4\ud589(suspend, resume) \uc5ec\ubd80\ub294 \ubaa8\ub450 \uac8c\uc784\uc758 \uc9c4\ud589\uc790\uc778 russian_roulette \uc11c\ube0c\ub8e8\ud2f4\uc5d0\uc11c \uad00\ub9ac\ud558\ubbc0\ub85c \ub450 \uacbd\uc6b0 \ubaa8\ub450 suspend_always \ub97c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4.","title":"Player \ucf54\ub8e8\ud2f4\uc744 \uc704\ud55c \ubc18\ud658 \ud0c0\uc785"},{"location":"articles/russian-roulette-kor/#player_1","text":"user_behavior_t::promise_type \ub294 promise_manual_control \ub97c \uc0c1\uc18d\ubc1b\uc73c\uba74\uc11c, 2\uac00\uc9c0 \uba64\ubc84 \ud568\uc218\ub97c \uc815\uc758\ud569\ub2c8\ub2e4. return_void : co_return \uc744 \ucc98\ub9ac\ud569\ub2c8\ub2e4 get_return_object : \ucf54\ub8e8\ud2f4\uc758 \ubc18\ud658\ud0c0\uc785\uc744 \uc0dd\uc131\ud560 \uc218 \uc788\ub3c4\ub85d \uc784\uc758\uc758 \uac1c\uccb4\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4. \uc774 \uacbd\uc6b0\ub294 user_behavior_t \ub97c \ubc14\ub85c \ubc18\ud658\ud558\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; user_behavior_t \ub294 coroutine_handle<void> \ub97c \uc0c1\uc18d \ubc1b\uc544 resume , done , destroy \uc640 \uac19\uc774 \ucf54\ub8e8\ud2f4\uc744 \uc81c\uc5b4\ud560 \uc218 \uc788\ub3c4\ub85d \ud558\uc600\uc2b5\ub2c8\ub2e4. \uc774\ub97c \uc704\ud574\uc11c\ub294 promise_type \uc73c\ub85c\ubd80\ud130 coroutine_handle<void> \ub97c \uc5bb\uc744 \ubc29\ubc95\uc774 \ud544\uc694\ud55c\ub370, \uc774\ub294 coroutine_handle<promise_type> \uc744 \uc0ac\uc6a9\ud558\uc5ec \ud574\uacb0\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \uc81c\uc5b4\ub294 russian_roulette \uc5d0\uc11c \uc9c1\uc811 \uc774\ub8e8\uc5b4\uc9c0\ubbc0\ub85c \uc9c0\uae08\uacfc \uac19\uc740 \ucf54\ub4dc\ub85c\ub3c4 \ubb38\uc81c\uac00 \uc5c6\uc2b5\ub2c8\ub2e4. \ud558\uc9c0\ub9cc coroutine_handle<void> \ub294 \ub9c8\uce58 void* \ucc98\ub7fc \uc0ac\uc6a9\ud560 \uc218 \uc788\uae30 \ub54c\ubb38\uc5d0, \ubd80\uc8fc\uc758\ud55c \uc2e4\uc218\ub97c \uc608\ubc29\ud558\ub824\uba74 \ubcf5\uc0ac/\uc774\ub3d9 \uc0dd\uc131\uc790, \ubcf5\uc0ac/\uc774\ub3d9 \ub300\uc785 \uc5f0\uc0b0\uc790, \uc18c\uba78\uc790\ub97c \ucd94\uac00\ub85c \uc815\uc758\ud574\uc57c \ud560 \uac83\uc785\ub2c8\ub2e4.","title":"Player \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784\uc5d0 \ub300\ud55c \uc811\uadfc"},{"location":"articles/russian-roulette-kor/#_3","text":"All-in-one \ucf54\ub4dc\ub294 Compiler Explorer\uc5d0\uc11c \uc2e4\ud589\ud574\ubcfc \uc218 \uc788\uc2b5\ub2c8\ub2e4. https://github.com/Naios/continuable \ucc98\ub7fc future<T> \ub97c \ub354 \ud3b8\ub9ac\ud558\uac8c \uc0ac\uc6a9\ud558\uae30 \uc704\ud574 \ucf54\ub8e8\ud2f4\uc744 \uc0ac\uc6a9\ud560\uc218\ub3c4 \uc788\uc9c0\ub9cc, \uc774\ub294 \ud55c\uac00\uc9c0 \ubc29\ubc95\uc77c \ubfd0\uc785\ub2c8\ub2e4. \ucf54\ub8e8\ud2f4 \ud504\ub808\uc784 \uc548\uc5d0 \uc911\ub2e8 \uc9c0\uc810\uc5d0 \ub300\ud55c \uc815\ubcf4(index)\uac00 \uc788\uae30 \ub54c\ubb38\uc5d0 \uad6c\ud604\ub808\ubca8\uc5d0\uc11c\ub294 \uc0c1\ud0dc \ud328\ud134\uacfc \ud06c\uac8c \ub2e4\ub974\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. \ub2e4\ub9cc \ucc28\uc774\uc810\uc774 \uc788\ub2e4\uba74 \uc0c1\ud0dc \ud328\ud134\uc774 \ucd94\uac00\uc801\uc778 \ud0c0\uc785\uc744 \uc791\uc131\ud574\uc57c \ud558\uc9c0\ub9cc, \ucf54\ub8e8\ud2f4\uc5d0\uc11c\ub294 \uc911\ub2e8(suspend)\uacfc \uc7ac\uac1c(resume)\ub97c \uc790\uc5f0\uc2a4\ub7fd\uac8c \uae30\uc220\ud558\ub294\ub370 \uc880 \ub354 \ucd08\uc810\uc744 \ub458 \uc218 \uc788\uc8e0. \uc774\ub294 \uc911\ub2e8\uacfc \uc7ac\uac1c\ud558\ub294 \uacfc\uc815\uc774 \ucf54\ub4dc\uc758 \uad6c\uc870\uc5d0 \uc601\ud5a5\uc744 \uc8fc\ub294 \uc77c\uc774 \uc904\uc5b4\ub4e0\ub2e4\uace0 \uc694\uc57d\ud560 \uc218 \uc788\uaca0\uc2b5\ub2c8\ub2e4.","title":"\uacb0\ub860"},{"location":"articles/russian-roulette/","text":"Russian Roulette and C++ Coroutines \ud55c\uad6d\uc5b4 In this post, I'd like to show an example which separates definition of a behavior and its execution. For the example, the Russian Roulette is used. Following its famous rule, the players' behavior are defined using the coroutine and a game with those players will written be written in an ordinary subroutine. Making a revolver 1: Chamber/Trigger Let's start with makeing a revolver. Since we don't know how many players are going to join, uint32_t will be used to define the value space for the chamber. And we need an additional function, select_chamber , to select one chamber value. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } This is indeed the most simple implementation. It might be more complex for the real case, but let's use it anyway. We need a trigger now. Of course it can be pull ed, and it knows which chamber is loaded and which chamber is going to be fired for the moment( current ). After pull operation, simply decreasing 1 from the chamber_t 's value. Remind that we are going to use a revolver! // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... }; Defining the players' behavior In addition to that, let's make the trigger to an awaitable type. So all players can wait for the bullet after pulling it. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; By doing so, each player will be in one of the 3 state. Pulled the trigger, and not fired. (Alive!) Pulled the trigger, and fired. (Hold X to pay respect) Waiting for its turn, and another player received the bullet. In the 'code' form, it will be like the following. index is for distinguishing each player instance. fired should be non-local since the other player will monitor its value. Also trigger is passed by reference because all players share 1 revolver. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } What a short function! Remind that trigger_t is an awaitable type. So each player will suspend immediately after pulling the trigger. After all players become suspended, then we will resume them one by one. When a player is resumed, it will check the return value of the await_resume and notify the resule( fired ) by storing the result. Of course the player behavior branches with it. Making a revolver 2 Let me explain about the user_behavior_t after finishing the definition of the revolver and the game. 1 revolver owns 1 trigger. The point will be expressed through the implementation inheritance. In addition to that, revolver_t must be aware of the loaded chamber. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; Because someone must win the prize, we didn't forget to apply modular arithmetic. Progress of the game Now it's time to define a execution of the game. I already told you it's an ordinay subroutine. Assume that we have 6 players for 1 game. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } The game, russian_roulette is invoked with the resources. You may not aware of the the GSL(C++ Core G uideline S upport L ibrary), but don't take it so hard. gsl::span is a pair of the pointer and length to support range- for statement, gsl::finally invokes a given funcion object in its destuction phase. Here, by using it we can guarantee clean up of the coroutine frame. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } Like I said all player s share fired variable and revolver instance. Their behavior is defined using the coroutine. russian_roulette subroutine becomes the moderator of the game with the control flow. It's task is to continue this turn-based game by resuming each player coroutine. When they are resumed through task.resume() first time, they will pull the trigger and suspend again. The game continues (by resume) until fired becomes true . When there is a victim, the subroutine will return and on_finish object will destroy all players' coroutine frame. Simply using frame.destroy() will do the work. Return type for the player coroutine In C++ 20 Coroutines, the return type of the coroutine must fulfill the Coroutine Promise Requirement. user_behavior_t is such kind of the type. You can see the Lewiss Baker's post about it The first thing we have to do is to define user_behavior_t::promise_type which manages the coroutine frame. We can use coroutine_traits<user_behavior_t, ...>::promise_type to do the work, but let's go through the easy way :) #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; Each function's role is like the following. initial_suspend : Decide whether to suspend after the coroutine functions is invoked. At this moment the coroutine's frame is allocated. final_suspend : Decide whether to suspend after the coroutine function is returned( co_return ). unhandled_exception : Invoked when an exception is thrown in the coroutine function's body Returning suspend_always type means that the coroutine is willing to suspend for the defined moment. If you don't want to suspend and continue the flow, you should return suspend_never . For this example, player coroutine's creation, progress(suspend/resume), destruction is fully managed by the subroutine russian_roulette . So we will return suspend_always type and forget about the other concerns. Exposing the player coroutine's frame user_behavior_t::promise_type inherits promise_manual_control and add 2 funtion to meet the requirement. return_void : invoked just after co_return get_return_object : the function's return becomes the return type of the coroutine function. Here, we will return user_behavior_t directly. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; The inheritance is public . So it exposes those member functions which controls the coroutine. ( resume , done , and destroy ) After its base class construction, coroutine_handle<void> is in the empty state. Here, I used the simplest way to translate promise_type to its matching coroutine_handle<void> . You can see that from_promise of the coroutine_handle<promise_type> is doing the work. Unless we trust the execution manager, russian_roulette , such exposure won't matter. Remind that coroutine_handle<void> follows the semantics of void* . So if you want to prevent some mistakes for future extenstion, you had better define or delete copy/move functions and its destructor. Conclusion You can run the all-in-one code with the Compiler Explorer. Like https://github.com/Naios/continuable, C++ Coroutines can be used like a sugar for the future<T> . But that's the not only usage. Since the coroutine frame contains an index to distinguish its suspension points, we can't tell it is totaly different from the state pattern. We need to define awaitable type and the return types for our logic, but by doing so the point of suspension and continuation can be written more naturally. For my perspective this gives more resilience to the code.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette/#russian-roulette-and-c-coroutines","text":"\ud55c\uad6d\uc5b4 In this post, I'd like to show an example which separates definition of a behavior and its execution. For the example, the Russian Roulette is used. Following its famous rule, the players' behavior are defined using the coroutine and a game with those players will written be written in an ordinary subroutine.","title":"Russian Roulette and C++ Coroutines"},{"location":"articles/russian-roulette/#making-a-revolver-1-chambertrigger","text":"Let's start with makeing a revolver. Since we don't know how many players are going to join, uint32_t will be used to define the value space for the chamber. And we need an additional function, select_chamber , to select one chamber value. #include <random> // for this example, // chamber_t is the indices of the revolver's chambers using chamber_t = uint32_t ; auto select_chamber () -> chamber_t { std :: random_device device {}; std :: mt19937_64 gen { device ()}; return static_cast < chamber_t > ( gen ()); } This is indeed the most simple implementation. It might be more complex for the real case, but let's use it anyway. We need a trigger now. Of course it can be pull ed, and it knows which chamber is loaded and which chamber is going to be fired for the moment( current ). After pull operation, simply decreasing 1 from the chamber_t 's value. Remind that we are going to use a revolver! // trigger fires the bullet class trigger_t { protected : const chamber_t & loaded ; chamber_t current ; public : trigger_t ( const chamber_t & _loaded , chamber_t _current ) : loaded { _loaded }, current { _current } { } private : bool pull () { // pull the trigger. is it the bad case? return -- current == loaded ; } // ... };","title":"Making a revolver 1: Chamber/Trigger"},{"location":"articles/russian-roulette/#defining-the-players-behavior","text":"In addition to that, let's make the trigger to an awaitable type. So all players can wait for the bullet after pulling it. // trigger fires the bullet // all players will 'wait' for it class trigger_t { // ... public : bool await_ready () { return false ; } void await_suspend ( coroutine_handle < void > ) { } bool await_resume () { return pull (); } }; By doing so, each player will be in one of the 3 state. Pulled the trigger, and not fired. (Alive!) Pulled the trigger, and fired. (Hold X to pay respect) Waiting for its turn, and another player received the bullet. In the 'code' form, it will be like the following. index is for distinguishing each player instance. fired should be non-local since the other player will monitor its value. Also trigger is passed by reference because all players share 1 revolver. // this player will ... // 1. be bypassed // (fired = false; then return) // 2. receive the bullet // (fired = true; then return) // 3. be skipped because of the other player became a victim // (destroyed when it is suspended - no output) auto player ( gsl :: index id , bool & fired , trigger_t & trigger ) -> user_behavior_t { // bang ! fired = co_await trigger ; fired ? printf ( \"player %zu dead :( \\n \" , id ) : printf ( \"player %zu alive :) \\n \" , id ); } What a short function! Remind that trigger_t is an awaitable type. So each player will suspend immediately after pulling the trigger. After all players become suspended, then we will resume them one by one. When a player is resumed, it will check the return value of the await_resume and notify the resule( fired ) by storing the result. Of course the player behavior branches with it.","title":"Defining the players' behavior"},{"location":"articles/russian-roulette/#making-a-revolver-2","text":"Let me explain about the user_behavior_t after finishing the definition of the revolver and the game. 1 revolver owns 1 trigger. The point will be expressed through the implementation inheritance. In addition to that, revolver_t must be aware of the loaded chamber. // revolver knows which is the loaded chamber class revolver_t : public trigger_t { const chamber_t loaded ; public : revolver_t ( chamber_t current , chamber_t num_player ) : trigger_t { loaded , num_player }, // loaded { current % num_player } { } }; Because someone must win the prize, we didn't forget to apply modular arithmetic.","title":"Making a revolver 2"},{"location":"articles/russian-roulette/#progress-of-the-game","text":"Now it's time to define a execution of the game. I already told you it's an ordinay subroutine. Assume that we have 6 players for 1 game. #include <array> int main ( int , char * []) { // select some chamber with the users array < user_behavior_t , 6 > users {}; revolver_t revolver { select_chamber (), static_cast < chamber_t > ( users . max_size ())}; russian_roulette ( revolver , users ); return EXIT_SUCCESS ; } The game, russian_roulette is invoked with the resources. You may not aware of the the GSL(C++ Core G uideline S upport L ibrary), but don't take it so hard. gsl::span is a pair of the pointer and length to support range- for statement, gsl::finally invokes a given funcion object in its destuction phase. Here, by using it we can guarantee clean up of the coroutine frame. #include <gsl/gsl> // the game will go on until the revolver fires its bullet auto russian_roulette ( revolver_t & revolver , gsl :: span < user_behavior_t > users ) { bool fired = false ; // spawn player coroutines with their id gsl :: index id {}; for ( auto & user : users ) user = player ( ++ id , fired , revolver ); // cleanup the game on return auto on_finish = gsl :: finally ([ users ] { for ( coroutine_handle < void >& frame : users ) frame . destroy (); }); // until there is a victim ... for ( id = 0u ; fired == false ; id = ( id + 1 ) % users . size ()) { // continue the users' behavior in round-robin manner coroutine_handle < void >& task = users [ id ]; if ( task . done () == false ) task . resume (); } } Like I said all player s share fired variable and revolver instance. Their behavior is defined using the coroutine. russian_roulette subroutine becomes the moderator of the game with the control flow. It's task is to continue this turn-based game by resuming each player coroutine. When they are resumed through task.resume() first time, they will pull the trigger and suspend again. The game continues (by resume) until fired becomes true . When there is a victim, the subroutine will return and on_finish object will destroy all players' coroutine frame. Simply using frame.destroy() will do the work.","title":"Progress of the game"},{"location":"articles/russian-roulette/#return-type-for-the-player-coroutine","text":"In C++ 20 Coroutines, the return type of the coroutine must fulfill the Coroutine Promise Requirement. user_behavior_t is such kind of the type. You can see the Lewiss Baker's post about it The first thing we have to do is to define user_behavior_t::promise_type which manages the coroutine frame. We can use coroutine_traits<user_behavior_t, ...>::promise_type to do the work, but let's go through the easy way :) #include <experimental/coroutine> using namespace std ; using namespace std :: experimental ; class promise_manual_control { public : auto initial_suspend () { return suspend_always {}; // suspend after invoke } auto final_suspend () { return suspend_always {}; // suspend after return } void unhandled_exception () { // this example never 'throw'. so nothing to do } }; Each function's role is like the following. initial_suspend : Decide whether to suspend after the coroutine functions is invoked. At this moment the coroutine's frame is allocated. final_suspend : Decide whether to suspend after the coroutine function is returned( co_return ). unhandled_exception : Invoked when an exception is thrown in the coroutine function's body Returning suspend_always type means that the coroutine is willing to suspend for the defined moment. If you don't want to suspend and continue the flow, you should return suspend_never . For this example, player coroutine's creation, progress(suspend/resume), destruction is fully managed by the subroutine russian_roulette . So we will return suspend_always type and forget about the other concerns.","title":"Return type for the player coroutine"},{"location":"articles/russian-roulette/#exposing-the-player-coroutines-frame","text":"user_behavior_t::promise_type inherits promise_manual_control and add 2 funtion to meet the requirement. return_void : invoked just after co_return get_return_object : the function's return becomes the return type of the coroutine function. Here, we will return user_behavior_t directly. // behavior will be defined as a coroutine class user_behavior_t : public coroutine_handle < void > { public : class promise_type : public promise_manual_control { public : void return_void () { } auto get_return_object () -> user_behavior_t { return { this }; } }; private : user_behavior_t ( promise_type * p ) : coroutine_handle < void > {} { coroutine_handle < void >& self = * this ; self = coroutine_handle < promise_type >:: from_promise ( * p ); } public : user_behavior_t () = default ; }; The inheritance is public . So it exposes those member functions which controls the coroutine. ( resume , done , and destroy ) After its base class construction, coroutine_handle<void> is in the empty state. Here, I used the simplest way to translate promise_type to its matching coroutine_handle<void> . You can see that from_promise of the coroutine_handle<promise_type> is doing the work. Unless we trust the execution manager, russian_roulette , such exposure won't matter. Remind that coroutine_handle<void> follows the semantics of void* . So if you want to prevent some mistakes for future extenstion, you had better define or delete copy/move functions and its destructor.","title":"Exposing the player coroutine's frame"},{"location":"articles/russian-roulette/#conclusion","text":"You can run the all-in-one code with the Compiler Explorer. Like https://github.com/Naios/continuable, C++ Coroutines can be used like a sugar for the future<T> . But that's the not only usage. Since the coroutine frame contains an index to distinguish its suspension points, we can't tell it is totaly different from the state pattern. We need to define awaitable type and the return types for our logic, but by doing so the point of suspension and continuation can be written more naturally. For my perspective this gives more resilience to the code.","title":"Conclusion"},{"location":"articles/windll-linking-issues/","text":"Work In Progress ... :o","title":"Windll linking issues"},{"location":"features/channel-overview/","text":"Overview: Coroutine based channel This is a simplified form of channel in The Go Language . Just like this library, several C++ coroutines libraries already has their own implementation of the concept. So it might be redundant to have another implementation in this repositoty, but this is one of the very first type I've wrote after the feature becomes available. Debugging its examples will help you to enhance understanding of the coroutine and which trick can be possible. See Also Go Channel types A Tour of Go: Channels CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" If you're first with the concept, I strongly recommend you to see the talk above even though I've implemented it in a different way. Example test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp Channel with a Lockable When channel<T> is used, which means that bypass_lock is used, channel doesn't care about the race condition (NOT MT-safe). Therefore, user have to provide an appropriate Lockable type and instance if it must be MT-safe As a result, the type doesn't support copy/move since typically those operations are unavailable for Lockable objects. namespace coro { // // The channel is a stream of values. // `channel<T>` isn't MT-safe (using `bypass_lock`). // template < typename T , typename M = bypass_lock > class channel ; // There are some helper types which implements the operations template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro Channel guarantees coverage of all reader/writer coroutines in its list. When a writer found its reader , or vice versa, it resumes the other's routine and then proceeds its flow. When reader can't be matched with a writer , it attaches itself in channel just before suspend . In the same way, writer attaches itself if it couldn't find reader . Template Parameters T : An element type to deliver between reader/writer coroutines M : Must be a BasicLockable type Default Operations As mentioned above, the type can't be copied/moved. template < typename T , typename M > class channel final { public : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; channel () noexcept ( false ); ~ channel () noexcept ( false ); // !!!! }; Notice that its destructor throws exception . In the destructor, the channel resumes its pending coroutines. The destructor throws if (and only if) one of the resumed coroutines throws an exception. Member Variables Since stackless coroutines are heap-allocated, it uses linked list to those coroutines without additional allocation. Member Description reader_list linked list of reader coroutines. writer_list linked list of writer coroutines. mtx mutex to provide delivery without race between reader/writer coroutines. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); using mutex_type = M ; private : mutex_type mtx {}; public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; Functions Function Description write create a writer object for the given channel read create a reader object for the given channel template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { public : // `writer` type implements the awaitable concept decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // `reader` type implements the awaitable concept decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"coroutine/channel.hpp"},{"location":"features/channel-overview/#overview-coroutine-based-channel","text":"This is a simplified form of channel in The Go Language . Just like this library, several C++ coroutines libraries already has their own implementation of the concept. So it might be redundant to have another implementation in this repositoty, but this is one of the very first type I've wrote after the feature becomes available. Debugging its examples will help you to enhance understanding of the coroutine and which trick can be possible.","title":"Overview: Coroutine based channel"},{"location":"features/channel-overview/#see-also","text":"Go Channel types A Tour of Go: Channels CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" If you're first with the concept, I strongly recommend you to see the talk above even though I've implemented it in a different way.","title":"See Also"},{"location":"features/channel-overview/#example","text":"test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp","title":"Example"},{"location":"features/channel-overview/#channel-with-a-lockable","text":"When channel<T> is used, which means that bypass_lock is used, channel doesn't care about the race condition (NOT MT-safe). Therefore, user have to provide an appropriate Lockable type and instance if it must be MT-safe As a result, the type doesn't support copy/move since typically those operations are unavailable for Lockable objects. namespace coro { // // The channel is a stream of values. // `channel<T>` isn't MT-safe (using `bypass_lock`). // template < typename T , typename M = bypass_lock > class channel ; // There are some helper types which implements the operations template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro Channel guarantees coverage of all reader/writer coroutines in its list. When a writer found its reader , or vice versa, it resumes the other's routine and then proceeds its flow. When reader can't be matched with a writer , it attaches itself in channel just before suspend . In the same way, writer attaches itself if it couldn't find reader .","title":"Channel with a Lockable"},{"location":"features/channel-overview/#template-parameters","text":"T : An element type to deliver between reader/writer coroutines M : Must be a BasicLockable type","title":"Template Parameters"},{"location":"features/channel-overview/#default-operations","text":"As mentioned above, the type can't be copied/moved. template < typename T , typename M > class channel final { public : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; channel () noexcept ( false ); ~ channel () noexcept ( false ); // !!!! }; Notice that its destructor throws exception . In the destructor, the channel resumes its pending coroutines. The destructor throws if (and only if) one of the resumed coroutines throws an exception.","title":"Default Operations"},{"location":"features/channel-overview/#member-variables","text":"Since stackless coroutines are heap-allocated, it uses linked list to those coroutines without additional allocation. Member Description reader_list linked list of reader coroutines. writer_list linked list of writer coroutines. mtx mutex to provide delivery without race between reader/writer coroutines. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); using mutex_type = M ; private : mutex_type mtx {}; public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Member Variables"},{"location":"features/channel-overview/#functions","text":"Function Description write create a writer object for the given channel read create a reader object for the given channel template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { public : // `writer` type implements the awaitable concept decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // `reader` type implements the awaitable concept decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Functions"},{"location":"features/channel-read_write/","text":"Current version uses helper types to use channel in a designed manner. The types implements awaitable interface that is required by co_await operator. namespace coro { template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro See Also Channel Concept Go Channel types CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" Example test/channel_read_write_mutex.cpp test/channel_write_read_mutex.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp Awaitable Channel Read Short Example using namespace coro ; template < typename T , typename M > auto read_from ( channel < T , M >& ch ) -> no_return { auto [ value , ok ] = co_await ch . read (); // you can use `std::tie` if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. } Type: reader<T, M> The type supports move operation, but it is unecessary in general. template < typename T , typename M > class reader final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ); auto await_resume () noexcept ( false ) -> std :: tuple < value_type , bool > ; }; Function Description await_ready Returns true if there is a waiting writer instance in the channel await_suspend Start waiting in the channel's reader list await_resume Resumes both writer and ifself when the read was successful. Returned tuple containes false if the channel is going to be destroyed(closed). Awaitable Channel Write Short Example using namespace coro ; template < typename T , typename M > auto write_to ( channel < T , M >& ch , T && value ) -> no_return { auto ok = co_await ch . write ( value ); // call by reference (T&) if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. } Type: writer<T, M> The type supports move operation, but it is unecessary in general. template < typename T , typename M > class writer final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > _rh ) noexcept ( false ); bool await_resume () noexcept ( false ); }; Function Description await_ready Returns true if there is a waiting reader instance in the channel await_suspend Start waiting in the channel's writer list await_resume Resumes both reader and ifself the write was successful. Return false if the channel is going to be destroyed(closed).","title":"read and write"},{"location":"features/channel-read_write/#see-also","text":"Channel Concept Go Channel types CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\"","title":"See Also"},{"location":"features/channel-read_write/#example","text":"test/channel_read_write_mutex.cpp test/channel_write_read_mutex.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp","title":"Example"},{"location":"features/channel-read_write/#awaitable-channel-read","text":"","title":"Awaitable Channel Read"},{"location":"features/channel-read_write/#short-example","text":"using namespace coro ; template < typename T , typename M > auto read_from ( channel < T , M >& ch ) -> no_return { auto [ value , ok ] = co_await ch . read (); // you can use `std::tie` if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. }","title":"Short Example"},{"location":"features/channel-read_write/#type-readerltt-mgt","text":"The type supports move operation, but it is unecessary in general. template < typename T , typename M > class reader final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ); auto await_resume () noexcept ( false ) -> std :: tuple < value_type , bool > ; }; Function Description await_ready Returns true if there is a waiting writer instance in the channel await_suspend Start waiting in the channel's reader list await_resume Resumes both writer and ifself when the read was successful. Returned tuple containes false if the channel is going to be destroyed(closed).","title":"Type: reader&lt;T, M&gt;"},{"location":"features/channel-read_write/#awaitable-channel-write","text":"","title":"Awaitable Channel Write"},{"location":"features/channel-read_write/#short-example_1","text":"using namespace coro ; template < typename T , typename M > auto write_to ( channel < T , M >& ch , T && value ) -> no_return { auto ok = co_await ch . write ( value ); // call by reference (T&) if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. }","title":"Short Example"},{"location":"features/channel-read_write/#type-writerltt-mgt","text":"The type supports move operation, but it is unecessary in general. template < typename T , typename M > class writer final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > _rh ) noexcept ( false ); bool await_resume () noexcept ( false ); }; Function Description await_ready Returns true if there is a waiting reader instance in the channel await_suspend Start waiting in the channel's writer list await_resume Resumes both reader and ifself the write was successful. Return false if the channel is going to be destroyed(closed).","title":"Type: writer&lt;T, M&gt;"},{"location":"features/channel-select/","text":"Current version uses helper types to use channel in a designed manner. namespace coro { template < typename T , typename M > class channel ; template < typename T , typename M > class peeker ; } // namespace coro See Also Channel Concept Channel Read/Write Example test/channel_select_bypass_empty.cpp test/channel_select_type_match.cpp test/channel_select_peek_all_cases.cpp Channel Non-blocking Select Short Example using namespace coro ; using u32_chan_t = channel < uint32_t > ; using i32_chan_t = channel < int32_t > ; TEST_METHOD ( channel_select_match_one ) { u32_chan_t ch1 {}; i32_chan_t ch2 {}; write_to ( ch1 , 17u ); select ( ch2 , // empty channel. bypass []( auto v ) { static_assert ( is_same_v < decltype ( v ), int32_t > ); Assert :: Fail ( L \"select on empty channel must bypass\" ); }, ch1 , // if the channel has a writer, peek and invoke callback []( auto v ) -> no_return { static_assert ( is_same_v < decltype ( v ), uint32_t > ); Assert :: IsTrue ( v == 17u ); co_await suspend_never {}; }); } Selecting a pair from arguments To support expression like above, select received a number of pairs of channel and functions. The functions can be a coroutine. However, their return object will be truncated. namespace coro { // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { // evaluate select ( ch , forward < FuncType &&> ( fn )); // try next pair return select ( forward < Args &&> ( args )...); } } // namespace coro For each pair, select test the channel and consume writer coroutines. namespace coro { // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } } // namespace coro Channel Peek Operation peeker<T, M> is quite simple. Function Description peek test the channel if there is a waiting writer coroutine. if so, fetch it. acquire return false if there was no writer. Move the value from writer coroutine to local storage. writer coroutine will be resumed. namespace coro { // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; } // namespace coro","title":"select on multiple channels"},{"location":"features/channel-select/#see-also","text":"Channel Concept Channel Read/Write","title":"See Also"},{"location":"features/channel-select/#example","text":"test/channel_select_bypass_empty.cpp test/channel_select_type_match.cpp test/channel_select_peek_all_cases.cpp","title":"Example"},{"location":"features/channel-select/#channel-non-blocking-select","text":"","title":"Channel Non-blocking Select"},{"location":"features/channel-select/#short-example","text":"using namespace coro ; using u32_chan_t = channel < uint32_t > ; using i32_chan_t = channel < int32_t > ; TEST_METHOD ( channel_select_match_one ) { u32_chan_t ch1 {}; i32_chan_t ch2 {}; write_to ( ch1 , 17u ); select ( ch2 , // empty channel. bypass []( auto v ) { static_assert ( is_same_v < decltype ( v ), int32_t > ); Assert :: Fail ( L \"select on empty channel must bypass\" ); }, ch1 , // if the channel has a writer, peek and invoke callback []( auto v ) -> no_return { static_assert ( is_same_v < decltype ( v ), uint32_t > ); Assert :: IsTrue ( v == 17u ); co_await suspend_never {}; }); }","title":"Short Example"},{"location":"features/channel-select/#selecting-a-pair-from-arguments","text":"To support expression like above, select received a number of pairs of channel and functions. The functions can be a coroutine. However, their return object will be truncated. namespace coro { // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { // evaluate select ( ch , forward < FuncType &&> ( fn )); // try next pair return select ( forward < Args &&> ( args )...); } } // namespace coro For each pair, select test the channel and consume writer coroutines. namespace coro { // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } } // namespace coro","title":"Selecting a pair from arguments"},{"location":"features/channel-select/#channel-peek-operation","text":"peeker<T, M> is quite simple. Function Description peek test the channel if there is a waiting writer coroutine. if so, fetch it. acquire return false if there was no writer. Move the value from writer coroutine to local storage. writer coroutine will be resumed. namespace coro { // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; } // namespace coro","title":"Channel Peek Operation"},{"location":"features/concrt-latch/","text":"See Also Go Language: sync.WaitGroup C++ Concurrency TS: Latch latch The type is used for synchronization in fork-join scenario. It will be removed when it C++ Concurrency TS becomes available. Visit the cppreference.com for the detailed explaination. Latch in this library has slightly different interface with that of the concurrency TS namespace concrt { // A temporary implementation of `std::experimental::latch` class latch final : no_copy_move { public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept = default ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; } // namespace concrt Definition (Windows) The implementation uses Win32 Event object and a counter using <atomic> . The win32_event here doesn't support co_await expression. namespace concrt { class latch { atomic_uint64_t ref {}; mutable win32_event ev {}; // ... }; } // namespace concrt Definiton (POSIX) The implementation uses pthread_cond_t and pthread_mutex_t . It checks spurious wake-up so it can wait without timeout like the concurrency TS. namespace concrt { class latch { atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; // ... }; } // namespace concrt Example Wait for multiple times Throws exception when counter becomes negative test/channel_race_no_leak.cpp test/net_echo_tcp.cpp","title":"Concrt latch"},{"location":"features/concrt-latch/#see-also","text":"Go Language: sync.WaitGroup C++ Concurrency TS: Latch","title":"See Also"},{"location":"features/concrt-latch/#latch","text":"The type is used for synchronization in fork-join scenario. It will be removed when it C++ Concurrency TS becomes available. Visit the cppreference.com for the detailed explaination. Latch in this library has slightly different interface with that of the concurrency TS namespace concrt { // A temporary implementation of `std::experimental::latch` class latch final : no_copy_move { public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept = default ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; } // namespace concrt","title":"latch"},{"location":"features/concrt-latch/#definition-windows","text":"The implementation uses Win32 Event object and a counter using <atomic> . The win32_event here doesn't support co_await expression. namespace concrt { class latch { atomic_uint64_t ref {}; mutable win32_event ev {}; // ... }; } // namespace concrt","title":"Definition (Windows)"},{"location":"features/concrt-latch/#definiton-posix","text":"The implementation uses pthread_cond_t and pthread_mutex_t . It checks spurious wake-up so it can wait without timeout like the concurrency TS. namespace concrt { class latch { atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; // ... }; } // namespace concrt","title":"Definiton (POSIX)"},{"location":"features/concrt-latch/#example","text":"Wait for multiple times Throws exception when counter becomes negative test/channel_race_no_leak.cpp test/net_echo_tcp.cpp","title":"Example"},{"location":"features/concrt-overview/","text":"#include <coroutine/concrt.h> using namespace concrt ; References C++ Reference: Extensions for concurrency Background When I requested for the explanation about the coroutine concept, I mostly start with notifing that the coroutine is irrelevent with the thread (see page 6) . What I explain is, in short: The coroutine is about the routine's design The thread is about the processor abstraction (CPU in general) Therefore, all program with the coroutine must be able to run on (only) 1 thread. Just notice that using a thread is an issue of the implementation, and using a C++ 20 coroutine is an issue of the design. Indeed you can use both together and they can work in harmony. What I want you to know here is that they have a different domain. Contents #include <coroutine/concrt.h> using namespace concrt ; There are 2 family. For Windows and for non-Windows. Shared section latch Windows ptp_work ptp_event Linux + Darwin (POSIX + System API) event and signaled_event_tasks TBA: implementation note for the Darwin","title":"Concrt overview"},{"location":"features/concrt-overview/#references","text":"C++ Reference: Extensions for concurrency","title":"References"},{"location":"features/concrt-overview/#background","text":"When I requested for the explanation about the coroutine concept, I mostly start with notifing that the coroutine is irrelevent with the thread (see page 6) . What I explain is, in short: The coroutine is about the routine's design The thread is about the processor abstraction (CPU in general) Therefore, all program with the coroutine must be able to run on (only) 1 thread. Just notice that using a thread is an issue of the implementation, and using a C++ 20 coroutine is an issue of the design. Indeed you can use both together and they can work in harmony. What I want you to know here is that they have a different domain.","title":"Background"},{"location":"features/concrt-overview/#contents","text":"#include <coroutine/concrt.h> using namespace concrt ; There are 2 family. For Windows and for non-Windows.","title":"Contents"},{"location":"features/concrt-overview/#shared","text":"section latch","title":"Shared"},{"location":"features/concrt-overview/#windows","text":"ptp_work ptp_event","title":"Windows"},{"location":"features/concrt-overview/#linux-darwin-posix-system-api","text":"event and signaled_event_tasks TBA: implementation note for the Darwin","title":"Linux + Darwin (POSIX + System API)"},{"location":"features/concrt-posix_event/","text":"","title":"Concrt posix event"},{"location":"features/concrt-ptp_event/","text":"Win32 Event Object + Coroutine See Also MSDN: Using Event Objects ptp_event Awaitable event with the Windows Thread Pool API. Allows mutliple usage with 1 instance. But only 1 co_await is possible each time. Example Wait until signal Cancel #include <coroutine/concrt.h> #include <coroutine/return.h> using namespace concrt ; using namespace coro ; auto wait_an_event ( ptp_event & wo , atomic_flag & flag ) -> no_return { // wait for set or cancel // `co_await` will forward `GetLastError` if canceled. if ( DWORD ec = co_await wo ) { FAIL_WITH_MESSAGE ( system_category (). message ( ec )); co_return ; } flag . test_and_set (); } auto ptp_event_set_test () { // Notice that the Event Object is managed separately. HANDLE ev = CreateEventEx ( nullptr , nullptr , // CREATE_EVENT_MANUAL_RESET , // EVENT_ALL_ACCESS ); auto on_return = gsl :: finally ([ ev ]() { CloseHandle ( ev ); }); ptp_event waitable { ev }; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_an_event ( waitable , flag ); SetEvent ( ev ); SleepEx ( 3 , true ); // give time to the waiting threas set the `flag` REQUIRE ( flag . test_and_set ()); } Definition modules/windows/concrt.cpp class ptp_event final : no_copy_move { HANDLE wo {}; private : // WAITORTIMERCALLBACK static void __stdcall wait_on_thread_pool ( PVOID , BOOLEAN ); public : explicit ptp_event ( HANDLE target ) noexcept ( false ); ~ ptp_event () noexcept ; void cancel () noexcept ; bool await_ready () noexcept ; void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ); uint32_t await_resume () noexcept ; }; Since it uses INFINITE wait, user must make sure one of SetEvent or cancel will happen on the object. Default Operations The type is not copyable and movable. Functions Function Description cancel Cancel the waiting ptp_event . The waiting coroutine will be resumed automatically by the Win32 thread. await_ready Always returns false ( suspend_always ) await_suspend Attach a background thread work to wait the SetEvent await_resume Unregister the wait operation so it can be used again.","title":"Win32 Event Object + Coroutine"},{"location":"features/concrt-ptp_event/#win32-event-object-coroutine","text":"","title":"Win32 Event Object + Coroutine"},{"location":"features/concrt-ptp_event/#see-also","text":"MSDN: Using Event Objects","title":"See Also"},{"location":"features/concrt-ptp_event/#ptp_event","text":"Awaitable event with the Windows Thread Pool API. Allows mutliple usage with 1 instance. But only 1 co_await is possible each time.","title":"ptp_event"},{"location":"features/concrt-ptp_event/#example","text":"Wait until signal Cancel #include <coroutine/concrt.h> #include <coroutine/return.h> using namespace concrt ; using namespace coro ; auto wait_an_event ( ptp_event & wo , atomic_flag & flag ) -> no_return { // wait for set or cancel // `co_await` will forward `GetLastError` if canceled. if ( DWORD ec = co_await wo ) { FAIL_WITH_MESSAGE ( system_category (). message ( ec )); co_return ; } flag . test_and_set (); } auto ptp_event_set_test () { // Notice that the Event Object is managed separately. HANDLE ev = CreateEventEx ( nullptr , nullptr , // CREATE_EVENT_MANUAL_RESET , // EVENT_ALL_ACCESS ); auto on_return = gsl :: finally ([ ev ]() { CloseHandle ( ev ); }); ptp_event waitable { ev }; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_an_event ( waitable , flag ); SetEvent ( ev ); SleepEx ( 3 , true ); // give time to the waiting threas set the `flag` REQUIRE ( flag . test_and_set ()); }","title":"Example"},{"location":"features/concrt-ptp_event/#definition","text":"modules/windows/concrt.cpp class ptp_event final : no_copy_move { HANDLE wo {}; private : // WAITORTIMERCALLBACK static void __stdcall wait_on_thread_pool ( PVOID , BOOLEAN ); public : explicit ptp_event ( HANDLE target ) noexcept ( false ); ~ ptp_event () noexcept ; void cancel () noexcept ; bool await_ready () noexcept ; void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ); uint32_t await_resume () noexcept ; }; Since it uses INFINITE wait, user must make sure one of SetEvent or cancel will happen on the object.","title":"Definition"},{"location":"features/concrt-ptp_event/#default-operations","text":"The type is not copyable and movable.","title":"Default Operations"},{"location":"features/concrt-ptp_event/#functions","text":"Function Description cancel Cancel the waiting ptp_event . The waiting coroutine will be resumed automatically by the Win32 thread. await_ready Always returns false ( suspend_always ) await_suspend Attach a background thread work to wait the SetEvent await_resume Unregister the wait operation so it can be used again.","title":"Functions"},{"location":"features/concrt-ptp_work/","text":"Win32 Thread Pool Work + Coroutine See Also CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Using the thread pool functions MSDN: CreateThreadpoolWork WandBox example: A function that selects its thread ptp_work Change current coroutine's execution thread to background thread in the windows thread pool. Example #include <coroutine/return.h> // for `no_return` #include <coroutine/concrt.h> using namespace coro ; // for `no_return` using namespace concrt ; // the example might fail because of the constant folding auto switch_to_background () -> no_return { auto before = GetCurrentThreadId (); co_await ptp_work {}; // resume on thread in the pool auto after = GetCurrentThreadId (); Assert :: IsTrue ( before != after ); } Like the example, it is recommended to use it as a temporary object. Definition modules/windows/concrt.cpp namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { static void __stdcall resume_on_thread_pool ( // PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; }; } // namepace concrt Default Operations The type doesn't require memory (0-byte size). And it is a regular type. Functions Function Description suspend send the given coroutine_handle<void> to background await_suspend coroutine code is generated in importing code. throws error if an error is occurred. namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = suspend ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; } // namepace concrt","title":"Win32 Thread Pool Work + Coroutine"},{"location":"features/concrt-ptp_work/#win32-thread-pool-work-coroutine","text":"","title":"Win32 Thread Pool Work + Coroutine"},{"location":"features/concrt-ptp_work/#see-also","text":"CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Using the thread pool functions MSDN: CreateThreadpoolWork WandBox example: A function that selects its thread","title":"See Also"},{"location":"features/concrt-ptp_work/#ptp_work","text":"Change current coroutine's execution thread to background thread in the windows thread pool.","title":"ptp_work"},{"location":"features/concrt-ptp_work/#example","text":"#include <coroutine/return.h> // for `no_return` #include <coroutine/concrt.h> using namespace coro ; // for `no_return` using namespace concrt ; // the example might fail because of the constant folding auto switch_to_background () -> no_return { auto before = GetCurrentThreadId (); co_await ptp_work {}; // resume on thread in the pool auto after = GetCurrentThreadId (); Assert :: IsTrue ( before != after ); } Like the example, it is recommended to use it as a temporary object.","title":"Example"},{"location":"features/concrt-ptp_work/#definition","text":"modules/windows/concrt.cpp namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { static void __stdcall resume_on_thread_pool ( // PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; }; } // namepace concrt","title":"Definition"},{"location":"features/concrt-ptp_work/#default-operations","text":"The type doesn't require memory (0-byte size). And it is a regular type.","title":"Default Operations"},{"location":"features/concrt-ptp_work/#functions","text":"Function Description suspend send the given coroutine_handle<void> to background await_suspend coroutine code is generated in importing code. throws error if an error is occurred. namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = suspend ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; } // namepace concrt","title":"Functions"},{"location":"features/concrt-section/","text":"See Also Concept: BasicLockable section : Critical Section A basic lockable type with System API. The type is not copyable and movable. The purpose of this type is to provide a thin wrapper to use a lockable type in this library's test codes . namespace concrt { class section final : no_copy_move { // ... public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt Definition (Windows) With Win32 API, It uses CRITICAL_SECTION instead of SRWLock . Even though SRWLock doesn't require deallocation and possibly good for performance reason, CRITICAL_SECTION is used since the type is for test code. namespace concrt { // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION , no_copy_move { // ... }; } // namepace concrt Definition (POSIX) With POSIX API, it uses pthread_rwlock_t . The type's existance is only for platform compatibility of test codes. The type was written with pthread_mutex_t to replace std::mutex in test code. The reason was that some test codes required different setting like PTHREAD_PRIO_NONE . namespace concrt { // Standard lockable with pthread reader writer lock class section final : no_copy_move { pthread_rwlock_t rwlock ; // ... }; } // namepace concrt Example #include <coroutine/concrt.h> using namespace concrt ; void perform_with_lock ( section & m ){ std :: lock_guard lck { m }; // do some work... } In this library: test/channel_race_no_leak.cpp","title":"Concrt section"},{"location":"features/concrt-section/#see-also","text":"Concept: BasicLockable","title":"See Also"},{"location":"features/concrt-section/#section-critical-section","text":"A basic lockable type with System API. The type is not copyable and movable. The purpose of this type is to provide a thin wrapper to use a lockable type in this library's test codes . namespace concrt { class section final : no_copy_move { // ... public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt","title":"section: Critical Section"},{"location":"features/concrt-section/#definition-windows","text":"With Win32 API, It uses CRITICAL_SECTION instead of SRWLock . Even though SRWLock doesn't require deallocation and possibly good for performance reason, CRITICAL_SECTION is used since the type is for test code. namespace concrt { // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION , no_copy_move { // ... }; } // namepace concrt","title":"Definition (Windows)"},{"location":"features/concrt-section/#definition-posix","text":"With POSIX API, it uses pthread_rwlock_t . The type's existance is only for platform compatibility of test codes. The type was written with pthread_mutex_t to replace std::mutex in test code. The reason was that some test codes required different setting like PTHREAD_PRIO_NONE . namespace concrt { // Standard lockable with pthread reader writer lock class section final : no_copy_move { pthread_rwlock_t rwlock ; // ... }; } // namepace concrt","title":"Definition (POSIX)"},{"location":"features/concrt-section/#example","text":"#include <coroutine/concrt.h> using namespace concrt ; void perform_with_lock ( section & m ){ std :: lock_guard lck { m }; // do some work... } In this library: test/channel_race_no_leak.cpp","title":"Example"},{"location":"features/frame-compiler_specific/","text":"This document covers compiler specific issues. See Also <coroutine/frame.h> Exploring the C++ coroutine Github Issues in this repo Compiler Awareness The file declares some variables for if constexpr support. static constexpr auto is_msvc = // true or false ... static constexpr auto is_clang = // true or false ... static constexpr auto is_gcc = // true or false ... Compiler Intrinsic For MSVC, the library rely on 2 intrinsic functions and 1 adapter function. extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // adapter for _coro_done bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; For Clang, the library rely on 3 intrinsic functions. extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * ); Coroutine Frame Prefix The file also defines frame prefix types to help debugging of coroutine frame. template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16 - 1 ) & ~ ( 16 - 1 )); using procedure_t = void ( __cdecl * )( void * ); The following type is for MSVC. struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); The following type is for Clang and Clang-cl. struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 );","title":"Frame compiler specific"},{"location":"features/frame-compiler_specific/#see-also","text":"<coroutine/frame.h> Exploring the C++ coroutine Github Issues in this repo","title":"See Also"},{"location":"features/frame-compiler_specific/#compiler-awareness","text":"The file declares some variables for if constexpr support. static constexpr auto is_msvc = // true or false ... static constexpr auto is_clang = // true or false ... static constexpr auto is_gcc = // true or false ...","title":"Compiler Awareness"},{"location":"features/frame-compiler_specific/#compiler-intrinsic","text":"For MSVC, the library rely on 2 intrinsic functions and 1 adapter function. extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // adapter for _coro_done bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; For Clang, the library rely on 3 intrinsic functions. extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * );","title":"Compiler Intrinsic"},{"location":"features/frame-compiler_specific/#coroutine-frame-prefix","text":"The file also defines frame prefix types to help debugging of coroutine frame. template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16 - 1 ) & ~ ( 16 - 1 )); using procedure_t = void ( __cdecl * )( void * ); The following type is for MSVC. struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); The following type is for Clang and Clang-cl. struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 );","title":"Coroutine Frame Prefix"},{"location":"features/frame-coroutine_handle/","text":"See Also n4736 <experimental/coroutine> in VC++ <experimental/coroutine> in libc++ 7 or later Library Issues https://github.com/luncliff/coroutine/issues/23 Coroutine Handle (Standard) ToDo: Summarize the standard docs Coroutine Handle (Custom) Defines the templace class coroutine_handle<T> in std::experimental namespace. namespace std :: experimental { template < typename PromiseType = void > class coroutine_handle ; } Template Parameters PromiseType must fulfills the Coroutine Promise Requirement. Default Operations The class coroutine_handle<P> is regular type . namespace std :: experimental { template <> class coroutine_handle < void > { public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept ; explicit coroutine_handle ( std :: nullptr_t ) noexcept ; // ... }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); // ... } With Void Mostly the type will be used with void as its promise type( coroutine_handle<void> ). In the case, its member functions are like the following table. Function Description operator bool Tells the coroutine handle is not empty resume Resume the coroutine's control flow. The coroutine must be in suspended state. destroy Destruct the variables in the coroutine frame and the frame done Returns true if the coroutine is returned address Acquire the address of the frame from_address Create a coroutine handle that uses the given address as a frame namespace std :: experimental { template <> class coroutine_handle < void > { public : operator bool () const noexcept ; void resume () noexcept ( false ); void destroy () noexcept ; bool done () const noexcept ; constexpr void * address () const noexcept ; static coroutine_handle from_address ( void * addr ) noexcept ; // ... }; } With Promise When the promise type is not void , the template class defines additional functions to work with the PromiseType . Function Description from_address Considering the promise type's size, create a coroutine handle from the given address from_promise Create a handle from the reference to promise namespace std :: experimental { template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; // ... static coroutine_handle from_address ( void * addr ) noexcept ; static coroutine_handle from_promise ( promise_type & prom ) noexcept ; // ... }; } Non-Member Functions Compare Operators namespace std :: experimental { bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; }","title":"Frame coroutine handle"},{"location":"features/frame-coroutine_handle/#see-also","text":"n4736 <experimental/coroutine> in VC++ <experimental/coroutine> in libc++ 7 or later","title":"See Also"},{"location":"features/frame-coroutine_handle/#library-issues","text":"https://github.com/luncliff/coroutine/issues/23","title":"Library Issues"},{"location":"features/frame-coroutine_handle/#coroutine-handle-standard","text":"ToDo: Summarize the standard docs","title":"Coroutine Handle (Standard)"},{"location":"features/frame-coroutine_handle/#coroutine-handle-custom","text":"Defines the templace class coroutine_handle<T> in std::experimental namespace. namespace std :: experimental { template < typename PromiseType = void > class coroutine_handle ; }","title":"Coroutine Handle (Custom)"},{"location":"features/frame-coroutine_handle/#template-parameters","text":"PromiseType must fulfills the Coroutine Promise Requirement.","title":"Template Parameters"},{"location":"features/frame-coroutine_handle/#default-operations","text":"The class coroutine_handle<P> is regular type . namespace std :: experimental { template <> class coroutine_handle < void > { public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept ; explicit coroutine_handle ( std :: nullptr_t ) noexcept ; // ... }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); // ... }","title":"Default Operations"},{"location":"features/frame-coroutine_handle/#with-void","text":"Mostly the type will be used with void as its promise type( coroutine_handle<void> ). In the case, its member functions are like the following table. Function Description operator bool Tells the coroutine handle is not empty resume Resume the coroutine's control flow. The coroutine must be in suspended state. destroy Destruct the variables in the coroutine frame and the frame done Returns true if the coroutine is returned address Acquire the address of the frame from_address Create a coroutine handle that uses the given address as a frame namespace std :: experimental { template <> class coroutine_handle < void > { public : operator bool () const noexcept ; void resume () noexcept ( false ); void destroy () noexcept ; bool done () const noexcept ; constexpr void * address () const noexcept ; static coroutine_handle from_address ( void * addr ) noexcept ; // ... }; }","title":"With Void"},{"location":"features/frame-coroutine_handle/#with-promise","text":"When the promise type is not void , the template class defines additional functions to work with the PromiseType . Function Description from_address Considering the promise type's size, create a coroutine handle from the given address from_promise Create a handle from the reference to promise namespace std :: experimental { template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; // ... static coroutine_handle from_address ( void * addr ) noexcept ; static coroutine_handle from_promise ( promise_type & prom ) noexcept ; // ... }; }","title":"With Promise"},{"location":"features/frame-coroutine_handle/#non-member-functions","text":"","title":"Non-Member Functions"},{"location":"features/frame-coroutine_handle/#compare-operators","text":"namespace std :: experimental { bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; }","title":"Compare Operators"},{"location":"features/frame-coroutine_traits/","text":"This document covers coroutine_traits<R, P...> . Coroutine Traits (Standard) TBA Coroutine Traits (Custom) Unlike libc++ or VC++, current version doesn't allow SFINAE. namespace std :: experimental { // traits to enforce member `promise_type` template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; }","title":"Frame coroutine traits"},{"location":"features/frame-coroutine_traits/#coroutine-traits-standard","text":"TBA","title":"Coroutine Traits (Standard)"},{"location":"features/frame-coroutine_traits/#coroutine-traits-custom","text":"Unlike libc++ or VC++, current version doesn't allow SFINAE. namespace std :: experimental { // traits to enforce member `promise_type` template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; }","title":"Coroutine Traits (Custom)"},{"location":"features/frame-overview/","text":"#include <coroutine/frame.h> using namespace std :: experimental ; References http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0664r0.html ToDo organize list in this issue add list for the latest ones Background C++ Coroutines is so compiler specific that we can't compile VC++'s <experimental/coroutine> with Clang compiler, and vice versa. Because this is an example project, I believe I have a duty to show people how to configure projects under those envionments. The start was clang-cl on Windows, and I solved some problems related to the difference between 2 compilers. For that, there was no way but to add a wrapper header file. <coroutine/frame.h> file is an adapter to handle coroutine frame's difference between compilers. (For now, they are MSVC and Clang ). Notice that the file imports <experimental/coroutine> . Just like below, <coroutine/frame.h> activates custom implementation only for specific environments. // <coroutine> header build issue handling #if defined(__clang__) && defined(_MSC_VER) // case: clang-cl, VC++ // Use this library's implementation ... #else // case: msvc, VC++ // case: clang, libc++ # if __has_include(<coroutine>) // C++ 20 # include <coroutine> # elif __has_include(<experimental/coroutine>) // C++ 17 # include <experimental/coroutine> # endif #endif // ... So in general you don't have to care. Think of <coroutine/frame.h> as <coroutine> in the future. #if __has_include(<coroutine>) # include <coroutine> #else # include <coroutine/frame.h> #endif If you're really curious, read the file and please review my approach. :) Contents I'm going to cover both the standard and my implementation in this section. You can think these items are the supplement of https://en.cppreference.com/w/cpp . #include <coroutine/frame.h> using namespace std :: experimental ; coroutine_handle<P> coroutine_traits<R, P...> suspend_never and suspend_always Note: Compiler Specific Issues","title":"Frame overview"},{"location":"features/frame-overview/#references","text":"http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0664r0.html ToDo organize list in this issue add list for the latest ones","title":"References"},{"location":"features/frame-overview/#background","text":"C++ Coroutines is so compiler specific that we can't compile VC++'s <experimental/coroutine> with Clang compiler, and vice versa. Because this is an example project, I believe I have a duty to show people how to configure projects under those envionments. The start was clang-cl on Windows, and I solved some problems related to the difference between 2 compilers. For that, there was no way but to add a wrapper header file. <coroutine/frame.h> file is an adapter to handle coroutine frame's difference between compilers. (For now, they are MSVC and Clang ). Notice that the file imports <experimental/coroutine> . Just like below, <coroutine/frame.h> activates custom implementation only for specific environments. // <coroutine> header build issue handling #if defined(__clang__) && defined(_MSC_VER) // case: clang-cl, VC++ // Use this library's implementation ... #else // case: msvc, VC++ // case: clang, libc++ # if __has_include(<coroutine>) // C++ 20 # include <coroutine> # elif __has_include(<experimental/coroutine>) // C++ 17 # include <experimental/coroutine> # endif #endif // ... So in general you don't have to care. Think of <coroutine/frame.h> as <coroutine> in the future. #if __has_include(<coroutine>) # include <coroutine> #else # include <coroutine/frame.h> #endif If you're really curious, read the file and please review my approach. :)","title":"Background"},{"location":"features/frame-overview/#contents","text":"I'm going to cover both the standard and my implementation in this section. You can think these items are the supplement of https://en.cppreference.com/w/cpp . #include <coroutine/frame.h> using namespace std :: experimental ; coroutine_handle<P> coroutine_traits<R, P...> suspend_never and suspend_always Note: Compiler Specific Issues","title":"Contents"},{"location":"features/frame-suspend_types/","text":"Coroutine Promise Requirement requires some awaitable type for the initial_suspend and final_suspend member functions for promise_type . suspend_never Awaitable type that never suspend. The control flows through ready - resume . Definition Example namespace std :: experimental { class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // Since the class won't suspend, this function won't be invoked } }; } // namespace std::experimental Known Usages In this library: Type enumerable<T> Type no_return TBA: external references suspend_always Awaitable type that always suspend. The control flows through ready - suspend - resume . Definition Example namespace std :: experimental { class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // The routine will suspend but the class ignores the given handle } }; } // namespace std::experimental Known Usages In this library: Type frame TBA: external references","title":"Frame suspend types"},{"location":"features/frame-suspend_types/#suspend_never","text":"Awaitable type that never suspend. The control flows through ready - resume .","title":"suspend_never"},{"location":"features/frame-suspend_types/#definition-example","text":"namespace std :: experimental { class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // Since the class won't suspend, this function won't be invoked } }; } // namespace std::experimental","title":"Definition Example"},{"location":"features/frame-suspend_types/#known-usages","text":"In this library: Type enumerable<T> Type no_return TBA: external references","title":"Known Usages"},{"location":"features/frame-suspend_types/#suspend_always","text":"Awaitable type that always suspend. The control flows through ready - suspend - resume .","title":"suspend_always"},{"location":"features/frame-suspend_types/#definition-example_1","text":"namespace std :: experimental { class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // The routine will suspend but the class ignores the given handle } }; } // namespace std::experimental","title":"Definition Example"},{"location":"features/frame-suspend_types/#known-usages_1","text":"In this library: Type frame TBA: external references","title":"Known Usages"},{"location":"features/net-implementation-epoll/","text":"This document is under progress ... Epoll For Linux platform, it uses epoll . modules/linux/net.cpp Expect & Ensures Socket Socket object for the argument must be O_NONBLOCK flagged. int64_t socket_create ( const addrinfo & hint ) { int64_t sd = socket ( hint . ai_family , hint . ai_socktype , hint . ai_protocol ); if ( sd == - 1 ) FAIL ( strerror ( errno )); return sd ; } void socket_set_option_nonblock ( int64_t sd ) { // make non-block/async REQUIRE ( fcntl ( sd , F_SETFL , O_NONBLOCK | O_ASYNC ) != - 1 ); } The library assumes that all socket descriptors will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SHUT_RDWR ); close ( sd ); } Control Flow and Data The table shows all system calls that are used for each interface functions. Interface Internal send_to epoll_ctl , sendto recv_from epoll_ctl , recvfrom send_stream epoll_ctl , send recv_stream epoll_ctl , recv wait_io_tasks epoll_wait , epoll_create1 , close Concurrent I/O control I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume Request This step works just like Winsock based implementation. auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . sd = sd ; work . from6 = addressof ( remote ); work . addrlen = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } Progress Check fcntl checks the socket's flag for non blocking. If the socket is not flagged non-block, co_await will bypass the suspend step(which uses epoll ) and it will directed to blocking I/O. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true and bypass the epoll return true ; } Suspend coroutine_handle becomes user data of epoll event. However, if there is a pending recv , another recv request won't cancel the previous one . Therefore user have to be cautious about managing pending operations for the socket. struct event_data_t { int fd ; const size_t capacity ; unique_ptr < epoll_event [] > events ; // ... void try_add ( uint64_t sd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( fd , op , sd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } }; void io_recv_from :: suspend ( coroutine_task_t rh ) noexcept ( false ) { errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails } Polling and Resume Since only 1 event can be bound for a file descriptor, the implementation separates inbound and outbound. send , send_to uses inbound and recv , recv_from uses the other. wait_io_tasks function polls both like the following code. event_data_t inbound {}, outbound {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; for ( auto coro : inbound . wait ( half_time )) co_yield coro ; for ( auto coro : outbound . wait ( half_time )) co_yield coro ; } Limitations Current version doesn't provide interface for I/O cancel.","title":"Net implementation epoll"},{"location":"features/net-implementation-epoll/#epoll","text":"For Linux platform, it uses epoll . modules/linux/net.cpp","title":"Epoll"},{"location":"features/net-implementation-epoll/#expect-ensures","text":"","title":"Expect &amp; Ensures"},{"location":"features/net-implementation-epoll/#socket","text":"Socket object for the argument must be O_NONBLOCK flagged. int64_t socket_create ( const addrinfo & hint ) { int64_t sd = socket ( hint . ai_family , hint . ai_socktype , hint . ai_protocol ); if ( sd == - 1 ) FAIL ( strerror ( errno )); return sd ; } void socket_set_option_nonblock ( int64_t sd ) { // make non-block/async REQUIRE ( fcntl ( sd , F_SETFL , O_NONBLOCK | O_ASYNC ) != - 1 ); } The library assumes that all socket descriptors will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SHUT_RDWR ); close ( sd ); }","title":"Socket"},{"location":"features/net-implementation-epoll/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to epoll_ctl , sendto recv_from epoll_ctl , recvfrom send_stream epoll_ctl , send recv_stream epoll_ctl , recv wait_io_tasks epoll_wait , epoll_create1 , close","title":"Control Flow and Data"},{"location":"features/net-implementation-epoll/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume","title":"Concurrent I/O control"},{"location":"features/net-implementation-epoll/#request","text":"This step works just like Winsock based implementation. auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . sd = sd ; work . from6 = addressof ( remote ); work . addrlen = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); }","title":"Request"},{"location":"features/net-implementation-epoll/#progress-check","text":"fcntl checks the socket's flag for non blocking. If the socket is not flagged non-block, co_await will bypass the suspend step(which uses epoll ) and it will directed to blocking I/O. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true and bypass the epoll return true ; }","title":"Progress Check"},{"location":"features/net-implementation-epoll/#suspend","text":"coroutine_handle becomes user data of epoll event. However, if there is a pending recv , another recv request won't cancel the previous one . Therefore user have to be cautious about managing pending operations for the socket. struct event_data_t { int fd ; const size_t capacity ; unique_ptr < epoll_event [] > events ; // ... void try_add ( uint64_t sd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( fd , op , sd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } }; void io_recv_from :: suspend ( coroutine_task_t rh ) noexcept ( false ) { errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails }","title":"Suspend"},{"location":"features/net-implementation-epoll/#polling-and-resume","text":"Since only 1 event can be bound for a file descriptor, the implementation separates inbound and outbound. send , send_to uses inbound and recv , recv_from uses the other. wait_io_tasks function polls both like the following code. event_data_t inbound {}, outbound {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; for ( auto coro : inbound . wait ( half_time )) co_yield coro ; for ( auto coro : outbound . wait ( half_time )) co_yield coro ; }","title":"Polling and Resume"},{"location":"features/net-implementation-epoll/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"features/net-implementation-kqueue/","text":"This document is under progress ... KQueue For Mac OS(Darwin) platform, it uses kqueue . modules/darwin/net.cpp Expect & Ensures Socket All expectations for socket object are same with epoll based implementation . Control Flow and Data The table shows all system calls that are used for each interface functions. Interface Internal send_to kevent64 , sendto recv_from kevent64 , recvfrom send_stream kevent64 , send recv_stream kevent64 , recv wait_io_tasks kqueue , kevent64 , close Concurrent I/O control I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume Request It performs argument copy(packing) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . sd = sd ; work . addrlen = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } Progress Check The implementation equals to the case of epoll . If the socket is not O_NONBLOCK flagged, it won't use kqueue API. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return errc ; } Suspend Every requests will be one shot requests. Unlike epoll based implementation, it uses io_work for user data. void io_send :: suspend ( coroutine_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = sd ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); auto ec = kevent64 ( kq . fd , & req , 1 , // change nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; } Polling and Resume wait_io_tasks yields iterates kevent64 list. Each of their user data( io_work ) holds coroutine_handle , so the functuon yields them one by one. Current version doesn't use additional information in kevent64 , but the structure will be maintained to deliver it on demand. struct kqueue_data_t { int fd ; const size_t capacity ; unique_ptr < kevent64_s [] > events ; // ... }; kqueue_data_t kq {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); // wait for events ... auto count = kevent64 ( kq . fd , nullptr , 0 , // kq . events . get (), kq . capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { auto & ev = kq . events [ i ]; auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } resume operations perform actual i/o request and acquire its result. int64_t io_send :: resume () noexcept { const auto flag = addrlen ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; // -> io_work::error return sz ; } Limitations Current version doesn't provide interface for I/O cancel.","title":"Net implementation kqueue"},{"location":"features/net-implementation-kqueue/#kqueue","text":"For Mac OS(Darwin) platform, it uses kqueue . modules/darwin/net.cpp","title":"KQueue"},{"location":"features/net-implementation-kqueue/#expect-ensures","text":"","title":"Expect &amp; Ensures"},{"location":"features/net-implementation-kqueue/#socket","text":"All expectations for socket object are same with epoll based implementation .","title":"Socket"},{"location":"features/net-implementation-kqueue/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to kevent64 , sendto recv_from kevent64 , recvfrom send_stream kevent64 , send recv_stream kevent64 , recv wait_io_tasks kqueue , kevent64 , close","title":"Control Flow and Data"},{"location":"features/net-implementation-kqueue/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume","title":"Concurrent I/O control"},{"location":"features/net-implementation-kqueue/#request","text":"It performs argument copy(packing) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . sd = sd ; work . addrlen = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); }","title":"Request"},{"location":"features/net-implementation-kqueue/#progress-check","text":"The implementation equals to the case of epoll . If the socket is not O_NONBLOCK flagged, it won't use kqueue API. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return errc ; }","title":"Progress Check"},{"location":"features/net-implementation-kqueue/#suspend","text":"Every requests will be one shot requests. Unlike epoll based implementation, it uses io_work for user data. void io_send :: suspend ( coroutine_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = sd ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); auto ec = kevent64 ( kq . fd , & req , 1 , // change nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; }","title":"Suspend"},{"location":"features/net-implementation-kqueue/#polling-and-resume","text":"wait_io_tasks yields iterates kevent64 list. Each of their user data( io_work ) holds coroutine_handle , so the functuon yields them one by one. Current version doesn't use additional information in kevent64 , but the structure will be maintained to deliver it on demand. struct kqueue_data_t { int fd ; const size_t capacity ; unique_ptr < kevent64_s [] > events ; // ... }; kqueue_data_t kq {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); // wait for events ... auto count = kevent64 ( kq . fd , nullptr , 0 , // kq . events . get (), kq . capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { auto & ev = kq . events [ i ]; auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } resume operations perform actual i/o request and acquire its result. int64_t io_send :: resume () noexcept { const auto flag = addrlen ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; // -> io_work::error return sz ; }","title":"Polling and Resume"},{"location":"features/net-implementation-kqueue/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"features/net-implementation-winsock2/","text":"This document is under progress ... Coroutine + Socket Overlapped I/O + Completion Routine See Also CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Winsock Overlapped I/O modules/windows/net.cpp Remarks The library never invoke WSAStartup and WSACleanup . User must do it. Socket socket object for the argument must be WSA_FLAG_OVERLAPPED flagged. int64_t socket_create ( const addrinfo & hint ) { // use address hint in test class int64_t sd = :: WSASocketW ( hint . ai_family , hint . ai_socktype , hint . ai_protocol , nullptr , 0 , WSA_FLAG_OVERLAPPED ); if ( sd == INVALID_SOCKET ) fail_with_error_message ( WSAGetLastError ()); return sd ; } The library assumes that SOCKET will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SD_BOTH ); closesocket ( sd ); } Control Flow and Data The table shows all system calls that are used for each interface functions. Interface Internal send_to WSASendTo recv_from WSARecvFrom send_stream WSASend recv_stream WSARecv io_work_t containes OVERLAPPED struct . struct io_work_t : public OVERLAPPED { coroutine_task_t task {}; io_buffer_t buffer {}; union { sockaddr * addr {}; sockaddr_in6 * from6 ; const sockaddr_in6 * to6 ; sockaddr_in * from ; const sockaddr_in * to ; }; }; Since it uses completion routine to resume I/O coroutines, wait_io_tasks will always return 0 coroutine handle. // file: <coroutine/net.h> // - Note // This function is only non-windows platform. // Over windows api, it always yields nothing. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > ; Concurrent I/O control I/O Request I/O Progress Check I/O Suspend I/O Resume Request The interface function converts given arguments to invoke Winsock API. auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); work . buffer = buffer ; work . to6 = std :: addressof ( remote ); work . Internal = sd ; work . InternalHigh = sizeof ( remote ); // lead to co_await operations with `io_send_to` type return * reinterpret_cast < io_send_to *> ( std :: addressof ( work )); } Progress Check Always leads to suspend procedure. bool io_work_t :: ready () const noexcept { return false ; // trigger `await_suspend` } Suspend Actual request comes after coroutine_handle is forwarded. void io_send_to :: suspend ( coroutine_task_t rh ) noexcept ( false ) { const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = DWORD { 0 }; const auto sd = gsl :: narrow_cast < SOCKET > ( Internal ); auto bufs = make_wsa_buf ( buffer ); task = rh ; // coroutine for the i/o callback :: WSASendTo ( sd , & bufs , 1 , // nullptr , flag , addr , addrlen , // zero_overlapped ( this ), onWorkDone ); const auto ec = WSAGetLastError (); if ( ec == NO_ERROR || ec == ERROR_IO_PENDING ) return ; // ok. expected for async i/o throw std :: system_error { ec , std :: system_category (), \"WSASendTo\" }; } int64_t io_send_to :: resume () noexcept { return gsl :: narrow_cast < int64_t > ( InternalHigh ); } Resume (by Completion Routine) Completion routine resumes its coroutine frame. io_work works as a receiver for the operation results. void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); work -> Internal = errc ; // -> return of `await_resume()` work -> InternalHigh = sz ; // -> return of `work.error()` work -> task . resume (); } In general(x64), Internal and InternalHigh already have same value with errc , sz . The routine just ensures it. Limitations Current version doesn't provide interface for I/O cancel.","title":"Net implementation winsock2"},{"location":"features/net-implementation-winsock2/#see-also","text":"CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\"","title":"See Also"},{"location":"features/net-implementation-winsock2/#winsock-overlapped-io","text":"modules/windows/net.cpp","title":"Winsock Overlapped I/O"},{"location":"features/net-implementation-winsock2/#remarks","text":"The library never invoke WSAStartup and WSACleanup . User must do it.","title":"Remarks"},{"location":"features/net-implementation-winsock2/#socket","text":"socket object for the argument must be WSA_FLAG_OVERLAPPED flagged. int64_t socket_create ( const addrinfo & hint ) { // use address hint in test class int64_t sd = :: WSASocketW ( hint . ai_family , hint . ai_socktype , hint . ai_protocol , nullptr , 0 , WSA_FLAG_OVERLAPPED ); if ( sd == INVALID_SOCKET ) fail_with_error_message ( WSAGetLastError ()); return sd ; } The library assumes that SOCKET will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SD_BOTH ); closesocket ( sd ); }","title":"Socket"},{"location":"features/net-implementation-winsock2/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to WSASendTo recv_from WSARecvFrom send_stream WSASend recv_stream WSARecv io_work_t containes OVERLAPPED struct . struct io_work_t : public OVERLAPPED { coroutine_task_t task {}; io_buffer_t buffer {}; union { sockaddr * addr {}; sockaddr_in6 * from6 ; const sockaddr_in6 * to6 ; sockaddr_in * from ; const sockaddr_in * to ; }; }; Since it uses completion routine to resume I/O coroutines, wait_io_tasks will always return 0 coroutine handle. // file: <coroutine/net.h> // - Note // This function is only non-windows platform. // Over windows api, it always yields nothing. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > ;","title":"Control Flow and Data"},{"location":"features/net-implementation-winsock2/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Resume","title":"Concurrent I/O control"},{"location":"features/net-implementation-winsock2/#request","text":"The interface function converts given arguments to invoke Winsock API. auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); work . buffer = buffer ; work . to6 = std :: addressof ( remote ); work . Internal = sd ; work . InternalHigh = sizeof ( remote ); // lead to co_await operations with `io_send_to` type return * reinterpret_cast < io_send_to *> ( std :: addressof ( work )); }","title":"Request"},{"location":"features/net-implementation-winsock2/#progress-check","text":"Always leads to suspend procedure. bool io_work_t :: ready () const noexcept { return false ; // trigger `await_suspend` }","title":"Progress Check"},{"location":"features/net-implementation-winsock2/#suspend","text":"Actual request comes after coroutine_handle is forwarded. void io_send_to :: suspend ( coroutine_task_t rh ) noexcept ( false ) { const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = DWORD { 0 }; const auto sd = gsl :: narrow_cast < SOCKET > ( Internal ); auto bufs = make_wsa_buf ( buffer ); task = rh ; // coroutine for the i/o callback :: WSASendTo ( sd , & bufs , 1 , // nullptr , flag , addr , addrlen , // zero_overlapped ( this ), onWorkDone ); const auto ec = WSAGetLastError (); if ( ec == NO_ERROR || ec == ERROR_IO_PENDING ) return ; // ok. expected for async i/o throw std :: system_error { ec , std :: system_category (), \"WSASendTo\" }; } int64_t io_send_to :: resume () noexcept { return gsl :: narrow_cast < int64_t > ( InternalHigh ); }","title":"Suspend"},{"location":"features/net-implementation-winsock2/#resume-by-completion-routine","text":"Completion routine resumes its coroutine frame. io_work works as a receiver for the operation results. void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); work -> Internal = errc ; // -> return of `await_resume()` work -> InternalHigh = sz ; // -> return of `work.error()` work -> task . resume (); } In general(x64), Internal and InternalHigh already have same value with errc , sz . The routine just ensures it.","title":"Resume (by Completion Routine)"},{"location":"features/net-implementation-winsock2/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"features/net-overview/","text":"The interface contains socket I/O functions with coroutine. See Also CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" Dependency The interface uses GSL(Guideline Support Library) and some of this library's features. For GSL itself, please see the GSL section in the C++ Core Guidelines . #include <coroutine/yield.hpp> #include <gsl/gsl> Variables constexpr The header defines 2 constexpr variable. static constexpr bool is_winsock = /* true or false */ ; static constexpr bool is_netinet = /* true or false */ ; Types io_control_block This is an alias of OVERLAPPED struct. For netinet, it's struct follows the OVERLAPPED . // follow the definition of Windows `OVERLAPPED` struct io_control_block { uint64_t internal ; // uint32_t errc; int32_t flag; uint64_t internal_high ; union { struct { int32_t offset ; // socklen_t addrlen; int32_t offset_high ; }; void * ptr ; }; int64_t handle ; // int64_t sd; }; endpoint_t Helper type for socket address usage. Notice that the type contains sockaddr_storage . union endpoint_t final { sockaddr_storage storage {}; sockaddr addr ; sockaddr_in in4 ; sockaddr_in6 in6 ; }; io_task_t This is an alias of coroutine_handle<void> . The coroutine frame becomes an user data in the underlying system's API // 1 task item == 1 resumable function using io_task_t = std :: experimental :: coroutine_handle < void > ; io_buffer_t The type is a view to the bytes(storage for read/write operation). Be aware that it doesn't have ownership. See gsl::span<T> for its usage. using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 ); io_work_t It is a struct to describe 1 I/O request to the underlying system's API class io_work_t : public io_control_block { io_task_t task {}; io_buffer_t buffer {}; endpoint_t * ep {}; public : bool ready () const noexcept ; uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 64 ); After co_await , error() returns the stored error from I/O operation. For its usage, see the examples in I/O operation functions. Operations Remarks The library doesn't use cancel/scatter/gather operations. The library doesn't provide create/destroy/option for the socket. Such an abstraction is tedious and distracts to understand both interface design and internal codes. It just expects that the given socket is non-block and async one, and it works as designed only for the case. Test helper codes below contain socket functions. You can copy-and-paste them :) test/test_network.h test/test_network.cpp wait_io_tasks Acquires currently resumable I/O coroutines. This function is for non-windows platform. Over Windows API, the implementation resumes I/O coroutines automatically. So it always yields nothing . Also, the library does not guarantee that all coroutines(I/O tasks) will be fetched at once. Therefore it is strongly recommended for user to have another method to detect that watching I/O coroutines are returned. User must repeat the resuming loop without break so that there is no leak of event. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > ; Example Use it with the constexpr variables . void io_polling_example () { if constexpr ( is_winsock == false ) { // the library doesn't guarantee they will be fetched at once // so user have to repeat enough to finish all i/o tasks for ( auto task : wait_io_tasks ( 10 ms )) task . resume (); } } send_to Request to internal API to send a buffer to specific endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_send_to final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in6 & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; Params sd : a bound socket descriptor remote : remote address to send buf buf : data(span of std::byte ) to send work : I/O request holder. Down-casted to io_send_to Return send_to : lvalue reference to an awaitable type( io_send_to ) await_resume : success: the length of sent bytes in int64_t failure: the error code will be stored to given work Example The following code shows how send_to can be used. auto example ( uint64_t sd , const sockaddr_in & remote , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_to ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz == storage . size ()); } recv_from Request to internal API to receive through a socket from the unspecified endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_recv_from final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; Params sd : a bound socket descriptor remote : memory to store sender's address buf : data(span of std::byte ) to receive work : I/O request holder. Down-casted to io_recv_from Return recv_from : lvalue reference to an awaitable type( io_recv_from ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example The following code shows how recv_from can be used. auto example ( uint64_t sd , sockaddr_in & remote , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_from ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); } send_stream Request to internal API to send to the connected peer and return a refernce of concrete io_work_t that can be used for co_await . class io_send final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_send & ; Params sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_send Return send_stream : lvalue reference to an awaitable type( io_send ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example The following code shows how send_stream can be used. auto example ( int64_t sd , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz > 0 ); } recv_stream Request to internal API to receive through the connected socket and return a refernce of concrete io_work_t that can be used for co_await . class io_recv final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_recv & ; Params sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_recv Return recv_stream : lvalue reference to an awaitable type( io_recv ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example The following code shows how recv_stream can be used. auto example ( int64_t sd , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); } Usage Pattern User must use 2 parts to use the interface. I/O coroutine I/O polling subroutine 1 I/O Reqeust == 1 Coroutine Each I/O request flows sequentially. Polling subroutine will yields coroutines with finished(errored) I/O. auto user_io_coroutine ( uint64_t socket ) -> some_return_type { io_work_t work {}; // control block object io_buffer_t buf {}; // { byte*, size_t } endpoint_t remote {}; // this is the only allowed usage pattern int64_t sz = co_await io_request ( socket , remote , buf , work ) if ( sz == - 1 ) { // ec is updated after the request auto ec = work . error (); // ... } // ... } The request can be one of following functions. Interface Description send_to Send to a specific endpoint( sockaddr ) recv_from Receive a packet and set the sender's endpoint( sockaddr ) send_stream Send to the socket's connected peer recv_stream Receive from the socket's connected peer Continuation of I/O Coroutines User can pool until all I/O coroutines are finished with wait_io_tasks function. It will yield at least 0 coroutine handle. auto example_io_polling ( bool & all_io_finished ) { // timeout with <chrono> using namespace std :: chrono_literals ; // ... while ( all_io_finished == false ) for ( auto coro : wait_io_tasks ( 10 ms )) coro . resume (); // ... } Examples resolve IPv6 Multicast TCPv6 Connect UDPv6 v4 mapped send_stream / recv_stream ( wait_io_tasks ) send_to / recv_from ( wait_io_tasks )","title":"Net overview"},{"location":"features/net-overview/#see-also","text":"CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\"","title":"See Also"},{"location":"features/net-overview/#dependency","text":"The interface uses GSL(Guideline Support Library) and some of this library's features. For GSL itself, please see the GSL section in the C++ Core Guidelines . #include <coroutine/yield.hpp> #include <gsl/gsl>","title":"Dependency"},{"location":"features/net-overview/#variables","text":"","title":"Variables"},{"location":"features/net-overview/#constexpr","text":"The header defines 2 constexpr variable. static constexpr bool is_winsock = /* true or false */ ; static constexpr bool is_netinet = /* true or false */ ;","title":"constexpr"},{"location":"features/net-overview/#types","text":"","title":"Types"},{"location":"features/net-overview/#io_control_block","text":"This is an alias of OVERLAPPED struct. For netinet, it's struct follows the OVERLAPPED . // follow the definition of Windows `OVERLAPPED` struct io_control_block { uint64_t internal ; // uint32_t errc; int32_t flag; uint64_t internal_high ; union { struct { int32_t offset ; // socklen_t addrlen; int32_t offset_high ; }; void * ptr ; }; int64_t handle ; // int64_t sd; };","title":"io_control_block"},{"location":"features/net-overview/#endpoint_t","text":"Helper type for socket address usage. Notice that the type contains sockaddr_storage . union endpoint_t final { sockaddr_storage storage {}; sockaddr addr ; sockaddr_in in4 ; sockaddr_in6 in6 ; };","title":"endpoint_t"},{"location":"features/net-overview/#io_task_t","text":"This is an alias of coroutine_handle<void> . The coroutine frame becomes an user data in the underlying system's API // 1 task item == 1 resumable function using io_task_t = std :: experimental :: coroutine_handle < void > ;","title":"io_task_t"},{"location":"features/net-overview/#io_buffer_t","text":"The type is a view to the bytes(storage for read/write operation). Be aware that it doesn't have ownership. See gsl::span<T> for its usage. using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 );","title":"io_buffer_t"},{"location":"features/net-overview/#io_work_t","text":"It is a struct to describe 1 I/O request to the underlying system's API class io_work_t : public io_control_block { io_task_t task {}; io_buffer_t buffer {}; endpoint_t * ep {}; public : bool ready () const noexcept ; uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 64 ); After co_await , error() returns the stored error from I/O operation. For its usage, see the examples in I/O operation functions.","title":"io_work_t"},{"location":"features/net-overview/#operations","text":"","title":"Operations"},{"location":"features/net-overview/#remarks","text":"The library doesn't use cancel/scatter/gather operations. The library doesn't provide create/destroy/option for the socket. Such an abstraction is tedious and distracts to understand both interface design and internal codes. It just expects that the given socket is non-block and async one, and it works as designed only for the case. Test helper codes below contain socket functions. You can copy-and-paste them :) test/test_network.h test/test_network.cpp","title":"Remarks"},{"location":"features/net-overview/#wait_io_tasks","text":"Acquires currently resumable I/O coroutines. This function is for non-windows platform. Over Windows API, the implementation resumes I/O coroutines automatically. So it always yields nothing . Also, the library does not guarantee that all coroutines(I/O tasks) will be fetched at once. Therefore it is strongly recommended for user to have another method to detect that watching I/O coroutines are returned. User must repeat the resuming loop without break so that there is no leak of event. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > ;","title":"wait_io_tasks"},{"location":"features/net-overview/#example","text":"Use it with the constexpr variables . void io_polling_example () { if constexpr ( is_winsock == false ) { // the library doesn't guarantee they will be fetched at once // so user have to repeat enough to finish all i/o tasks for ( auto task : wait_io_tasks ( 10 ms )) task . resume (); } }","title":"Example"},{"location":"features/net-overview/#send_to","text":"Request to internal API to send a buffer to specific endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_send_to final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in6 & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ;","title":"send_to"},{"location":"features/net-overview/#params","text":"sd : a bound socket descriptor remote : remote address to send buf buf : data(span of std::byte ) to send work : I/O request holder. Down-casted to io_send_to","title":"Params"},{"location":"features/net-overview/#return","text":"send_to : lvalue reference to an awaitable type( io_send_to ) await_resume : success: the length of sent bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_1","text":"The following code shows how send_to can be used. auto example ( uint64_t sd , const sockaddr_in & remote , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_to ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz == storage . size ()); }","title":"Example"},{"location":"features/net-overview/#recv_from","text":"Request to internal API to receive through a socket from the unspecified endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_recv_from final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ;","title":"recv_from"},{"location":"features/net-overview/#params_1","text":"sd : a bound socket descriptor remote : memory to store sender's address buf : data(span of std::byte ) to receive work : I/O request holder. Down-casted to io_recv_from","title":"Params"},{"location":"features/net-overview/#return_1","text":"recv_from : lvalue reference to an awaitable type( io_recv_from ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_2","text":"The following code shows how recv_from can be used. auto example ( uint64_t sd , sockaddr_in & remote , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_from ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); }","title":"Example"},{"location":"features/net-overview/#send_stream","text":"Request to internal API to send to the connected peer and return a refernce of concrete io_work_t that can be used for co_await . class io_send final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_send & ;","title":"send_stream"},{"location":"features/net-overview/#params_2","text":"sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_send","title":"Params"},{"location":"features/net-overview/#return_2","text":"send_stream : lvalue reference to an awaitable type( io_send ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_3","text":"The following code shows how send_stream can be used. auto example ( int64_t sd , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz > 0 ); }","title":"Example"},{"location":"features/net-overview/#recv_stream","text":"Request to internal API to receive through the connected socket and return a refernce of concrete io_work_t that can be used for co_await . class io_recv final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_recv & ;","title":"recv_stream"},{"location":"features/net-overview/#params_3","text":"sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_recv","title":"Params"},{"location":"features/net-overview/#return_3","text":"recv_stream : lvalue reference to an awaitable type( io_recv ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"features/net-overview/#example_4","text":"The following code shows how recv_stream can be used. auto example ( int64_t sd , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); }","title":"Example"},{"location":"features/net-overview/#usage-pattern","text":"User must use 2 parts to use the interface. I/O coroutine I/O polling subroutine","title":"Usage Pattern"},{"location":"features/net-overview/#1-io-reqeust-1-coroutine","text":"Each I/O request flows sequentially. Polling subroutine will yields coroutines with finished(errored) I/O. auto user_io_coroutine ( uint64_t socket ) -> some_return_type { io_work_t work {}; // control block object io_buffer_t buf {}; // { byte*, size_t } endpoint_t remote {}; // this is the only allowed usage pattern int64_t sz = co_await io_request ( socket , remote , buf , work ) if ( sz == - 1 ) { // ec is updated after the request auto ec = work . error (); // ... } // ... } The request can be one of following functions. Interface Description send_to Send to a specific endpoint( sockaddr ) recv_from Receive a packet and set the sender's endpoint( sockaddr ) send_stream Send to the socket's connected peer recv_stream Receive from the socket's connected peer","title":"1 I/O Reqeust == 1 Coroutine"},{"location":"features/net-overview/#continuation-of-io-coroutines","text":"User can pool until all I/O coroutines are finished with wait_io_tasks function. It will yield at least 0 coroutine handle. auto example_io_polling ( bool & all_io_finished ) { // timeout with <chrono> using namespace std :: chrono_literals ; // ... while ( all_io_finished == false ) for ( auto coro : wait_io_tasks ( 10 ms )) coro . resume (); // ... }","title":"Continuation of I/O Coroutines"},{"location":"features/net-overview/#examples","text":"resolve IPv6 Multicast TCPv6 Connect UDPv6 v4 mapped send_stream / recv_stream ( wait_io_tasks ) send_to / recv_from ( wait_io_tasks )","title":"Examples"},{"location":"features/return-frame/","text":"See Also C++ Coroutines: Understanding the promise type Exploring The C++ Coroutine Coroutine Promise Requirements (N4736) frame as a ReturnType When user wants to (or have to) manage the destruction of coroutine frame, frame opens a way to acquire the coroutine_handle<void> . Basically, this type is a shallow extension of coroutine_handle<void> . Example The type can be empty. In the case, using done() member function will access to nullptr . #include <coroutine/return.h> using namespace coro ; auto coro_frame_empty_test () -> void { frame fh {}; auto coro = static_cast < coroutine_handle < void >> ( fh ); REQUIRE ( coro . address () == nullptr ); } When the coroutine frame's destuction need to be controlled manually, just suspend( co_await ) or return( co_return , the final suspend) in the function. #include <coroutine/return.h> using namespace coro ; auto invoke_and_suspend () -> frame { co_await suspend_always {}; co_return ; }; auto coro_frame_first_suspend_test () -> void { auto frame = invoke_and_suspend (); // allow access to `coroutine_handle<void>` // after first suspend(which can be `co_return`) coroutine_handle < void >& coro = frame ; REQUIRE ( static_cast < bool > ( coro )); // not null REQUIRE ( coro . done () == false ); // it is susepended, but not return. frame . destroy (); } Remarks The coroutine's frame will remain 'final suspended' after co_return . See the final_suspend in the definiton below. Like no_return , the type doesn't allows co_return; . Definition (Promise) The type's size is equal to that of coroutine_handle<void> . namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final { auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_always {}; // !!!!! } void return_void () noexcept ; void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * ; static auto get_return_object_on_allocation_failure () noexcept -> promise_type * ; }; public : void await_suspend ( coroutine_handle < void > coro ) noexcept ; frame () noexcept = default ; frame ( promise_type * p ) noexcept { this -> await_suspend ( coroutine_handle < promise_type >:: from_promise ( * p )); } }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro frame as an Awaitable The type can be also used as an awaitable to receive coroutine_handle<void> . You may think this harms the SRP(Single Responsibility Principle), but writing another type for the purpose will make the code tedious. Remark The following example shows frame doesn't guarantee it's target(coroutine's frame) is alive. See the following example. In the co_await expression, it must be used by reference . Example Please, be cautious. #include <gsl/gsl> #include <coroutine/return.h> using namespace coro ; auto save_current_handle_to_frame ( frame & fh , int & status ) -> no_return { auto defer = gsl :: finally ([ & ]() { status = 3 ; // change state on destruction phase }); status = 1 ; co_await fh ; // frame type as an awaitable. status = 2 ; co_await fh ; co_return ; } auto coro_frame_awaitable_test () -> void { int status = 0 ; frame coro {}; save_current_handle_to_frame ( coro , status ); REQUIRE ( status == 1 ); // `frame` inherits `coroutine_handle<void>` coro . resume (); REQUIRE ( status == 2 ); // coroutine reached end. // so `defer` in the routine will change status coro . resume (); REQUIRE ( status == 3 ); // however, `no_return` destroyed the coroutine's frame. // so `destroy` through `coro` will be undefined behavior... } Definition (Awaitable) It inherits await_ready and await_resume from the suspend_always type. However, it overrides await_suspend to save given handle. namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final ; public : // override `suspend_always::await_suspend` // assumed to be used as an argument of `co_await` by reference void await_suspend ( coroutine_handle < void > coro ) noexcept { coroutine_handle < void >& self = * this ; self = coro ; } frame () noexcept = default ; frame ( promise_type * p ) noexcept ; }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Return frame"},{"location":"features/return-frame/#see-also","text":"C++ Coroutines: Understanding the promise type Exploring The C++ Coroutine Coroutine Promise Requirements (N4736)","title":"See Also"},{"location":"features/return-frame/#frame-as-a-returntype","text":"When user wants to (or have to) manage the destruction of coroutine frame, frame opens a way to acquire the coroutine_handle<void> . Basically, this type is a shallow extension of coroutine_handle<void> .","title":"frame as a ReturnType"},{"location":"features/return-frame/#example","text":"The type can be empty. In the case, using done() member function will access to nullptr . #include <coroutine/return.h> using namespace coro ; auto coro_frame_empty_test () -> void { frame fh {}; auto coro = static_cast < coroutine_handle < void >> ( fh ); REQUIRE ( coro . address () == nullptr ); } When the coroutine frame's destuction need to be controlled manually, just suspend( co_await ) or return( co_return , the final suspend) in the function. #include <coroutine/return.h> using namespace coro ; auto invoke_and_suspend () -> frame { co_await suspend_always {}; co_return ; }; auto coro_frame_first_suspend_test () -> void { auto frame = invoke_and_suspend (); // allow access to `coroutine_handle<void>` // after first suspend(which can be `co_return`) coroutine_handle < void >& coro = frame ; REQUIRE ( static_cast < bool > ( coro )); // not null REQUIRE ( coro . done () == false ); // it is susepended, but not return. frame . destroy (); }","title":"Example"},{"location":"features/return-frame/#remarks","text":"The coroutine's frame will remain 'final suspended' after co_return . See the final_suspend in the definiton below. Like no_return , the type doesn't allows co_return; .","title":"Remarks"},{"location":"features/return-frame/#definition-promise","text":"The type's size is equal to that of coroutine_handle<void> . namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final { auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_always {}; // !!!!! } void return_void () noexcept ; void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * ; static auto get_return_object_on_allocation_failure () noexcept -> promise_type * ; }; public : void await_suspend ( coroutine_handle < void > coro ) noexcept ; frame () noexcept = default ; frame ( promise_type * p ) noexcept { this -> await_suspend ( coroutine_handle < promise_type >:: from_promise ( * p )); } }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Definition (Promise)"},{"location":"features/return-frame/#frame-as-an-awaitable","text":"The type can be also used as an awaitable to receive coroutine_handle<void> . You may think this harms the SRP(Single Responsibility Principle), but writing another type for the purpose will make the code tedious.","title":"frame as an Awaitable"},{"location":"features/return-frame/#remark","text":"The following example shows frame doesn't guarantee it's target(coroutine's frame) is alive. See the following example. In the co_await expression, it must be used by reference .","title":"Remark"},{"location":"features/return-frame/#example_1","text":"Please, be cautious. #include <gsl/gsl> #include <coroutine/return.h> using namespace coro ; auto save_current_handle_to_frame ( frame & fh , int & status ) -> no_return { auto defer = gsl :: finally ([ & ]() { status = 3 ; // change state on destruction phase }); status = 1 ; co_await fh ; // frame type as an awaitable. status = 2 ; co_await fh ; co_return ; } auto coro_frame_awaitable_test () -> void { int status = 0 ; frame coro {}; save_current_handle_to_frame ( coro , status ); REQUIRE ( status == 1 ); // `frame` inherits `coroutine_handle<void>` coro . resume (); REQUIRE ( status == 2 ); // coroutine reached end. // so `defer` in the routine will change status coro . resume (); REQUIRE ( status == 3 ); // however, `no_return` destroyed the coroutine's frame. // so `destroy` through `coro` will be undefined behavior... }","title":"Example"},{"location":"features/return-frame/#definition-awaitable","text":"It inherits await_ready and await_resume from the suspend_always type. However, it overrides await_suspend to save given handle. namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final ; public : // override `suspend_always::await_suspend` // assumed to be used as an argument of `co_await` by reference void await_suspend ( coroutine_handle < void > coro ) noexcept { coroutine_handle < void >& self = * this ; self = coro ; } frame () noexcept = default ; frame ( promise_type * p ) noexcept ; }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Definition (Awaitable)"},{"location":"features/return-no_return/","text":"See Also C++ coroutiness: Understanding the promise type Exploring The C++ coroutines Coroutine Promise Requirements (N4736) no_return This is a void return type for the general coroutine functions. Since a coroutine might suspend without return, it is not recommended to rely heavily on co_return from its caller/resumer. If the return can be ignored, class no_return can do the work. Remarks Since the promise_type does not final suspend, a frame of the coroutine that return no_return type will be destroyed immediately . Example If you doesn't care about coroutine's life cycle, use no_return . At least the routine will be resumed(continued) properly, co_return will destroy the frame #include <coroutine/return.h> using namespace coro ; auto fire_and_forget () -> no_return { co_await suspend_never {}; co_return ; }; auto example_caller () -> void { fire_and_forget (); // spawn a new coroutine frame. // the routine will be finished somehow // and destroy the frame. // do some other works ... } Definition It's definition is in the <coroutine/return.h> namespace coro { // General `void` return for the coroutine functions class no_return final { public : class promise_type final { public : // No suspend for init/final suspension point auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * { return this ; } static auto get_return_object_on_allocation_failure () noexcept -> promise_type * { return nullptr ; } }; public : no_return ( const promise_type * ) noexcept { // the type truncates all given info about its frame } }; } // namespace coro Possible customization points are ... unhandled_exception : We can throw the exception again and handle it , but mostly it depends on the scenario. This version assumes it's a somthing irrecoverable. get_return_object_on_allocation_failure : with operator new and operator delete , you can customise memory management for the coroutine frames.","title":"Return no return"},{"location":"features/return-no_return/#see-also","text":"C++ coroutiness: Understanding the promise type Exploring The C++ coroutines Coroutine Promise Requirements (N4736)","title":"See Also"},{"location":"features/return-no_return/#no_return","text":"This is a void return type for the general coroutine functions. Since a coroutine might suspend without return, it is not recommended to rely heavily on co_return from its caller/resumer. If the return can be ignored, class no_return can do the work.","title":"no_return"},{"location":"features/return-no_return/#remarks","text":"Since the promise_type does not final suspend, a frame of the coroutine that return no_return type will be destroyed immediately .","title":"Remarks"},{"location":"features/return-no_return/#example","text":"If you doesn't care about coroutine's life cycle, use no_return . At least the routine will be resumed(continued) properly, co_return will destroy the frame #include <coroutine/return.h> using namespace coro ; auto fire_and_forget () -> no_return { co_await suspend_never {}; co_return ; }; auto example_caller () -> void { fire_and_forget (); // spawn a new coroutine frame. // the routine will be finished somehow // and destroy the frame. // do some other works ... }","title":"Example"},{"location":"features/return-no_return/#definition","text":"It's definition is in the <coroutine/return.h> namespace coro { // General `void` return for the coroutine functions class no_return final { public : class promise_type final { public : // No suspend for init/final suspension point auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * { return this ; } static auto get_return_object_on_allocation_failure () noexcept -> promise_type * { return nullptr ; } }; public : no_return ( const promise_type * ) noexcept { // the type truncates all given info about its frame } }; } // namespace coro Possible customization points are ... unhandled_exception : We can throw the exception again and handle it , but mostly it depends on the scenario. This version assumes it's a somthing irrecoverable. get_return_object_on_allocation_failure : with operator new and operator delete , you can customise memory management for the coroutine frames.","title":"Definition"},{"location":"features/return-overview/","text":"#include <coroutine/return.h> using namespace coro ; References N4820 Working Draft N4736 Working Draft Background One of the entry barriers for the coroutine function is to write a return type. The return type's promise_type must fulfills the Coroutine Promise Requirement (Actually it's coroutine_traits<R>::promise_type , but just let me skip the detail for now). To save your time, start with the article of Lewiss Baker . I also wrote about it with N4402 , and with my talk in C++ Korea (see the page 60) . In my opinion, N4402 was short enough and explains well about the role of those requirements. Contents Currently, this library provides 2 types. #include <coroutine/return.h> using namespace coro ; no_return frame You may noticed that there is no task<T> . I don't have a plan to support the type for 2 reasons. To encourage use of https://github.com/lewissbaker/cppcoro which already implemented it To encourage use of the suspension( co_await and co_yield ) insead of the return( co_return ) In my perspective, the coroutine is a routine with multiple entry points and multiple suspend points. Therefore we should be familiar with the suspension and have concern about its usage rather than just using return(the last suspension).","title":"Return overview"},{"location":"features/return-overview/#references","text":"N4820 Working Draft N4736 Working Draft","title":"References"},{"location":"features/return-overview/#background","text":"One of the entry barriers for the coroutine function is to write a return type. The return type's promise_type must fulfills the Coroutine Promise Requirement (Actually it's coroutine_traits<R>::promise_type , but just let me skip the detail for now). To save your time, start with the article of Lewiss Baker . I also wrote about it with N4402 , and with my talk in C++ Korea (see the page 60) . In my opinion, N4402 was short enough and explains well about the role of those requirements.","title":"Background"},{"location":"features/return-overview/#contents","text":"Currently, this library provides 2 types. #include <coroutine/return.h> using namespace coro ; no_return frame You may noticed that there is no task<T> . I don't have a plan to support the type for 2 reasons. To encourage use of https://github.com/lewissbaker/cppcoro which already implemented it To encourage use of the suspension( co_await and co_yield ) insead of the return( co_return ) In my perspective, the coroutine is a routine with multiple entry points and multiple suspend points. Therefore we should be familiar with the suspension and have concern about its usage rather than just using return(the last suspension).","title":"Contents"},{"location":"features/yield-enumerable/","text":"Generator with the coroutine See Also <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck enumerable<T> This is an implementation of the 'Coroutine-based Generator' concept. However, because of some known implementations, the name can be considered as a reserved one. In this library, the impl is is named as enumerable . Even though there are existing implementations like the generator of VC++, I had to write my own one to test coroutine_handle<void> because the type is compiler-dependent. If you're clang/libc++ user, you can use mine or generator of the cppcoro . template < typename T > class enumerable final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; enumerable contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements. Template Parameters T : The type of element in the enumerable. Default Operations Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class enumerable final { public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( promise_type * ptr ) noexcept ; ~ enumerable () noexcept ; }; Coroutine frame for the generator follows RAII. So it will destroy its handle in destructor. Functions The type supports ranged- for statment. Function Description begin Start fetching elements until co_return . end End of the enumerable. template < typename T > class enumerable final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; }; Type: promise_type The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the generator coroutine yield_value Yield the given element and allow its consumer to access it Remark It only takes lvalue reference( T& ) for the operand of co_yield . template < typename T > class enumerable final { public : class promise_type final { public : auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; auto yield_value ( reference ref ) noexcept ; void return_void () noexcept ; void unhandled_exception () noexcept ; promise_type * get_return_object () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; Type: iterator Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent misusage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Also, as an iterator type, it supports * , -> , == , != . template < typename T > class enumerable final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; }; Examples You can see the usage with test codes. Use of co_yield What if the function yields 0-time? Move Semantics Iteration std::accumulate std::max_element","title":"Yield enumerable"},{"location":"features/yield-enumerable/#see-also","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"See Also"},{"location":"features/yield-enumerable/#enumerablelttgt","text":"This is an implementation of the 'Coroutine-based Generator' concept. However, because of some known implementations, the name can be considered as a reserved one. In this library, the impl is is named as enumerable . Even though there are existing implementations like the generator of VC++, I had to write my own one to test coroutine_handle<void> because the type is compiler-dependent. If you're clang/libc++ user, you can use mine or generator of the cppcoro . template < typename T > class enumerable final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; enumerable contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements.","title":"enumerable&lt;T&gt;"},{"location":"features/yield-enumerable/#template-parameters","text":"T : The type of element in the enumerable.","title":"Template Parameters"},{"location":"features/yield-enumerable/#default-operations","text":"Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class enumerable final { public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( promise_type * ptr ) noexcept ; ~ enumerable () noexcept ; }; Coroutine frame for the generator follows RAII. So it will destroy its handle in destructor.","title":"Default Operations"},{"location":"features/yield-enumerable/#functions","text":"The type supports ranged- for statment. Function Description begin Start fetching elements until co_return . end End of the enumerable. template < typename T > class enumerable final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; };","title":"Functions"},{"location":"features/yield-enumerable/#type-promise_type","text":"The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the generator coroutine yield_value Yield the given element and allow its consumer to access it","title":"Type: promise_type"},{"location":"features/yield-enumerable/#remark","text":"It only takes lvalue reference( T& ) for the operand of co_yield . template < typename T > class enumerable final { public : class promise_type final { public : auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; auto yield_value ( reference ref ) noexcept ; void return_void () noexcept ; void unhandled_exception () noexcept ; promise_type * get_return_object () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; };","title":"Remark"},{"location":"features/yield-enumerable/#type-iterator","text":"Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent misusage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Also, as an iterator type, it supports * , -> , == , != . template < typename T > class enumerable final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Type: iterator"},{"location":"features/yield-enumerable/#examples","text":"You can see the usage with test codes. Use of co_yield What if the function yields 0-time? Move Semantics Iteration std::accumulate std::max_element","title":"Examples"},{"location":"features/yield-overview/","text":"#include <coroutine/yield.hpp> using namespace coro ; References <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck Background I strongly recomment the last two materials. Andreas Reischuck's explanation will be a good time saver for you. ToDo: The essense of co_yield ? Contents enumerable<T> sequence<T>","title":"Yield overview"},{"location":"features/yield-overview/#references","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"References"},{"location":"features/yield-overview/#background","text":"I strongly recomment the last two materials. Andreas Reischuck's explanation will be a good time saver for you. ToDo: The essense of co_yield ?","title":"Background"},{"location":"features/yield-overview/#contents","text":"enumerable<T> sequence<T>","title":"Contents"},{"location":"features/yield-sequence/","text":"Generator + Async Iterator See Also <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck sequence<T> sequence is an abstraction for the async generator. It is not named async_generator to imply that it's just one implementation of the concept. This type should be used carefully . It is not recommended in general, and there might be a bug(failure) on release mode with clang compiler . Contrary to that, MSVC works well with the optimization flag . template < typename T > class sequence final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; sequence contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements. Template Parameters T : the type of element in the sequence. Default Operations Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class sequence final { public : sequence ( sequence & ) = delete ; sequence & operator = ( sequence & ) = delete ; sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; It is expected that the user code will destroy the coroutine frame of the sequence manually . This is inconvenient but must be ensured like the following example. TEST_CASE ( \"async_generator\" , \"[generic]\" ) { using namespace std :: experimental ; // for async generator, // its coroutine frame must be alive for some case. return_frame frame {}; auto ensure_destroy_frame = gsl :: finally ([ = ]() { if ( auto coro = static_cast < coroutine_handle < void >> ( frame )) coro . destroy (); }); SECTION ( \"yield once\" ) { auto example = []() -> sequence < int > { int v = 333 ; co_yield v ; co_return ; }; auto use_sequence = [ = ]( int & ref ) -> return_frame { for co_await ( int v : example ()) ref = v ; co_return ; }; int value = 0 ; REQUIRE_NOTHROW ( frame = use_sequence ( value )); REQUIRE ( value == 333 ); } // ... } Functions Function Description begin Start the sequence coroutine and fetch elements until co_yield receives some awaitable. end End of the sequence. template < typename T > class sequence final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; }; Type: promise_type The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the sequence coroutine yield_value<Awaitable> Trigger suspend until the given Awaitable is resumed. yield_value Yield the given element and notify to consumer coroutine When the next element is unavailable, programmer suspend it by co_yield ing an awaitable. The promise_type allows to distinguish between the new element and programmer's awaitable by using itself as an awaitable. Function Description await_ready true if consumer is waiting for the sequence coroutine. await_suspend Save the sequence coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (user of the sequence ). template < typename T > class sequence final { public : class promise_type final { public : void unhandled_exception () noexcept ; auto get_return_object () noexcept -> promise_type * ; auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; promise_type & yield_value ( reference ref ) noexcept ; template < typename Awaitable > Awaitable & yield_value ( Awaitable && a ) noexcept ; void return_void () noexcept ; bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; void await_resume () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; Type: iterator Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Like normal iterator types, it supports * , -> , == , != . However, the iterator itself is an awaitable . Function Description await_ready false if the element is not available. true for the other case. await_suspend Save the current coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (this). template < typename T > class sequence final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; iterator & await_resume () noexcept ; reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; }; Examples You can see the usage with test codes. Use of co_yield with awaitable What if the function yields 0-time? Destruction Frame's status Iteration Suspend with co_await Suspend with co_yield See Also In this library: Type frame","title":"Yield sequence"},{"location":"features/yield-sequence/#see-also","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"See Also"},{"location":"features/yield-sequence/#sequencelttgt","text":"sequence is an abstraction for the async generator. It is not named async_generator to imply that it's just one implementation of the concept. This type should be used carefully . It is not recommended in general, and there might be a bug(failure) on release mode with clang compiler . Contrary to that, MSVC works well with the optimization flag . template < typename T > class sequence final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; sequence contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements.","title":"sequence&lt;T&gt;"},{"location":"features/yield-sequence/#template-parameters","text":"T : the type of element in the sequence.","title":"Template Parameters"},{"location":"features/yield-sequence/#default-operations","text":"Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class sequence final { public : sequence ( sequence & ) = delete ; sequence & operator = ( sequence & ) = delete ; sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; It is expected that the user code will destroy the coroutine frame of the sequence manually . This is inconvenient but must be ensured like the following example. TEST_CASE ( \"async_generator\" , \"[generic]\" ) { using namespace std :: experimental ; // for async generator, // its coroutine frame must be alive for some case. return_frame frame {}; auto ensure_destroy_frame = gsl :: finally ([ = ]() { if ( auto coro = static_cast < coroutine_handle < void >> ( frame )) coro . destroy (); }); SECTION ( \"yield once\" ) { auto example = []() -> sequence < int > { int v = 333 ; co_yield v ; co_return ; }; auto use_sequence = [ = ]( int & ref ) -> return_frame { for co_await ( int v : example ()) ref = v ; co_return ; }; int value = 0 ; REQUIRE_NOTHROW ( frame = use_sequence ( value )); REQUIRE ( value == 333 ); } // ... }","title":"Default Operations"},{"location":"features/yield-sequence/#functions","text":"Function Description begin Start the sequence coroutine and fetch elements until co_yield receives some awaitable. end End of the sequence. template < typename T > class sequence final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; };","title":"Functions"},{"location":"features/yield-sequence/#type-promise_type","text":"The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the sequence coroutine yield_value<Awaitable> Trigger suspend until the given Awaitable is resumed. yield_value Yield the given element and notify to consumer coroutine When the next element is unavailable, programmer suspend it by co_yield ing an awaitable. The promise_type allows to distinguish between the new element and programmer's awaitable by using itself as an awaitable. Function Description await_ready true if consumer is waiting for the sequence coroutine. await_suspend Save the sequence coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (user of the sequence ). template < typename T > class sequence final { public : class promise_type final { public : void unhandled_exception () noexcept ; auto get_return_object () noexcept -> promise_type * ; auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; promise_type & yield_value ( reference ref ) noexcept ; template < typename Awaitable > Awaitable & yield_value ( Awaitable && a ) noexcept ; void return_void () noexcept ; bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; void await_resume () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; };","title":"Type: promise_type"},{"location":"features/yield-sequence/#type-iterator","text":"Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Like normal iterator types, it supports * , -> , == , != . However, the iterator itself is an awaitable . Function Description await_ready false if the element is not available. true for the other case. await_suspend Save the current coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (this). template < typename T > class sequence final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; iterator & await_resume () noexcept ; reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Type: iterator"},{"location":"features/yield-sequence/#examples","text":"You can see the usage with test codes. Use of co_yield with awaitable What if the function yields 0-time? Destruction Frame's status Iteration Suspend with co_await Suspend with co_yield","title":"Examples"},{"location":"features/yield-sequence/#see-also_1","text":"In this library: Type frame","title":"See Also"},{"location":"howto/build-using-cmake/","text":"How To Build: CMake Project Known Configurations? This library relies on various CI services. I'm testing the build with the multiple config files. Just follow those files and compare with the build log. It won't be that hard :) You can create an issue (of course PR will be wellcomed!) if you can't try one of them. Also, if you think some complex configuration must be tested (for your development!), let me know with the issue! Ubuntu Linux Travis CI : dist: xenial Azure Pipelines : ubuntu-16.04 AppVeyor : Ubuntu 18.04 I'm testing with Ubuntu distribution because it's the CI services above uses them. I think build test with Docker might be possible. The option is reserved for really complex conditions. Installing libc++ By default the environment won't have libc++. We need it to use <experimental/coroutine> . This library has a custom implementation so it can deal with the problem, but it is obvious that installing libc++ is more helpful and practical. Review this script file and run the installation with sudo . # suppose you are in coroutine/ sudo bash ./scripts/install-libc++8.sh ; Android Travis CI : language: android I'm considering to deprecate Android build with NDK because of the CMake version in it :( Mac OS Azure Pipelines : macos-latest iPhone OS Travis CI : osx_image: xcode10.1 Special thanks to https://github.com/leetal/ios-cmake !!! Windows Azure Pipelines : Visual Studio 2017 AppVeyor : Visual Studio 2017, 2019 You can try with the Visual Studio. But it's a Cross-Platform Make! How can I ignore the charming OS? Well, the configuration for the Windows OS is a bit special. It supports Clang-cl build. Visual Studio Just set the Generator as Visual Studio. git clone https : // github . com / luncliff / coroutine Push-Location coroutine ; cmake .. -G \"Visual Studio 15 2017 Win64\" -DUSE_PORTABLE_HEADER = \"true\" Pop-Location ; LLVM Clang-cl Currently, I recommend static build for clang-cl . But the DLL build is also available for current master branch. To do so, please reference the AppVeyor build steps . Install Chocolatey & Required Packages Chocolatey can be installed easily. Follow guide of the official page . We need 2 packages. choco install -y ninja ; choco install -y llvm ; After the installation, don't forget to check the version $ ninja --version ... $ choco info llvm ... The clang-cl will invoke the clang appropriately . So if clang-cl works well, then all setup is done correctly. $ clang-cl --version ...","title":"CMake"},{"location":"howto/build-using-cmake/#how-to-build-cmake-project","text":"","title":"How To Build: CMake Project"},{"location":"howto/build-using-cmake/#known-configurations","text":"This library relies on various CI services. I'm testing the build with the multiple config files. Just follow those files and compare with the build log. It won't be that hard :) You can create an issue (of course PR will be wellcomed!) if you can't try one of them. Also, if you think some complex configuration must be tested (for your development!), let me know with the issue!","title":"Known Configurations?"},{"location":"howto/build-using-cmake/#ubuntu-linux","text":"Travis CI : dist: xenial Azure Pipelines : ubuntu-16.04 AppVeyor : Ubuntu 18.04 I'm testing with Ubuntu distribution because it's the CI services above uses them. I think build test with Docker might be possible. The option is reserved for really complex conditions.","title":"Ubuntu Linux"},{"location":"howto/build-using-cmake/#installing-libc","text":"By default the environment won't have libc++. We need it to use <experimental/coroutine> . This library has a custom implementation so it can deal with the problem, but it is obvious that installing libc++ is more helpful and practical. Review this script file and run the installation with sudo . # suppose you are in coroutine/ sudo bash ./scripts/install-libc++8.sh ;","title":"Installing libc++"},{"location":"howto/build-using-cmake/#android","text":"Travis CI : language: android I'm considering to deprecate Android build with NDK because of the CMake version in it :(","title":"Android"},{"location":"howto/build-using-cmake/#mac-os","text":"Azure Pipelines : macos-latest","title":"Mac OS"},{"location":"howto/build-using-cmake/#iphone-os","text":"Travis CI : osx_image: xcode10.1 Special thanks to https://github.com/leetal/ios-cmake !!!","title":"iPhone OS"},{"location":"howto/build-using-cmake/#windows","text":"Azure Pipelines : Visual Studio 2017 AppVeyor : Visual Studio 2017, 2019 You can try with the Visual Studio. But it's a Cross-Platform Make! How can I ignore the charming OS? Well, the configuration for the Windows OS is a bit special. It supports Clang-cl build.","title":"Windows"},{"location":"howto/build-using-cmake/#visual-studio","text":"Just set the Generator as Visual Studio. git clone https : // github . com / luncliff / coroutine Push-Location coroutine ; cmake .. -G \"Visual Studio 15 2017 Win64\" -DUSE_PORTABLE_HEADER = \"true\" Pop-Location ;","title":"Visual Studio"},{"location":"howto/build-using-cmake/#llvm-clang-cl","text":"Currently, I recommend static build for clang-cl . But the DLL build is also available for current master branch. To do so, please reference the AppVeyor build steps .","title":"LLVM Clang-cl"},{"location":"howto/build-using-cmake/#install-chocolatey-required-packages","text":"Chocolatey can be installed easily. Follow guide of the official page . We need 2 packages. choco install -y ninja ; choco install -y llvm ; After the installation, don't forget to check the version $ ninja --version ... $ choco info llvm ... The clang-cl will invoke the clang appropriately . So if clang-cl works well, then all setup is done correctly. $ clang-cl --version ...","title":"Install Chocolatey &amp; Required Packages"},{"location":"howto/build-using-visualstudio/","text":"How To Build: Visual Studio Before Build ... Check the Windows SDK and Visual Studio Tool/Compiler/Platform are listed in the 1.4.2 release note's 'Support' section . Visual Studio 2017, 2019 msvc : vc141, vc142 CMake (3.14 or later) clang-cl : 7.0.1, 8.0 Windows SDK 10.0.17134 10.0.14393 The list will be updated for every release. And the maintenance of those configs are top priority because it is the baseline for the purpose of this repo. You know, if you can't build & run this repo, how can people try the feature? Never hesitate to create a new issue for your configuration . Follow the steps! Clone the repo and submodules Nothing special. git clone + git submodule will do the work! PS D:\\> git clone https://github.com/luncliff/coroutine PS D:\\> cd .\\coroutine\\ PS D:\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/coroutine/external/guideline'... Cloning into 'D:/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' Open the Visual Studio Assuming you are using PowerShell. If not, just double-click the coroutine.sln . PS D:\\coroutine> Invoke-Item .\\coroutine.sln The solution file includes 1 DLL project and the others are Visual Studio Native Test projects. And don't forget that this project is only for x64 . The x86 arch is supported by MSVC, but it's not in the maintenance plan for now. Review the modules/windows.vcxproj Mostly you have to change Windows SDK Version that you are going to use. As far as I know, you don't need to touch the other settings. However, try the combinations and bother the VC++ team :D (not me!) Try The Build/Test! Press Ctrl + Shift + B to start the solution build. Afther the first build is done, open the 'Test Explorer' and run the tests. If the test runs well, it's done! The network test might fail because of permission or firewall issue. Or you can't sure about the reason, please, create an issue. The library still needs more tests. If all tests fail immediately, it must be the issue of the test execution. Check the 'Test > Test Settings > Default Processor Architecture'. Select the x64 .","title":"Visual Studio"},{"location":"howto/build-using-visualstudio/#how-to-build-visual-studio","text":"","title":"How To Build: Visual Studio"},{"location":"howto/build-using-visualstudio/#before-build","text":"","title":"Before Build ..."},{"location":"howto/build-using-visualstudio/#check-the-windows-sdk-and-visual-studio","text":"Tool/Compiler/Platform are listed in the 1.4.2 release note's 'Support' section . Visual Studio 2017, 2019 msvc : vc141, vc142 CMake (3.14 or later) clang-cl : 7.0.1, 8.0 Windows SDK 10.0.17134 10.0.14393 The list will be updated for every release. And the maintenance of those configs are top priority because it is the baseline for the purpose of this repo. You know, if you can't build & run this repo, how can people try the feature? Never hesitate to create a new issue for your configuration .","title":"Check the Windows SDK and Visual Studio"},{"location":"howto/build-using-visualstudio/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"howto/build-using-visualstudio/#clone-the-repo-and-submodules","text":"Nothing special. git clone + git submodule will do the work! PS D:\\> git clone https://github.com/luncliff/coroutine PS D:\\> cd .\\coroutine\\ PS D:\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/coroutine/external/guideline'... Cloning into 'D:/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a'","title":"Clone the repo and submodules"},{"location":"howto/build-using-visualstudio/#open-the-visual-studio","text":"Assuming you are using PowerShell. If not, just double-click the coroutine.sln . PS D:\\coroutine> Invoke-Item .\\coroutine.sln The solution file includes 1 DLL project and the others are Visual Studio Native Test projects. And don't forget that this project is only for x64 . The x86 arch is supported by MSVC, but it's not in the maintenance plan for now.","title":"Open the Visual Studio"},{"location":"howto/build-using-visualstudio/#review-the-moduleswindowsvcxproj","text":"Mostly you have to change Windows SDK Version that you are going to use. As far as I know, you don't need to touch the other settings. However, try the combinations and bother the VC++ team :D (not me!)","title":"Review the modules/windows.vcxproj"},{"location":"howto/build-using-visualstudio/#try-the-buildtest","text":"Press Ctrl + Shift + B to start the solution build. Afther the first build is done, open the 'Test Explorer' and run the tests. If the test runs well, it's done! The network test might fail because of permission or firewall issue. Or you can't sure about the reason, please, create an issue. The library still needs more tests. If all tests fail immediately, it must be the issue of the test execution. Check the 'Test > Test Settings > Default Processor Architecture'. Select the x64 .","title":"Try The Build/Test!"},{"location":"howto/import-using-cmake/","text":"How To Import: CMake Project Package Support? Does this library support any package manager? Actually, you don't have to use package manager for this libary. git submodule + add_subdirectory will be work well! Try with the Vcpkg This repository is registered as package coroutine in microsoft/vcpkg . Try the awesome tool! $ vcpkg install coroutine The following packages will be built and installed: coroutine[core]:x64-osx Starting package 1/1: coroutine:x64-osx Building package coroutine[core]:x64-osx... -- ... The package coroutine:x64-osx provides CMake targets: find_package(coroutine CONFIG REQUIRED) target_link_libraries(main PRIVATE coroutine) Follow the steps! Check your environment If you didn't checked your project's configuration, please do review this document first . Currently the library expects CMake 3.8 or later, which supports C++ 17 for CXX_STANDARD . You don't have to check yourself since CMake will do that. Just be aware of it. cmake_minimum_required ( VERSION 3.8 ) Installing GSL(Guideline Support Library) The GSL is a header-only and light-weighted library. You can just use git clone it and import easily. cmake /path/to/project -DGSL_INCLUDE_DIR = /path/to/gsl/include Call add_subdirectory Suppose your project's file tree is like the following. Notice that the project submodules GSL already . So mostly you don't have to manage GSL_INCLUDE_DIR manually. Let the command git submodule will do the work for you. $ git submodule update --init --recursive ... However this document will assume you wanted to use custom path. $ tree -L 2 /path/to/project /path/to/project \u251c\u2500\u2500 CMakeLists.txt \u251c... \u251c\u2500\u2500 gsl # <-- already placed GSL at your path \u2502 \u251c... \u2502 \u2514... \u251c\u2500\u2500 coroutine # <-- you submoduled this library \u2502 \u251c... \u2502 \u2514... \u251c... \u2514... In your CMakeLists.txt, call add_subdirectory . # if you submoduled the coroutine's master branch, # you don't have to set this cmake variable. set ( GSL_INCLUDE_DIR ${ CMAKE_CURRENT_SOURCE_DIR } /gsl/include ) add_subdirectory ( coroutine ) Test will be skipped automatically The library won't build test codes unless it is not a root project . Since you're using add_subdirectory , they will be skipped for your build time! # See the `coroutine/CMakeLists.txt` if ( TEST_DISABLED ) message ( STATUS \"Test is disabled.\" ) return () elseif ( IOS OR ANDROID ) message ( STATUS \"Mobile cross build doesn't support tests\" ) return () elseif ( NOT ${ CMAKE_SOURCE_DIR } STREQUAL ${ CMAKE_CURRENT_SOURCE_DIR } ) message ( STATUS \"This is not a root project. Skip tests\" ) return () endif () Call target_link_libraries The library's CMake configures some PUBLIC settings. So just using target_link_libraries for it will do all the necessary work for you. Such as compiler option, dependent system libraries, etc. target_link_libraries ( your_project_name PUBLIC coroutine ) Questions & Trouble Shooting Report your troubles!","title":"CMake"},{"location":"howto/import-using-cmake/#how-to-import-cmake-project","text":"","title":"How To Import: CMake Project"},{"location":"howto/import-using-cmake/#package-support","text":"","title":"Package Support?"},{"location":"howto/import-using-cmake/#does-this-library-support-any-package-manager","text":"Actually, you don't have to use package manager for this libary. git submodule + add_subdirectory will be work well!","title":"Does this library support any package manager?"},{"location":"howto/import-using-cmake/#try-with-the-vcpkg","text":"This repository is registered as package coroutine in microsoft/vcpkg . Try the awesome tool! $ vcpkg install coroutine The following packages will be built and installed: coroutine[core]:x64-osx Starting package 1/1: coroutine:x64-osx Building package coroutine[core]:x64-osx... -- ... The package coroutine:x64-osx provides CMake targets: find_package(coroutine CONFIG REQUIRED) target_link_libraries(main PRIVATE coroutine)","title":"Try with the Vcpkg"},{"location":"howto/import-using-cmake/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"howto/import-using-cmake/#check-your-environment","text":"If you didn't checked your project's configuration, please do review this document first . Currently the library expects CMake 3.8 or later, which supports C++ 17 for CXX_STANDARD . You don't have to check yourself since CMake will do that. Just be aware of it. cmake_minimum_required ( VERSION 3.8 )","title":"Check your environment"},{"location":"howto/import-using-cmake/#installing-gslguideline-support-library","text":"The GSL is a header-only and light-weighted library. You can just use git clone it and import easily. cmake /path/to/project -DGSL_INCLUDE_DIR = /path/to/gsl/include","title":"Installing GSL(Guideline Support Library)"},{"location":"howto/import-using-cmake/#call-add_subdirectory","text":"Suppose your project's file tree is like the following. Notice that the project submodules GSL already . So mostly you don't have to manage GSL_INCLUDE_DIR manually. Let the command git submodule will do the work for you. $ git submodule update --init --recursive ... However this document will assume you wanted to use custom path. $ tree -L 2 /path/to/project /path/to/project \u251c\u2500\u2500 CMakeLists.txt \u251c... \u251c\u2500\u2500 gsl # <-- already placed GSL at your path \u2502 \u251c... \u2502 \u2514... \u251c\u2500\u2500 coroutine # <-- you submoduled this library \u2502 \u251c... \u2502 \u2514... \u251c... \u2514... In your CMakeLists.txt, call add_subdirectory . # if you submoduled the coroutine's master branch, # you don't have to set this cmake variable. set ( GSL_INCLUDE_DIR ${ CMAKE_CURRENT_SOURCE_DIR } /gsl/include ) add_subdirectory ( coroutine )","title":"Call add_subdirectory"},{"location":"howto/import-using-cmake/#test-will-be-skipped-automatically","text":"The library won't build test codes unless it is not a root project . Since you're using add_subdirectory , they will be skipped for your build time! # See the `coroutine/CMakeLists.txt` if ( TEST_DISABLED ) message ( STATUS \"Test is disabled.\" ) return () elseif ( IOS OR ANDROID ) message ( STATUS \"Mobile cross build doesn't support tests\" ) return () elseif ( NOT ${ CMAKE_SOURCE_DIR } STREQUAL ${ CMAKE_CURRENT_SOURCE_DIR } ) message ( STATUS \"This is not a root project. Skip tests\" ) return () endif ()","title":"Test will be skipped automatically"},{"location":"howto/import-using-cmake/#call-target_link_libraries","text":"The library's CMake configures some PUBLIC settings. So just using target_link_libraries for it will do all the necessary work for you. Such as compiler option, dependent system libraries, etc. target_link_libraries ( your_project_name PUBLIC coroutine )","title":"Call target_link_libraries"},{"location":"howto/import-using-cmake/#questions-trouble-shooting","text":"Report your troubles!","title":"Questions &amp; Trouble Shooting"},{"location":"howto/import-using-visualstudio/","text":"How To Import: Visual Studio Before Import ... Check the Windows SDK and Visual Studio ! The coroutine.sln file might be accessing with the wrong version. Or the different version of the Visual Studio can bother you. Try the build first . If the step fails, please create a new issue ! I tested with the following configurations Visual Studio 2017 (v141, 15.12+) 10.0.14393: AppVeyor 10.0.17134 ... Visual Studio 2019 (v142, ...) 10.0.17134 ... Follow the steps! Create a new C++ Solution/Project Of course, the first step is to create importing Project. Open your Visual Studio and create a new VC++ Solution (or project, whatever). Then clone the repository. master branch will be ok. Also, you have to fetch submodules. PS D:\\ConsoleApp\\ConsoleApplication1> git clone https://github.com/luncliff/coroutine PS D:\\ConsoleApp\\ConsoleApplication1> cd .\\coroutine\\ PS D:\\ConsoleApp\\ConsoleApplication1\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/guideline'... Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' After the clone, the folder should be like the following. Let's open the VS and keep going. :) Import VC++ Project We're going to add this library's windows project to the solution. Oh, never forget the x64 platform config! This library doesn't target x86 . The arch is supported by MSVC, but it's not in the maintenance plan for now. Add Existing Project If you cloned the library like the above, you can find it after browsing the workspace. After import, open the Properties page and check the configruation. Change the 'Windows SDK Version' to installed one that you are going to use. It matters. Add Reference Now, change the reference of the ConsoleApplication1 project. Adjustment for the modules/windows.vcxproj Include Directories With basic include directories of the VC++ project, there are 3 additional paths. $(ProjectDir)..\\interface : include folder for library interfaces $(ProjectDir)..\\external\\guideline\\include : C++ Core Guideline Support Library. <gsl/gsl> $(ProjectDir) : internal codes So we have to inherit 2 paths in our new project( ConsoleApplication1 ). After changing the 'Additional Include Directories', update the code like the follwing. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types int main ( int , char * []) { std :: cout << \"Hello Coroutine! \\n \" ; return 0 ; } Now, try the build. (I will do that with x64|Debug ). The build must fail because we didn't changed compiler option. MSVC Compier Options To build the C++ 20 Coroutine code, we have to set the option /await . Also, the language standard C++ 17 is required( /std:c++17 or /std:c++latest ). In case of the coroutine's project, the option is just like this. <Project DefaultTargets= \"Build\" ToolsVersion= \"15.0\" xmlns= \"http://schemas.microsoft.com/developer/msbuild/2003\" > <!-- ... --> <ItemDefinitionGroup Condition= \"'$(Configuration)|$(Platform)'=='Debug|x64'\" > <!-- ... --> <AdditionalOptions> /await %(AdditionalOptions) </AdditionalOptions> <LanguageStandard> stdcpplatest </LanguageStandard> <!-- ... --> Therefore the property of our ConsoleApplication1 need to be changed like the image. Linker Options Well, you don't have to care! :) Just try the new build. If something goes wrong, create a new issue with your screenshot and reproduction steps so I can help you. Try this example So this is our new code. The function doesn't suspend and returns nothing. It works just like normal void(void) subroutine, but it's enough to confirm our compiler supports the feature. #include <iostream> #include <gsl/gsl> #include <coroutine/return.h> // pre-defined return types using std :: experimental :: suspend_never ; using namespace coro ; // Destroy coroutine frame after co_return. // It's fire and forget manner auto no_suspend_no_return () -> forget_frame { co_await suspend_never {}; std :: cout << \"C++ Coroutines! \\n \" ; co_return ; } int main ( int , char * []) { no_suspend_no_return (); return 0 ; } You can run the code with the Compiler Explorer . Questions & Trouble Shooting Report your troubles! Build with the Clang-cl ? Wow, really? You must install the LLVM packages first. Follow this document . I'm considering VS 2019's CMake integration for Clang-cl build tutorial. I will add a new document ASAP.","title":"Visual Studio"},{"location":"howto/import-using-visualstudio/#how-to-import-visual-studio","text":"","title":"How To Import: Visual Studio"},{"location":"howto/import-using-visualstudio/#before-import","text":"","title":"Before Import ..."},{"location":"howto/import-using-visualstudio/#check-the-windows-sdk-and-visual-studio","text":"The coroutine.sln file might be accessing with the wrong version. Or the different version of the Visual Studio can bother you. Try the build first . If the step fails, please create a new issue ! I tested with the following configurations Visual Studio 2017 (v141, 15.12+) 10.0.14393: AppVeyor 10.0.17134 ... Visual Studio 2019 (v142, ...) 10.0.17134 ...","title":"Check the Windows SDK and Visual Studio !"},{"location":"howto/import-using-visualstudio/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"howto/import-using-visualstudio/#create-a-new-c-solutionproject","text":"Of course, the first step is to create importing Project. Open your Visual Studio and create a new VC++ Solution (or project, whatever). Then clone the repository. master branch will be ok. Also, you have to fetch submodules. PS D:\\ConsoleApp\\ConsoleApplication1> git clone https://github.com/luncliff/coroutine PS D:\\ConsoleApp\\ConsoleApplication1> cd .\\coroutine\\ PS D:\\ConsoleApp\\ConsoleApplication1\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/guideline'... Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' After the clone, the folder should be like the following. Let's open the VS and keep going. :)","title":"Create a new C++ Solution/Project"},{"location":"howto/import-using-visualstudio/#import-vc-project","text":"We're going to add this library's windows project to the solution. Oh, never forget the x64 platform config! This library doesn't target x86 . The arch is supported by MSVC, but it's not in the maintenance plan for now.","title":"Import VC++ Project"},{"location":"howto/import-using-visualstudio/#add-existing-project","text":"If you cloned the library like the above, you can find it after browsing the workspace. After import, open the Properties page and check the configruation. Change the 'Windows SDK Version' to installed one that you are going to use. It matters.","title":"Add Existing Project"},{"location":"howto/import-using-visualstudio/#add-reference","text":"Now, change the reference of the ConsoleApplication1 project.","title":"Add Reference"},{"location":"howto/import-using-visualstudio/#adjustment-for-the-moduleswindowsvcxproj","text":"","title":"Adjustment for the modules/windows.vcxproj"},{"location":"howto/import-using-visualstudio/#include-directories","text":"With basic include directories of the VC++ project, there are 3 additional paths. $(ProjectDir)..\\interface : include folder for library interfaces $(ProjectDir)..\\external\\guideline\\include : C++ Core Guideline Support Library. <gsl/gsl> $(ProjectDir) : internal codes So we have to inherit 2 paths in our new project( ConsoleApplication1 ). After changing the 'Additional Include Directories', update the code like the follwing. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types int main ( int , char * []) { std :: cout << \"Hello Coroutine! \\n \" ; return 0 ; } Now, try the build. (I will do that with x64|Debug ). The build must fail because we didn't changed compiler option.","title":"Include Directories"},{"location":"howto/import-using-visualstudio/#msvc-compier-options","text":"To build the C++ 20 Coroutine code, we have to set the option /await . Also, the language standard C++ 17 is required( /std:c++17 or /std:c++latest ). In case of the coroutine's project, the option is just like this. <Project DefaultTargets= \"Build\" ToolsVersion= \"15.0\" xmlns= \"http://schemas.microsoft.com/developer/msbuild/2003\" > <!-- ... --> <ItemDefinitionGroup Condition= \"'$(Configuration)|$(Platform)'=='Debug|x64'\" > <!-- ... --> <AdditionalOptions> /await %(AdditionalOptions) </AdditionalOptions> <LanguageStandard> stdcpplatest </LanguageStandard> <!-- ... --> Therefore the property of our ConsoleApplication1 need to be changed like the image.","title":"MSVC Compier Options"},{"location":"howto/import-using-visualstudio/#linker-options","text":"Well, you don't have to care! :) Just try the new build. If something goes wrong, create a new issue with your screenshot and reproduction steps so I can help you.","title":"Linker Options"},{"location":"howto/import-using-visualstudio/#try-this-example","text":"So this is our new code. The function doesn't suspend and returns nothing. It works just like normal void(void) subroutine, but it's enough to confirm our compiler supports the feature. #include <iostream> #include <gsl/gsl> #include <coroutine/return.h> // pre-defined return types using std :: experimental :: suspend_never ; using namespace coro ; // Destroy coroutine frame after co_return. // It's fire and forget manner auto no_suspend_no_return () -> forget_frame { co_await suspend_never {}; std :: cout << \"C++ Coroutines! \\n \" ; co_return ; } int main ( int , char * []) { no_suspend_no_return (); return 0 ; } You can run the code with the Compiler Explorer .","title":"Try this example"},{"location":"howto/import-using-visualstudio/#questions-trouble-shooting","text":"Report your troubles!","title":"Questions &amp; Trouble Shooting"},{"location":"howto/import-using-visualstudio/#build-with-the-clang-cl","text":"Wow, really? You must install the LLVM packages first. Follow this document . I'm considering VS 2019's CMake integration for Clang-cl build tutorial. I will add a new document ASAP.","title":"Build with the Clang-cl ?"},{"location":"howto/start-using-cmake/","text":"How To Start: CMake Welcome! Well, this part is not about CMake's usage, nor setup of the CMake for your environment. I'd like to give the minimum CMake example for your project here. CMake's Version ? At this moment(2019), I recommend you to use at least CMake 3.8 or later. The version is allows you to specify 17 for the CXX_STANDARD property(It will be commented). But that's not the necessary step . Indeed the key part not the cmake but the compiler itself! If you already aware of your developer environment, forget about that recommendation! For the examples below, I will keep specifing flags related to C++ standard. Unless you are in some complicated situation, just 3.x will be fine. Library: Header-Only coroutine_portable is the only interface target in this example project. If you prefer to write header-only style codes, simply designating the path and flags will be enough. cmake_minimum_requried ( VERSION 3.6 ) # start a project. # defines cmake variables like PROJECT_NAME and PROJECT_SOURCE_DIR project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_headers INTERFACE ) set_target_properties ( my_coroutine_headers PROPERTIES # macro defintions INTERFACE_COMPILE_DEFINITIONS \"${CMAKE_SYSTEM_NAME}\" ) message ( STATUS \"macro defined: ${CMAKE_SYSTEM_NAME}\" ) # header include path target_include_directories ( my_coroutine_headers INTERFACE # path for `add_subdirectoy` $< BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include > # path after installation ( cmake --build . --target install ) $< INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include > ) Dealing with the compilers and their flags I strongly recommend to define compile options together so CMake can propagate them and reduce redundant compile option definitons in 'CMakeLists.txt' or '*.cmake' files. To do that, you have to check compiler. if ( ${ CMAKE_CXX_COMPILER_ID } MATCHES Clang ) if ( WIN32 ) # clang-cl for windows target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest -fms-compatibility -Xclang -fcoroutines-ts ) # for multiple definitions, you can do like this set_target_properties ( my_coroutine_headers PROPERTIES INTERFACE_COMPILE_DEFINITIONS \"CLANG_CL;_RESUMABLE_FUNCTIONS_SUPPORTED\" ) elseif ( UNIX OR APPLE ) # Clang or AppleClang target_compile_options ( my_coroutine_headers INTERFACE -std=c++2a -stdlib=libc++ -fcoroutines-ts ) endif () elseif ( MSVC ) target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest /await ) elseif ( ${ CMAKE_CXX_COMPILER_ID } MATCHES GNU ) target_compile_options ( my_coroutine_headers INTERFACE -std=gnu++2a -fcoroutines -fno-exceptions ) endif () Notice that I placed Clang ahead of MSVC. Even though clang-cl is specified with CMAKE_CXX_COMPILER , the CMake branch into the MSVC scope. In ohter words, it behaves like it's reusing WIN32 for the variable. So to be precise you always have to check the compiler familiy is clang. Library The only difference is that you have to list your source/header files in add_libary . cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_lib # ... list of source files in relative path ... # ... libmain.cpp ) set_target_properties ( my_coroutine_lib PROPERTIES CXX_STANDARD 14 # for CMake 3.8, you can use '17' here # for CMake 3.14, it can be '20' ) If some source files are platform dependent or requires some condition, use target_source function. if ( WIN32 ) target_source ( my_coroutine_lib PRIVATE impl_windows.cpp ) elseif ( APPLE ) target_source ( my_coroutine_lib PRIVATE impl_darwin.cpp ) elseif ( UNIX ) target_source ( my_coroutine_lib PRIVATE impl_unix.cpp ) endif () Since I already showed how to use compiler flags for C++ Coroutines, you can just copy & paste the part. The other way is to use target_link_libraries function, and inherit those 'interface' or 'public' compiler options. # PUBLIC: propagate these library dependencies # PRIVATE: consume and hide those dependencies target_link_libraries ( my_coroutine_lib PUBLIC my_coroutine_headers ) Isn't it simple? In this project, coroutine_event is defined like this. Executable If you already created some targets with add_library , the only thing you have to do is define an executable and to link it with the library. cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_executable ( my_coroutine_exe # ... list of source files in relative path ... # ... main.cpp ) target_link_libraries ( my_coroutine_exe PRIVATE my_coroutine_headers my_coroutine_lib ) That's all ! If you want to know more about the CMake and its usage, I recommend these materials. https://github.com/ruslo/CGold https://cliutils.gitlab.io/modern-cmake/","title":"CMake"},{"location":"howto/start-using-cmake/#how-to-start-cmake","text":"Welcome! Well, this part is not about CMake's usage, nor setup of the CMake for your environment. I'd like to give the minimum CMake example for your project here.","title":"How To Start: CMake"},{"location":"howto/start-using-cmake/#cmakes-version","text":"At this moment(2019), I recommend you to use at least CMake 3.8 or later. The version is allows you to specify 17 for the CXX_STANDARD property(It will be commented). But that's not the necessary step . Indeed the key part not the cmake but the compiler itself! If you already aware of your developer environment, forget about that recommendation! For the examples below, I will keep specifing flags related to C++ standard. Unless you are in some complicated situation, just 3.x will be fine.","title":"CMake's Version ?"},{"location":"howto/start-using-cmake/#library-header-only","text":"coroutine_portable is the only interface target in this example project. If you prefer to write header-only style codes, simply designating the path and flags will be enough. cmake_minimum_requried ( VERSION 3.6 ) # start a project. # defines cmake variables like PROJECT_NAME and PROJECT_SOURCE_DIR project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_headers INTERFACE ) set_target_properties ( my_coroutine_headers PROPERTIES # macro defintions INTERFACE_COMPILE_DEFINITIONS \"${CMAKE_SYSTEM_NAME}\" ) message ( STATUS \"macro defined: ${CMAKE_SYSTEM_NAME}\" ) # header include path target_include_directories ( my_coroutine_headers INTERFACE # path for `add_subdirectoy` $< BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include > # path after installation ( cmake --build . --target install ) $< INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include > )","title":"Library: Header-Only"},{"location":"howto/start-using-cmake/#dealing-with-the-compilers-and-their-flags","text":"I strongly recommend to define compile options together so CMake can propagate them and reduce redundant compile option definitons in 'CMakeLists.txt' or '*.cmake' files. To do that, you have to check compiler. if ( ${ CMAKE_CXX_COMPILER_ID } MATCHES Clang ) if ( WIN32 ) # clang-cl for windows target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest -fms-compatibility -Xclang -fcoroutines-ts ) # for multiple definitions, you can do like this set_target_properties ( my_coroutine_headers PROPERTIES INTERFACE_COMPILE_DEFINITIONS \"CLANG_CL;_RESUMABLE_FUNCTIONS_SUPPORTED\" ) elseif ( UNIX OR APPLE ) # Clang or AppleClang target_compile_options ( my_coroutine_headers INTERFACE -std=c++2a -stdlib=libc++ -fcoroutines-ts ) endif () elseif ( MSVC ) target_compile_options ( my_coroutine_headers INTERFACE /std:c++latest /await ) elseif ( ${ CMAKE_CXX_COMPILER_ID } MATCHES GNU ) target_compile_options ( my_coroutine_headers INTERFACE -std=gnu++2a -fcoroutines -fno-exceptions ) endif () Notice that I placed Clang ahead of MSVC. Even though clang-cl is specified with CMAKE_CXX_COMPILER , the CMake branch into the MSVC scope. In ohter words, it behaves like it's reusing WIN32 for the variable. So to be precise you always have to check the compiler familiy is clang.","title":"Dealing with the compilers and their flags"},{"location":"howto/start-using-cmake/#library","text":"The only difference is that you have to list your source/header files in add_libary . cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_library ( my_coroutine_lib # ... list of source files in relative path ... # ... libmain.cpp ) set_target_properties ( my_coroutine_lib PROPERTIES CXX_STANDARD 14 # for CMake 3.8, you can use '17' here # for CMake 3.14, it can be '20' ) If some source files are platform dependent or requires some condition, use target_source function. if ( WIN32 ) target_source ( my_coroutine_lib PRIVATE impl_windows.cpp ) elseif ( APPLE ) target_source ( my_coroutine_lib PRIVATE impl_darwin.cpp ) elseif ( UNIX ) target_source ( my_coroutine_lib PRIVATE impl_unix.cpp ) endif () Since I already showed how to use compiler flags for C++ Coroutines, you can just copy & paste the part. The other way is to use target_link_libraries function, and inherit those 'interface' or 'public' compiler options. # PUBLIC: propagate these library dependencies # PRIVATE: consume and hide those dependencies target_link_libraries ( my_coroutine_lib PUBLIC my_coroutine_headers ) Isn't it simple? In this project, coroutine_event is defined like this.","title":"Library"},{"location":"howto/start-using-cmake/#executable","text":"If you already created some targets with add_library , the only thing you have to do is define an executable and to link it with the library. cmake_minimum_requried ( VERSION 3.6 ) project ( my_coroutine_example LANGUAGES CXX ) add_executable ( my_coroutine_exe # ... list of source files in relative path ... # ... main.cpp ) target_link_libraries ( my_coroutine_exe PRIVATE my_coroutine_headers my_coroutine_lib )","title":"Executable"},{"location":"howto/start-using-cmake/#thats-all","text":"If you want to know more about the CMake and its usage, I recommend these materials. https://github.com/ruslo/CGold https://cliutils.gitlab.io/modern-cmake/","title":"That's all !"},{"location":"ppt/Exploring-the-Cpp-Coroutine/","text":"Exploring the C++ Coroutine: Approach, Compiler, and Issues Note I had a presentation in C++ Korea Facebook Group 's 5th Seminar . You can download and share it :) Links PDF: Exploring The C++ Coroutine / \ud55c\uad6d\uc5b4 OneDrive: Eng / \ud55c\uad6d\uc5b4","title":"C++ Korea 5th Seminar"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#exploring-the-c-coroutine-approach-compiler-and-issues","text":"","title":"Exploring the C++ Coroutine: Approach, Compiler, and Issues"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#note","text":"I had a presentation in C++ Korea Facebook Group 's 5th Seminar . You can download and share it :)","title":"Note"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#links","text":"PDF: Exploring The C++ Coroutine / \ud55c\uad6d\uc5b4 OneDrive: Eng / \ud55c\uad6d\uc5b4","title":"Links"}]}