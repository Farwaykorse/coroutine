{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Home/","text":"Latest Release is 1.4.3 Welcome to the luncliff/coroutine wiki! Please explore the pages with this link(GitHub Pages) If you have opinion for these docs, please create an issue and claim your idea. Let me hear you and write more helpful contents. :D This example project started with the post in 2017.02 . Developer Note Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine(Eng) (\ud55c\uad6d\uc5b4) - the PDF is here! Articles Awaitable event using coroutine, epoll , and eventfd Designing the coroutine channel Combining C++ coroutines and pthread_create First with the C++ 20 Coroutines? If you're finding any bunch of good references , visit the MattPD's collection ! If you want to run it now , there is a little WandBox example ... but it's poor for now. I will write a new one and update the link ASAP. Library Features Coroutine Handle Works related to <coroutine> header are placed in 1 file. #include <coroutine/frame.h> using namespace std :: experimental ; Return Types For The Coroutine Functions Pre-defined return types with this library's namespace, coro . #include <coroutine/return.h> using namespace coro ; Yield All types for co_yield operator are placed here. #include <coroutine/yield.hpp> using namespace coro ; Channel Have you ever used the Go language? or heard about the CSP(Communicating Sequential Processes)? #include <coroutine/channel.hpp> using namespace coro ; Concept Read & Write Select Concurrency Utilities Even though the C++ coroutines doesn't require thread features, working with existing multi-threaded code is an important issue. I had to write some utilities for the purpose. #include <coroutine/concrt.h> using namespace concrt ; Awaitable Event using the coroutine, epoll , and eventfd . Network I/O The socket async I/O related features are adopting GSL(Guideline Support Library) . The types/functions in this interface don't have their namespace for now. (They are global !) #include <coroutine/net.h> // nesting <gsl/gsl> using namespace gsl ; Overview Impl note for each system's API Winsock 2 Epoll KQueue","title":"Home"},{"location":"Home/#developer-note","text":"Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine(Eng) (\ud55c\uad6d\uc5b4) - the PDF is here! Articles Awaitable event using coroutine, epoll , and eventfd Designing the coroutine channel Combining C++ coroutines and pthread_create","title":"Developer Note"},{"location":"Home/#first-with-the-c-20-coroutines","text":"If you're finding any bunch of good references , visit the MattPD's collection ! If you want to run it now , there is a little WandBox example ... but it's poor for now. I will write a new one and update the link ASAP.","title":"First with the C++ 20 Coroutines?"},{"location":"Home/#library-features","text":"","title":"Library Features"},{"location":"Home/#coroutine-handle","text":"Works related to <coroutine> header are placed in 1 file. #include <coroutine/frame.h> using namespace std :: experimental ;","title":"Coroutine Handle"},{"location":"Home/#return-types-for-the-coroutine-functions","text":"Pre-defined return types with this library's namespace, coro . #include <coroutine/return.h> using namespace coro ;","title":"Return Types For The Coroutine Functions"},{"location":"Home/#yield","text":"All types for co_yield operator are placed here. #include <coroutine/yield.hpp> using namespace coro ;","title":"Yield"},{"location":"Home/#channel","text":"Have you ever used the Go language? or heard about the CSP(Communicating Sequential Processes)? #include <coroutine/channel.hpp> using namespace coro ; Concept Read & Write Select","title":"Channel"},{"location":"Home/#concurrency-utilities","text":"Even though the C++ coroutines doesn't require thread features, working with existing multi-threaded code is an important issue. I had to write some utilities for the purpose. #include <coroutine/concrt.h> using namespace concrt ; Awaitable Event using the coroutine, epoll , and eventfd .","title":"Concurrency Utilities"},{"location":"Home/#network-io","text":"The socket async I/O related features are adopting GSL(Guideline Support Library) . The types/functions in this interface don't have their namespace for now. (They are global !) #include <coroutine/net.h> // nesting <gsl/gsl> using namespace gsl ; Overview Impl note for each system's API Winsock 2 Epoll KQueue","title":"Network I/O"},{"location":"_Footer/","text":"This work is licensed under a Creative Commons Attribution 4.0 International License .","title":" Footer"},{"location":"build-using-cmake/","text":"How To Build: CMake Project Known Configurations Did you saw the status badges in the ReadMe ? This library relies on various CI services. I'm testing the build with the following configurations. You can create an issue (of course PR will be wellcomed!) if you can't try one of them. Also, if you think some complex configuration must be tested (for your development!), let me know with the issue! Linux Azure Pipelines Travis CI I'm testing with Ubuntu distribution because it's the CI services above uses them. I think build test with Docker might be possible. The option is reserved for really complex conditions. Ubuntu Travis CI Installing libc++ By default the environment won't have libc++. We need it to use <experimental/coroutine> . This library has a custom implementation so it can deal with the problem, but it is obvious that installing libc++ is more helpful and practical. Review this script file and run the installation with sudo . # suppose you are in coroutine/ sudo bash ./scripts/install-libc++8.sh ; ToDo: can we install the latest with apt? Android Travis CI Mac OS Azure Pipelines Travis CI iPhone OS Travis CI Windows Azure Pipelines AppVeyor You can try with the Visual Studio. But it's a Cross-Platform Make! How can I ignore the charming OS? Well, the configuration for the Windows OS is a bit special. It supports Clang-cl build. Visual Studio Just set the Generator as Visual Studio. LLVM Clang-cl The build support only static build for now. The known issue for this config is that clang's symbol generation doesn't fit for Windows DLL linkage. ToDo: Detail for the failure for the Windows DLL + Clang-cl Currently, the repo uses static build for Clang-cl. Build log (AppVeyor) . Install Chocolatey & Packages Chocolatey can be installed easily. Follow the official page ! Did you finished installation? We need 2 packages. The first one is LLVM, and the other is Ninja . choco install -y ninja ; choco install -y llvm ; After the installation, don't forget to check the version $ ninja --version ... $ choco info llvm ... Notice that the build tool will invoke clang through clang-cl . $ clang-cl --version ... Invoke vcvarsall.bat Specify I prefer setting $env:CXX via console in this case. For Powershell, you can set the variable using the following command. $env:CXX = \"clang-cl\" As you can see in this file , for Cmdlet, it's a bit different. set CXX=clang-cl However, if you hate using environment variable, you can set CMAKE_C_COMPILER and CMAKE_CXX_COMPILER in CMake configuration. cmake -G \"Ninja\" -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_C_COMPILER=clang-cl","title":"CMake"},{"location":"build-using-cmake/#how-to-build-cmake-project","text":"","title":"How To Build: CMake Project"},{"location":"build-using-cmake/#known-configurations","text":"Did you saw the status badges in the ReadMe ? This library relies on various CI services. I'm testing the build with the following configurations. You can create an issue (of course PR will be wellcomed!) if you can't try one of them. Also, if you think some complex configuration must be tested (for your development!), let me know with the issue!","title":"Known Configurations"},{"location":"build-using-cmake/#linux","text":"Azure Pipelines Travis CI I'm testing with Ubuntu distribution because it's the CI services above uses them. I think build test with Docker might be possible. The option is reserved for really complex conditions.","title":"Linux"},{"location":"build-using-cmake/#ubuntu","text":"Travis CI","title":"Ubuntu"},{"location":"build-using-cmake/#installing-libc","text":"By default the environment won't have libc++. We need it to use <experimental/coroutine> . This library has a custom implementation so it can deal with the problem, but it is obvious that installing libc++ is more helpful and practical. Review this script file and run the installation with sudo . # suppose you are in coroutine/ sudo bash ./scripts/install-libc++8.sh ; ToDo: can we install the latest with apt?","title":"Installing libc++"},{"location":"build-using-cmake/#android","text":"Travis CI","title":"Android"},{"location":"build-using-cmake/#mac-os","text":"Azure Pipelines Travis CI","title":"Mac OS"},{"location":"build-using-cmake/#iphone-os","text":"Travis CI","title":"iPhone OS"},{"location":"build-using-cmake/#windows","text":"Azure Pipelines AppVeyor You can try with the Visual Studio. But it's a Cross-Platform Make! How can I ignore the charming OS? Well, the configuration for the Windows OS is a bit special. It supports Clang-cl build.","title":"Windows"},{"location":"build-using-cmake/#visual-studio","text":"Just set the Generator as Visual Studio.","title":"Visual Studio"},{"location":"build-using-cmake/#llvm-clang-cl","text":"The build support only static build for now. The known issue for this config is that clang's symbol generation doesn't fit for Windows DLL linkage. ToDo: Detail for the failure for the Windows DLL + Clang-cl Currently, the repo uses static build for Clang-cl. Build log (AppVeyor) .","title":"LLVM Clang-cl"},{"location":"build-using-cmake/#install-chocolatey-packages","text":"Chocolatey can be installed easily. Follow the official page ! Did you finished installation? We need 2 packages. The first one is LLVM, and the other is Ninja . choco install -y ninja ; choco install -y llvm ; After the installation, don't forget to check the version $ ninja --version ... $ choco info llvm ... Notice that the build tool will invoke clang through clang-cl . $ clang-cl --version ...","title":"Install Chocolatey &amp; Packages"},{"location":"build-using-cmake/#invoke-vcvarsallbat","text":"","title":"Invoke vcvarsall.bat"},{"location":"build-using-cmake/#specify","text":"I prefer setting $env:CXX via console in this case. For Powershell, you can set the variable using the following command. $env:CXX = \"clang-cl\" As you can see in this file , for Cmdlet, it's a bit different. set CXX=clang-cl However, if you hate using environment variable, you can set CMAKE_C_COMPILER and CMAKE_CXX_COMPILER in CMake configuration. cmake -G \"Ninja\" -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_C_COMPILER=clang-cl","title":"Specify"},{"location":"build-using-visualstudio/","text":"How To Build: Visual Studio Before Build ... Check the Windows SDK and Visual Studio Tool/Compiler/Platform are listed in the 1.4.2 release note's 'Support' section . Visual Studio 2017, 2019 msvc : vc141, vc142 CMake (3.14 or later) clang-cl : 7.0.1, 8.0 Windows SDK 10.0.17134 10.0.14393 The list will be updated for every release. And the maintenance of those configs are top priority because it is the baseline for the purpose of this repo. You know, if you can't build & run this repo, how can people try the feature? Never hesitate to create a new issue for your configuration . Follow the steps! Clone the repo and submodules Nothing special. git clone + git submodule will do the work! PS D:\\> git clone https://github.com/luncliff/coroutine PS D:\\> cd .\\coroutine\\ PS D:\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/coroutine/external/guideline'... Cloning into 'D:/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' Open the Visual Studio Assuming you are using PowerShell. If not, just double-click the coroutine.sln . PS D:\\coroutine> Invoke-Item .\\coroutine.sln The solution file includes 1 DLL project and the others are Visual Studio Native Test projects. And don't forget that this project is only for x64 . The x86 arch is supported by MSVC, but it's not in the maintenance plan for now. Review the modules/windows.vcxproj Mostly you have to change Windows SDK Version that you are going to use. As far as I know, you don't need to touch the other settings. However, try the combinations and bother the VC++ team :D (not me!) Try The Build/Test! Press Ctrl + Shift + B to start the solution build. Afther the first build is done, open the 'Test Explorer' and run the tests. If the test runs well, it's done! The network test might fail because of permission or firewall issue. Or you can't sure about the reason, please, create an issue. The library still needs more tests. If all tests fail immediately, it must be the issue of the test execution. Check the 'Test > Test Settings > Default Processor Architecture'. Select the x64 .","title":"Visual Studio"},{"location":"build-using-visualstudio/#how-to-build-visual-studio","text":"","title":"How To Build: Visual Studio"},{"location":"build-using-visualstudio/#before-build","text":"","title":"Before Build ..."},{"location":"build-using-visualstudio/#check-the-windows-sdk-and-visual-studio","text":"Tool/Compiler/Platform are listed in the 1.4.2 release note's 'Support' section . Visual Studio 2017, 2019 msvc : vc141, vc142 CMake (3.14 or later) clang-cl : 7.0.1, 8.0 Windows SDK 10.0.17134 10.0.14393 The list will be updated for every release. And the maintenance of those configs are top priority because it is the baseline for the purpose of this repo. You know, if you can't build & run this repo, how can people try the feature? Never hesitate to create a new issue for your configuration .","title":"Check the Windows SDK and Visual Studio"},{"location":"build-using-visualstudio/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"build-using-visualstudio/#clone-the-repo-and-submodules","text":"Nothing special. git clone + git submodule will do the work! PS D:\\> git clone https://github.com/luncliff/coroutine PS D:\\> cd .\\coroutine\\ PS D:\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/coroutine/external/guideline'... Cloning into 'D:/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a'","title":"Clone the repo and submodules"},{"location":"build-using-visualstudio/#open-the-visual-studio","text":"Assuming you are using PowerShell. If not, just double-click the coroutine.sln . PS D:\\coroutine> Invoke-Item .\\coroutine.sln The solution file includes 1 DLL project and the others are Visual Studio Native Test projects. And don't forget that this project is only for x64 . The x86 arch is supported by MSVC, but it's not in the maintenance plan for now.","title":"Open the Visual Studio"},{"location":"build-using-visualstudio/#review-the-moduleswindowsvcxproj","text":"Mostly you have to change Windows SDK Version that you are going to use. As far as I know, you don't need to touch the other settings. However, try the combinations and bother the VC++ team :D (not me!)","title":"Review the modules/windows.vcxproj"},{"location":"build-using-visualstudio/#try-the-buildtest","text":"Press Ctrl + Shift + B to start the solution build. Afther the first build is done, open the 'Test Explorer' and run the tests. If the test runs well, it's done! The network test might fail because of permission or firewall issue. Or you can't sure about the reason, please, create an issue. The library still needs more tests. If all tests fail immediately, it must be the issue of the test execution. Check the 'Test > Test Settings > Default Processor Architecture'. Select the x64 .","title":"Try The Build/Test!"},{"location":"channel-overview/","text":"Overview: Coroutine based channel This is a simplified form of channel in The Go Language . Just like this library, several C++ coroutines libraries already has their own implementation of the concept. So it might be redundant to have another implementation in this repositoty, but this is one of the very first type I've wrote after the feature becomes available. Debugging its examples will help you to enhance understanding of the coroutine and which trick can be possible. See Also Go Channel types A Tour of Go: Channels CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" If you're first with the concept, I strongly recommend you to see the talk above even though I've implemented it in a different way. Example test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp Channel with a Lockable When channel<T> is used, which means that bypass_lock is used, channel doesn't care about the race condition (NOT MT-safe). Therefore, user have to provide an appropriate Lockable type and instance if it must be MT-safe As a result, the type doesn't support copy/move since typically those operations are unavailable for Lockable objects. namespace coro { // // The channel is a stream of values. // `channel<T>` isn't MT-safe (using `bypass_lock`). // template < typename T , typename M = bypass_lock > class channel ; // There are some helper types which implements the operations template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro Channel guarantees coverage of all reader/writer coroutines in its list. When a writer found its reader , or vice versa, it resumes the other's routine and then proceeds its flow. When reader can't be matched with a writer , it attaches itself in channel just before suspend . In the same way, writer attaches itself if it couldn't find reader . Template Parameters T : An element type to deliver between reader/writer coroutines M : Must be a BasicLockable type Default Operations As mentioned above, the type can't be copied/moved. template < typename T , typename M > class channel final { public : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; channel () noexcept ( false ); ~ channel () noexcept ( false ); // !!!! }; Notice that its destructor throws exception . In the destructor, the channel resumes its pending coroutines. The destructor throws if (and only if) one of the resumed coroutines throws an exception. Member Variables Since stackless coroutines are heap-allocated, it uses linked list to those coroutines without additional allocation. Member Description reader_list linked list of reader coroutines. writer_list linked list of writer coroutines. mtx mutex to provide delivery without race between reader/writer coroutines. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); using mutex_type = M ; private : mutex_type mtx {}; public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; Functions Function Description write create a writer object for the given channel read create a reader object for the given channel template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { public : // `writer` type implements the awaitable concept decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // `reader` type implements the awaitable concept decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Overview"},{"location":"channel-overview/#overview-coroutine-based-channel","text":"This is a simplified form of channel in The Go Language . Just like this library, several C++ coroutines libraries already has their own implementation of the concept. So it might be redundant to have another implementation in this repositoty, but this is one of the very first type I've wrote after the feature becomes available. Debugging its examples will help you to enhance understanding of the coroutine and which trick can be possible.","title":"Overview: Coroutine based channel"},{"location":"channel-overview/#see-also","text":"Go Channel types A Tour of Go: Channels CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" If you're first with the concept, I strongly recommend you to see the talk above even though I've implemented it in a different way.","title":"See Also"},{"location":"channel-overview/#example","text":"test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp","title":"Example"},{"location":"channel-overview/#channel-with-a-lockable","text":"When channel<T> is used, which means that bypass_lock is used, channel doesn't care about the race condition (NOT MT-safe). Therefore, user have to provide an appropriate Lockable type and instance if it must be MT-safe As a result, the type doesn't support copy/move since typically those operations are unavailable for Lockable objects. namespace coro { // // The channel is a stream of values. // `channel<T>` isn't MT-safe (using `bypass_lock`). // template < typename T , typename M = bypass_lock > class channel ; // There are some helper types which implements the operations template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro Channel guarantees coverage of all reader/writer coroutines in its list. When a writer found its reader , or vice versa, it resumes the other's routine and then proceeds its flow. When reader can't be matched with a writer , it attaches itself in channel just before suspend . In the same way, writer attaches itself if it couldn't find reader .","title":"Channel with a Lockable"},{"location":"channel-overview/#template-parameters","text":"T : An element type to deliver between reader/writer coroutines M : Must be a BasicLockable type","title":"Template Parameters"},{"location":"channel-overview/#default-operations","text":"As mentioned above, the type can't be copied/moved. template < typename T , typename M > class channel final { public : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; channel () noexcept ( false ); ~ channel () noexcept ( false ); // !!!! }; Notice that its destructor throws exception . In the destructor, the channel resumes its pending coroutines. The destructor throws if (and only if) one of the resumed coroutines throws an exception.","title":"Default Operations"},{"location":"channel-overview/#member-variables","text":"Since stackless coroutines are heap-allocated, it uses linked list to those coroutines without additional allocation. Member Description reader_list linked list of reader coroutines. writer_list linked list of writer coroutines. mtx mutex to provide delivery without race between reader/writer coroutines. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); using mutex_type = M ; private : mutex_type mtx {}; public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Member Variables"},{"location":"channel-overview/#functions","text":"Function Description write create a writer object for the given channel read create a reader object for the given channel template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { public : // `writer` type implements the awaitable concept decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // `reader` type implements the awaitable concept decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Functions"},{"location":"channel-read_write/","text":"Current version uses helper types to use channel in a designed manner. The types implements awaitable interface that is required by co_await operator. namespace coro { template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro See Also Channel Concept Go Channel types CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" Example test/channel_read_write_mutex.cpp test/channel_write_read_mutex.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp Awaitable Channel Read Short Example using namespace coro ; template < typename T , typename M > auto read_from ( channel < T , M >& ch ) -> no_return { auto [ value , ok ] = co_await ch . read (); // you can use `std::tie` if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. } Type: reader<T, M> The type supports move operation, but it is unecessary in general. template < typename T , typename M > class reader final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ); auto await_resume () noexcept ( false ) -> std :: tuple < value_type , bool > ; }; Function Description await_ready Returns true if there is a waiting writer instance in the channel await_suspend Start waiting in the channel's reader list await_resume Resumes both writer and ifself when the read was successful. Returned tuple containes false if the channel is going to be destroyed(closed). Awaitable Channel Write Short Example using namespace coro ; template < typename T , typename M > auto write_to ( channel < T , M >& ch , T && value ) -> no_return { auto ok = co_await ch . write ( value ); // call by reference (T&) if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. } Type: writer<T, M> The type supports move operation, but it is unecessary in general. template < typename T , typename M > class writer final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > _rh ) noexcept ( false ); bool await_resume () noexcept ( false ); }; Function Description await_ready Returns true if there is a waiting reader instance in the channel await_suspend Start waiting in the channel's writer list await_resume Resumes both reader and ifself the write was successful. Return false if the channel is going to be destroyed(closed).","title":"Read/Write"},{"location":"channel-read_write/#see-also","text":"Channel Concept Go Channel types CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\"","title":"See Also"},{"location":"channel-read_write/#example","text":"test/channel_read_write_mutex.cpp test/channel_write_read_mutex.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp","title":"Example"},{"location":"channel-read_write/#awaitable-channel-read","text":"","title":"Awaitable Channel Read"},{"location":"channel-read_write/#short-example","text":"using namespace coro ; template < typename T , typename M > auto read_from ( channel < T , M >& ch ) -> no_return { auto [ value , ok ] = co_await ch . read (); // you can use `std::tie` if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. }","title":"Short Example"},{"location":"channel-read_write/#type-readerltt-mgt","text":"The type supports move operation, but it is unecessary in general. template < typename T , typename M > class reader final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ); auto await_resume () noexcept ( false ) -> std :: tuple < value_type , bool > ; }; Function Description await_ready Returns true if there is a waiting writer instance in the channel await_suspend Start waiting in the channel's reader list await_resume Resumes both writer and ifself when the read was successful. Returned tuple containes false if the channel is going to be destroyed(closed).","title":"Type: reader&lt;T, M&gt;"},{"location":"channel-read_write/#awaitable-channel-write","text":"","title":"Awaitable Channel Write"},{"location":"channel-read_write/#short-example_1","text":"using namespace coro ; template < typename T , typename M > auto write_to ( channel < T , M >& ch , T && value ) -> no_return { auto ok = co_await ch . write ( value ); // call by reference (T&) if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. }","title":"Short Example"},{"location":"channel-read_write/#type-writerltt-mgt","text":"The type supports move operation, but it is unecessary in general. template < typename T , typename M > class writer final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > _rh ) noexcept ( false ); bool await_resume () noexcept ( false ); }; Function Description await_ready Returns true if there is a waiting reader instance in the channel await_suspend Start waiting in the channel's writer list await_resume Resumes both reader and ifself the write was successful. Return false if the channel is going to be destroyed(closed).","title":"Type: writer&lt;T, M&gt;"},{"location":"channel-select/","text":"Current version uses helper types to use channel in a designed manner. namespace coro { template < typename T , typename M > class channel ; template < typename T , typename M > class peeker ; } // namespace coro See Also Channel Concept Channel Read/Write Example test/channel_select_bypass_empty.cpp test/channel_select_type_match.cpp test/channel_select_peek_all_cases.cpp Channel Non-blocking Select Short Example using namespace coro ; using u32_chan_t = channel < uint32_t > ; using i32_chan_t = channel < int32_t > ; TEST_METHOD ( channel_select_match_one ) { u32_chan_t ch1 {}; i32_chan_t ch2 {}; write_to ( ch1 , 17u ); select ( ch2 , // empty channel. bypass []( auto v ) { static_assert ( is_same_v < decltype ( v ), int32_t > ); Assert :: Fail ( L \"select on empty channel must bypass\" ); }, ch1 , // if the channel has a writer, peek and invoke callback []( auto v ) -> no_return { static_assert ( is_same_v < decltype ( v ), uint32_t > ); Assert :: IsTrue ( v == 17u ); co_await suspend_never {}; }); } Selecting a pair from arguments To support expression like above, select received a number of pairs of channel and functions. The functions can be a coroutine. However, their return object will be truncated. namespace coro { // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { // evaluate select ( ch , forward < FuncType &&> ( fn )); // try next pair return select ( forward < Args &&> ( args )...); } } // namespace coro For each pair, select test the channel and consume writer coroutines. namespace coro { // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } } // namespace coro Channel Peek Operation peeker<T, M> is quite simple. Function Description peek test the channel if there is a waiting writer coroutine. if so, fetch it. acquire return false if there was no writer. Move the value from writer coroutine to local storage. writer coroutine will be resumed. namespace coro { // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; } // namespace coro","title":"Select on multiple channel"},{"location":"channel-select/#see-also","text":"Channel Concept Channel Read/Write","title":"See Also"},{"location":"channel-select/#example","text":"test/channel_select_bypass_empty.cpp test/channel_select_type_match.cpp test/channel_select_peek_all_cases.cpp","title":"Example"},{"location":"channel-select/#channel-non-blocking-select","text":"","title":"Channel Non-blocking Select"},{"location":"channel-select/#short-example","text":"using namespace coro ; using u32_chan_t = channel < uint32_t > ; using i32_chan_t = channel < int32_t > ; TEST_METHOD ( channel_select_match_one ) { u32_chan_t ch1 {}; i32_chan_t ch2 {}; write_to ( ch1 , 17u ); select ( ch2 , // empty channel. bypass []( auto v ) { static_assert ( is_same_v < decltype ( v ), int32_t > ); Assert :: Fail ( L \"select on empty channel must bypass\" ); }, ch1 , // if the channel has a writer, peek and invoke callback []( auto v ) -> no_return { static_assert ( is_same_v < decltype ( v ), uint32_t > ); Assert :: IsTrue ( v == 17u ); co_await suspend_never {}; }); }","title":"Short Example"},{"location":"channel-select/#selecting-a-pair-from-arguments","text":"To support expression like above, select received a number of pairs of channel and functions. The functions can be a coroutine. However, their return object will be truncated. namespace coro { // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { // evaluate select ( ch , forward < FuncType &&> ( fn )); // try next pair return select ( forward < Args &&> ( args )...); } } // namespace coro For each pair, select test the channel and consume writer coroutines. namespace coro { // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } } // namespace coro","title":"Selecting a pair from arguments"},{"location":"channel-select/#channel-peek-operation","text":"peeker<T, M> is quite simple. Function Description peek test the channel if there is a waiting writer coroutine. if so, fetch it. acquire return false if there was no writer. Move the value from writer coroutine to local storage. writer coroutine will be resumed. namespace coro { // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; } // namespace coro","title":"Channel Peek Operation"},{"location":"concrt-latch/","text":"See Also Go Language: sync.WaitGroup C++ Concurrency TS: Latch latch The type is used for synchronization in fork-join scenario. It will be removed when it C++ Concurrency TS becomes available. Visit the cppreference.com for the detailed explaination. Latch in this library has slightly different interface with that of the concurrency TS namespace concrt { // A temporary implementation of `std::experimental::latch` class latch final : no_copy_move { public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept = default ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; } // namespace concrt Definition (Windows) The implementation uses Win32 Event object and a counter using <atomic> . The win32_event here doesn't support co_await expression. namespace concrt { class latch { atomic_uint64_t ref {}; mutable win32_event ev {}; // ... }; } // namespace concrt Definiton (POSIX) The implementation uses pthread_cond_t and pthread_mutex_t . It checks spurious wake-up so it can wait without timeout like the concurrency TS. namespace concrt { class latch { atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; // ... }; } // namespace concrt Example Wait for multiple times Throws exception when counter becomes negative test/channel_race_no_leak.cpp test/net_echo_tcp.cpp","title":"latch"},{"location":"concrt-latch/#see-also","text":"Go Language: sync.WaitGroup C++ Concurrency TS: Latch","title":"See Also"},{"location":"concrt-latch/#latch","text":"The type is used for synchronization in fork-join scenario. It will be removed when it C++ Concurrency TS becomes available. Visit the cppreference.com for the detailed explaination. Latch in this library has slightly different interface with that of the concurrency TS namespace concrt { // A temporary implementation of `std::experimental::latch` class latch final : no_copy_move { public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept = default ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; } // namespace concrt","title":"latch"},{"location":"concrt-latch/#definition-windows","text":"The implementation uses Win32 Event object and a counter using <atomic> . The win32_event here doesn't support co_await expression. namespace concrt { class latch { atomic_uint64_t ref {}; mutable win32_event ev {}; // ... }; } // namespace concrt","title":"Definition (Windows)"},{"location":"concrt-latch/#definiton-posix","text":"The implementation uses pthread_cond_t and pthread_mutex_t . It checks spurious wake-up so it can wait without timeout like the concurrency TS. namespace concrt { class latch { atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; // ... }; } // namespace concrt","title":"Definiton (POSIX)"},{"location":"concrt-latch/#example","text":"Wait for multiple times Throws exception when counter becomes negative test/channel_race_no_leak.cpp test/net_echo_tcp.cpp","title":"Example"},{"location":"concrt-overview/","text":"#include <coroutine/concrt.h> using namespace concrt ; References C++ Reference: Extensions for concurrency Background When I requested for the explanation about the coroutine concept, I mostly start with notifing that the coroutine is irrelevent with the thread (see page 6) . What I explain is, in short: The coroutine is about the routine's design The thread is about the processor abstraction (CPU in general) Therefore, all program with the coroutine must be able to run on (only) 1 thread. Just notice that using a thread is an issue of the implementation, and using a C++ 20 coroutine is an issue of the design. Indeed you can use both together and they can work in harmony. What I want you to know here is that they have a different domain. Contents #include <coroutine/concrt.h> using namespace concrt ; There are 2 family. For Windows and for non-Windows. Shared section latch Windows ptp_work ptp_event Linux + Darwin (POSIX + System API) event and signaled_event_tasks TBA: implementation note for the Darwin","title":"Overview"},{"location":"concrt-overview/#references","text":"C++ Reference: Extensions for concurrency","title":"References"},{"location":"concrt-overview/#background","text":"When I requested for the explanation about the coroutine concept, I mostly start with notifing that the coroutine is irrelevent with the thread (see page 6) . What I explain is, in short: The coroutine is about the routine's design The thread is about the processor abstraction (CPU in general) Therefore, all program with the coroutine must be able to run on (only) 1 thread. Just notice that using a thread is an issue of the implementation, and using a C++ 20 coroutine is an issue of the design. Indeed you can use both together and they can work in harmony. What I want you to know here is that they have a different domain.","title":"Background"},{"location":"concrt-overview/#contents","text":"#include <coroutine/concrt.h> using namespace concrt ; There are 2 family. For Windows and for non-Windows.","title":"Contents"},{"location":"concrt-overview/#shared","text":"section latch","title":"Shared"},{"location":"concrt-overview/#windows","text":"ptp_work ptp_event","title":"Windows"},{"location":"concrt-overview/#linux-darwin-posix-system-api","text":"event and signaled_event_tasks TBA: implementation note for the Darwin","title":"Linux + Darwin (POSIX + System API)"},{"location":"concrt-posix_event/","text":"","title":"Concrt posix event"},{"location":"concrt-ptp_event/","text":"Win32 Event Object + Coroutine See Also MSDN: Using Event Objects ptp_event Awaitable event with the Windows Thread Pool API. Allows mutliple usage with 1 instance. But only 1 co_await is possible each time. Example Wait until signal Cancel #include <coroutine/concrt.h> #include <coroutine/return.h> using namespace concrt ; using namespace coro ; auto wait_an_event ( ptp_event & wo , atomic_flag & flag ) -> no_return { // wait for set or cancel // `co_await` will forward `GetLastError` if canceled. if ( DWORD ec = co_await wo ) { FAIL_WITH_MESSAGE ( system_category (). message ( ec )); co_return ; } flag . test_and_set (); } auto ptp_event_set_test () { // Notice that the Event Object is managed separately. HANDLE ev = CreateEventEx ( nullptr , nullptr , // CREATE_EVENT_MANUAL_RESET , // EVENT_ALL_ACCESS ); auto on_return = gsl :: finally ([ ev ]() { CloseHandle ( ev ); }); ptp_event waitable { ev }; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_an_event ( waitable , flag ); SetEvent ( ev ); SleepEx ( 3 , true ); // give time to the waiting threas set the `flag` REQUIRE ( flag . test_and_set ()); } Definition modules/windows/concrt.cpp class ptp_event final : no_copy_move { HANDLE wo {}; private : // WAITORTIMERCALLBACK static void __stdcall wait_on_thread_pool ( PVOID , BOOLEAN ); public : explicit ptp_event ( HANDLE target ) noexcept ( false ); ~ ptp_event () noexcept ; void cancel () noexcept ; bool await_ready () noexcept ; void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ); uint32_t await_resume () noexcept ; }; Since it uses INFINITE wait, user must make sure one of SetEvent or cancel will happen on the object. Default Operations The type is not copyable and movable. Functions Function Description cancel Cancel the waiting ptp_event . The waiting coroutine will be resumed automatically by the Win32 thread. await_ready Always returns false ( suspend_always ) await_suspend Attach a background thread work to wait the SetEvent await_resume Unregister the wait operation so it can be used again.","title":"Windows Event"},{"location":"concrt-ptp_event/#win32-event-object-coroutine","text":"","title":"Win32 Event Object + Coroutine"},{"location":"concrt-ptp_event/#see-also","text":"MSDN: Using Event Objects","title":"See Also"},{"location":"concrt-ptp_event/#ptp_event","text":"Awaitable event with the Windows Thread Pool API. Allows mutliple usage with 1 instance. But only 1 co_await is possible each time.","title":"ptp_event"},{"location":"concrt-ptp_event/#example","text":"Wait until signal Cancel #include <coroutine/concrt.h> #include <coroutine/return.h> using namespace concrt ; using namespace coro ; auto wait_an_event ( ptp_event & wo , atomic_flag & flag ) -> no_return { // wait for set or cancel // `co_await` will forward `GetLastError` if canceled. if ( DWORD ec = co_await wo ) { FAIL_WITH_MESSAGE ( system_category (). message ( ec )); co_return ; } flag . test_and_set (); } auto ptp_event_set_test () { // Notice that the Event Object is managed separately. HANDLE ev = CreateEventEx ( nullptr , nullptr , // CREATE_EVENT_MANUAL_RESET , // EVENT_ALL_ACCESS ); auto on_return = gsl :: finally ([ ev ]() { CloseHandle ( ev ); }); ptp_event waitable { ev }; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_an_event ( waitable , flag ); SetEvent ( ev ); SleepEx ( 3 , true ); // give time to the waiting threas set the `flag` REQUIRE ( flag . test_and_set ()); }","title":"Example"},{"location":"concrt-ptp_event/#definition","text":"modules/windows/concrt.cpp class ptp_event final : no_copy_move { HANDLE wo {}; private : // WAITORTIMERCALLBACK static void __stdcall wait_on_thread_pool ( PVOID , BOOLEAN ); public : explicit ptp_event ( HANDLE target ) noexcept ( false ); ~ ptp_event () noexcept ; void cancel () noexcept ; bool await_ready () noexcept ; void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ); uint32_t await_resume () noexcept ; }; Since it uses INFINITE wait, user must make sure one of SetEvent or cancel will happen on the object.","title":"Definition"},{"location":"concrt-ptp_event/#default-operations","text":"The type is not copyable and movable.","title":"Default Operations"},{"location":"concrt-ptp_event/#functions","text":"Function Description cancel Cancel the waiting ptp_event . The waiting coroutine will be resumed automatically by the Win32 thread. await_ready Always returns false ( suspend_always ) await_suspend Attach a background thread work to wait the SetEvent await_resume Unregister the wait operation so it can be used again.","title":"Functions"},{"location":"concrt-ptp_work/","text":"Win32 Thread Pool Work + Coroutine See Also CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Using the thread pool functions MSDN: CreateThreadpoolWork WandBox example: A function that selects its thread ptp_work Change current coroutine's execution thread to background thread in the windows thread pool. Example #include <coroutine/return.h> // for `no_return` #include <coroutine/concrt.h> using namespace coro ; // for `no_return` using namespace concrt ; // the example might fail because of the constant folding auto switch_to_background () -> no_return { auto before = GetCurrentThreadId (); co_await ptp_work {}; // resume on thread in the pool auto after = GetCurrentThreadId (); Assert :: IsTrue ( before != after ); } Like the example, it is recommended to use it as a temporary object. Definition modules/windows/concrt.cpp namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { static void __stdcall resume_on_thread_pool ( // PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; }; } // namepace concrt Default Operations The type doesn't require memory (0-byte size). And it is a regular type. Functions Function Description suspend send the given coroutine_handle<void> to background await_suspend coroutine code is generated in importing code. throws error if an error is occurred. namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = suspend ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; } // namepace concrt","title":"Windows Thread Pool"},{"location":"concrt-ptp_work/#win32-thread-pool-work-coroutine","text":"","title":"Win32 Thread Pool Work + Coroutine"},{"location":"concrt-ptp_work/#see-also","text":"CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Using the thread pool functions MSDN: CreateThreadpoolWork WandBox example: A function that selects its thread","title":"See Also"},{"location":"concrt-ptp_work/#ptp_work","text":"Change current coroutine's execution thread to background thread in the windows thread pool.","title":"ptp_work"},{"location":"concrt-ptp_work/#example","text":"#include <coroutine/return.h> // for `no_return` #include <coroutine/concrt.h> using namespace coro ; // for `no_return` using namespace concrt ; // the example might fail because of the constant folding auto switch_to_background () -> no_return { auto before = GetCurrentThreadId (); co_await ptp_work {}; // resume on thread in the pool auto after = GetCurrentThreadId (); Assert :: IsTrue ( before != after ); } Like the example, it is recommended to use it as a temporary object.","title":"Example"},{"location":"concrt-ptp_work/#definition","text":"modules/windows/concrt.cpp namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { static void __stdcall resume_on_thread_pool ( // PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; }; } // namepace concrt","title":"Definition"},{"location":"concrt-ptp_work/#default-operations","text":"The type doesn't require memory (0-byte size). And it is a regular type.","title":"Default Operations"},{"location":"concrt-ptp_work/#functions","text":"Function Description suspend send the given coroutine_handle<void> to background await_suspend coroutine code is generated in importing code. throws error if an error is occurred. namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = suspend ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; } // namepace concrt","title":"Functions"},{"location":"concrt-section/","text":"See Also Concept: BasicLockable section : Critical Section A basic lockable type with System API. The type is not copyable and movable. The purpose of this type is to provide a thin wrapper to use a lockable type in this library's test codes . namespace concrt { class section final : no_copy_move { // ... public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt Definition (Windows) With Win32 API, It uses CRITICAL_SECTION instead of SRWLock . Even though SRWLock doesn't require deallocation and possibly good for performance reason, CRITICAL_SECTION is used since the type is for test code. namespace concrt { // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION , no_copy_move { // ... }; } // namepace concrt Definition (POSIX) With POSIX API, it uses pthread_rwlock_t . The type's existance is only for platform compatibility of test codes. The type was written with pthread_mutex_t to replace std::mutex in test code. The reason was that some test codes required different setting like PTHREAD_PRIO_NONE . namespace concrt { // Standard lockable with pthread reader writer lock class section final : no_copy_move { pthread_rwlock_t rwlock ; // ... }; } // namepace concrt Example #include <coroutine/concrt.h> using namespace concrt ; void perform_with_lock ( section & m ){ std :: lock_guard lck { m }; // do some work... } In this library: test/channel_race_no_leak.cpp","title":"section"},{"location":"concrt-section/#see-also","text":"Concept: BasicLockable","title":"See Also"},{"location":"concrt-section/#section-critical-section","text":"A basic lockable type with System API. The type is not copyable and movable. The purpose of this type is to provide a thin wrapper to use a lockable type in this library's test codes . namespace concrt { class section final : no_copy_move { // ... public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt","title":"section: Critical Section"},{"location":"concrt-section/#definition-windows","text":"With Win32 API, It uses CRITICAL_SECTION instead of SRWLock . Even though SRWLock doesn't require deallocation and possibly good for performance reason, CRITICAL_SECTION is used since the type is for test code. namespace concrt { // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION , no_copy_move { // ... }; } // namepace concrt","title":"Definition (Windows)"},{"location":"concrt-section/#definition-posix","text":"With POSIX API, it uses pthread_rwlock_t . The type's existance is only for platform compatibility of test codes. The type was written with pthread_mutex_t to replace std::mutex in test code. The reason was that some test codes required different setting like PTHREAD_PRIO_NONE . namespace concrt { // Standard lockable with pthread reader writer lock class section final : no_copy_move { pthread_rwlock_t rwlock ; // ... }; } // namepace concrt","title":"Definition (POSIX)"},{"location":"concrt-section/#example","text":"#include <coroutine/concrt.h> using namespace concrt ; void perform_with_lock ( section & m ){ std :: lock_guard lck { m }; // do some work... } In this library: test/channel_race_no_leak.cpp","title":"Example"},{"location":"frame-compiler_specific/","text":"This document covers compiler specific issues. See Also <coroutine/frame.h> Exploring the C++ coroutine Github Issues in this repo Compiler Awareness The file declares some variables for if constexpr support. static constexpr auto is_msvc = // true or false ... static constexpr auto is_clang = // true or false ... static constexpr auto is_gcc = // true or false ... Compiler Intrinsic For MSVC, the library rely on 2 intrinsic functions and 1 adapter function. extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // adapter for _coro_done bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; For Clang, the library rely on 3 intrinsic functions. extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * ); Coroutine Frame Prefix The file also defines frame prefix types to help debugging of coroutine frame. template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16 - 1 ) & ~ ( 16 - 1 )); using procedure_t = void ( __cdecl * )( void * ); The following type is for MSVC. struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); The following type is for Clang and Clang-cl. struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 );","title":"Compiler Specific Issues"},{"location":"frame-compiler_specific/#see-also","text":"<coroutine/frame.h> Exploring the C++ coroutine Github Issues in this repo","title":"See Also"},{"location":"frame-compiler_specific/#compiler-awareness","text":"The file declares some variables for if constexpr support. static constexpr auto is_msvc = // true or false ... static constexpr auto is_clang = // true or false ... static constexpr auto is_gcc = // true or false ...","title":"Compiler Awareness"},{"location":"frame-compiler_specific/#compiler-intrinsic","text":"For MSVC, the library rely on 2 intrinsic functions and 1 adapter function. extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // adapter for _coro_done bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; For Clang, the library rely on 3 intrinsic functions. extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * );","title":"Compiler Intrinsic"},{"location":"frame-compiler_specific/#coroutine-frame-prefix","text":"The file also defines frame prefix types to help debugging of coroutine frame. template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16 - 1 ) & ~ ( 16 - 1 )); using procedure_t = void ( __cdecl * )( void * ); The following type is for MSVC. struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); The following type is for Clang and Clang-cl. struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 );","title":"Coroutine Frame Prefix"},{"location":"frame-coroutine_handle/","text":"See Also n4736 <experimental/coroutine> in VC++ <experimental/coroutine> in libc++ 7 or later Library Issues https://github.com/luncliff/coroutine/issues/23 Coroutine Handle (Standard) ToDo: Summarize the standard docs Coroutine Handle (Custom) Defines the templace class coroutine_handle<T> in std::experimental namespace. namespace std :: experimental { template < typename PromiseType = void > class coroutine_handle ; } Template Parameters PromiseType must fulfills the Coroutine Promise Requirement. Default Operations The class coroutine_handle<P> is regular type . namespace std :: experimental { template <> class coroutine_handle < void > { public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept ; explicit coroutine_handle ( std :: nullptr_t ) noexcept ; // ... }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); // ... } With Void Mostly the type will be used with void as its promise type( coroutine_handle<void> ). In the case, its member functions are like the following table. Function Description operator bool Tells the coroutine handle is not empty resume Resume the coroutine's control flow. The coroutine must be in suspended state. destroy Destruct the variables in the coroutine frame and the frame done Returns true if the coroutine is returned address Acquire the address of the frame from_address Create a coroutine handle that uses the given address as a frame namespace std :: experimental { template <> class coroutine_handle < void > { public : operator bool () const noexcept ; void resume () noexcept ( false ); void destroy () noexcept ; bool done () const noexcept ; constexpr void * address () const noexcept ; static coroutine_handle from_address ( void * addr ) noexcept ; // ... }; } With Promise When the promise type is not void , the template class defines additional functions to work with the PromiseType . Function Description from_address Considering the promise type's size, create a coroutine handle from the given address from_promise Create a handle from the reference to promise namespace std :: experimental { template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; // ... static coroutine_handle from_address ( void * addr ) noexcept ; static coroutine_handle from_promise ( promise_type & prom ) noexcept ; // ... }; } Non-Member Functions Compare Operators namespace std :: experimental { bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; }","title":"coroutine_handle"},{"location":"frame-coroutine_handle/#see-also","text":"n4736 <experimental/coroutine> in VC++ <experimental/coroutine> in libc++ 7 or later","title":"See Also"},{"location":"frame-coroutine_handle/#library-issues","text":"https://github.com/luncliff/coroutine/issues/23","title":"Library Issues"},{"location":"frame-coroutine_handle/#coroutine-handle-standard","text":"ToDo: Summarize the standard docs","title":"Coroutine Handle (Standard)"},{"location":"frame-coroutine_handle/#coroutine-handle-custom","text":"Defines the templace class coroutine_handle<T> in std::experimental namespace. namespace std :: experimental { template < typename PromiseType = void > class coroutine_handle ; }","title":"Coroutine Handle (Custom)"},{"location":"frame-coroutine_handle/#template-parameters","text":"PromiseType must fulfills the Coroutine Promise Requirement.","title":"Template Parameters"},{"location":"frame-coroutine_handle/#default-operations","text":"The class coroutine_handle<P> is regular type . namespace std :: experimental { template <> class coroutine_handle < void > { public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept ; explicit coroutine_handle ( std :: nullptr_t ) noexcept ; // ... }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); // ... }","title":"Default Operations"},{"location":"frame-coroutine_handle/#with-void","text":"Mostly the type will be used with void as its promise type( coroutine_handle<void> ). In the case, its member functions are like the following table. Function Description operator bool Tells the coroutine handle is not empty resume Resume the coroutine's control flow. The coroutine must be in suspended state. destroy Destruct the variables in the coroutine frame and the frame done Returns true if the coroutine is returned address Acquire the address of the frame from_address Create a coroutine handle that uses the given address as a frame namespace std :: experimental { template <> class coroutine_handle < void > { public : operator bool () const noexcept ; void resume () noexcept ( false ); void destroy () noexcept ; bool done () const noexcept ; constexpr void * address () const noexcept ; static coroutine_handle from_address ( void * addr ) noexcept ; // ... }; }","title":"With Void"},{"location":"frame-coroutine_handle/#with-promise","text":"When the promise type is not void , the template class defines additional functions to work with the PromiseType . Function Description from_address Considering the promise type's size, create a coroutine handle from the given address from_promise Create a handle from the reference to promise namespace std :: experimental { template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; // ... static coroutine_handle from_address ( void * addr ) noexcept ; static coroutine_handle from_promise ( promise_type & prom ) noexcept ; // ... }; }","title":"With Promise"},{"location":"frame-coroutine_handle/#non-member-functions","text":"","title":"Non-Member Functions"},{"location":"frame-coroutine_handle/#compare-operators","text":"namespace std :: experimental { bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; }","title":"Compare Operators"},{"location":"frame-coroutine_traits/","text":"This document covers coroutine_traits<R, P...> . Coroutine Traits (Standard) TBA Coroutine Traits (Custom) Unlike libc++ or VC++, current version doesn't allow SFINAE. namespace std :: experimental { // traits to enforce member `promise_type` template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; }","title":"coroutine_traits"},{"location":"frame-coroutine_traits/#coroutine-traits-standard","text":"TBA","title":"Coroutine Traits (Standard)"},{"location":"frame-coroutine_traits/#coroutine-traits-custom","text":"Unlike libc++ or VC++, current version doesn't allow SFINAE. namespace std :: experimental { // traits to enforce member `promise_type` template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; }","title":"Coroutine Traits (Custom)"},{"location":"frame-overview/","text":"#include <coroutine/frame.h> using namespace std :: experimental ; References http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0664r0.html ToDo organize list in this issue add list for the latest ones Background C++ Coroutines is so compiler specific that we can't compile VC++'s <experimental/coroutine> with Clang compiler, and vice versa. Because this is an example project, I believe I have a duty to show people how to configure projects under those envionments. The start was clang-cl on Windows, and I solved some problems related to the difference between 2 compilers. For that, there was no way but to add a wrapper header file. <coroutine/frame.h> file is an adapter to handle coroutine frame's difference between compilers. (For now, they are MSVC and Clang ). Notice that the file imports <experimental/coroutine> . Just like below, <coroutine/frame.h> activates custom implementation only for specific environments. // <coroutine> header build issue handling #if defined(__clang__) && defined(_MSC_VER) // case: clang-cl, VC++ // Use this library's implementation ... #else // case: msvc, VC++ // case: clang, libc++ # if __has_include(<coroutine>) // C++ 20 # include <coroutine> # elif __has_include(<experimental/coroutine>) // C++ 17 # include <experimental/coroutine> # endif #endif // ... So in general you don't have to care. Think of <coroutine/frame.h> as <coroutine> in the future. #if __has_include(<coroutine>) # include <coroutine> #else # include <coroutine/frame.h> #endif If you're really curious, read the file and please review my approach. :) Contents I'm going to cover both the standard and my implementation in this section. You can think these items are the supplement of https://en.cppreference.com/w/cpp . #include <coroutine/frame.h> using namespace std :: experimental ; coroutine_handle<P> coroutine_traits<R, P...> suspend_never and suspend_always Note: Compiler Specific Issues","title":"Overview"},{"location":"frame-overview/#references","text":"http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0664r0.html ToDo organize list in this issue add list for the latest ones","title":"References"},{"location":"frame-overview/#background","text":"C++ Coroutines is so compiler specific that we can't compile VC++'s <experimental/coroutine> with Clang compiler, and vice versa. Because this is an example project, I believe I have a duty to show people how to configure projects under those envionments. The start was clang-cl on Windows, and I solved some problems related to the difference between 2 compilers. For that, there was no way but to add a wrapper header file. <coroutine/frame.h> file is an adapter to handle coroutine frame's difference between compilers. (For now, they are MSVC and Clang ). Notice that the file imports <experimental/coroutine> . Just like below, <coroutine/frame.h> activates custom implementation only for specific environments. // <coroutine> header build issue handling #if defined(__clang__) && defined(_MSC_VER) // case: clang-cl, VC++ // Use this library's implementation ... #else // case: msvc, VC++ // case: clang, libc++ # if __has_include(<coroutine>) // C++ 20 # include <coroutine> # elif __has_include(<experimental/coroutine>) // C++ 17 # include <experimental/coroutine> # endif #endif // ... So in general you don't have to care. Think of <coroutine/frame.h> as <coroutine> in the future. #if __has_include(<coroutine>) # include <coroutine> #else # include <coroutine/frame.h> #endif If you're really curious, read the file and please review my approach. :)","title":"Background"},{"location":"frame-overview/#contents","text":"I'm going to cover both the standard and my implementation in this section. You can think these items are the supplement of https://en.cppreference.com/w/cpp . #include <coroutine/frame.h> using namespace std :: experimental ; coroutine_handle<P> coroutine_traits<R, P...> suspend_never and suspend_always Note: Compiler Specific Issues","title":"Contents"},{"location":"frame-suspend_types/","text":"Coroutine Promise Requirement requires some awaitable type for the initial_suspend and final_suspend member functions for promise_type . suspend_never Awaitable type that never suspend. The control flows through ready - resume . Definition Example namespace std :: experimental { class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // Since the class won't suspend, this function won't be invoked } }; } // namespace std::experimental Known Usages In this library: Type enumerable<T> Type no_return TBA: external references suspend_always Awaitable type that always suspend. The control flows through ready - suspend - resume . Definition Example namespace std :: experimental { class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // The routine will suspend but the class ignores the given handle } }; } // namespace std::experimental Known Usages In this library: Type frame TBA: external references","title":"Suspend Types"},{"location":"frame-suspend_types/#suspend_never","text":"Awaitable type that never suspend. The control flows through ready - resume .","title":"suspend_never"},{"location":"frame-suspend_types/#definition-example","text":"namespace std :: experimental { class suspend_never { public : constexpr bool await_ready () const noexcept { return true ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // Since the class won't suspend, this function won't be invoked } }; } // namespace std::experimental","title":"Definition Example"},{"location":"frame-suspend_types/#known-usages","text":"In this library: Type enumerable<T> Type no_return TBA: external references","title":"Known Usages"},{"location":"frame-suspend_types/#suspend_always","text":"Awaitable type that always suspend. The control flows through ready - suspend - resume .","title":"suspend_always"},{"location":"frame-suspend_types/#definition-example_1","text":"namespace std :: experimental { class suspend_always { public : constexpr bool await_ready () const noexcept { return false ; } constexpr void await_resume () const noexcept { } void await_suspend ( coroutine_handle < void > ) const noexcept { // The routine will suspend but the class ignores the given handle } }; } // namespace std::experimental","title":"Definition Example"},{"location":"frame-suspend_types/#known-usages_1","text":"In this library: Type frame TBA: external references","title":"Known Usages"},{"location":"howto-start-yours/","text":"I think you should be able to start your project if you have followed all of 'How To' documents. If not, please give me your opinion through GitHub issues . I'm longing to hear from you. :)","title":"Start Your Project!"},{"location":"import-using-cmake/","text":"How To Import: CMake Project Does this library support any package manager? Actually, you don't have to use package manager for this libary. git submodule + add_subdirectory will be work well! Try with the Vcpkg This repository is registered as package coroutine in microsoft/vcpkg . Try the awesome tool! $ vcpkg install coroutine The following packages will be built and installed: coroutine[core]:x64-osx Starting package 1/1: coroutine:x64-osx Building package coroutine[core]:x64-osx... -- ... The package coroutine:x64-osx provides CMake targets: find_package(coroutine CONFIG REQUIRED) target_link_libraries(main PRIVATE coroutine) Follow the steps! Check your environment If you didn't checked your project's configuration, please do review this document first . If possible, use the latest CMake Any reason for this? Any guide for the installation? Currently the library expects CMake 3.8 or later, which supports C++ 17 for CXX_STANDARD cmake_minimum_required ( VERSION 3.8 ) Installing GSL(Guideline Support Library) The GSL is a header-only and light-weighted library. You can just use git clone it and import easily. cmake /path/to/project -DGSL_INCLUDE_DIR = /path/to/gsl/include Call add_subdirectory Suppose your project's file tree is like the following. Notice that the project submodules GSL already . So mostly you don't have to manage GSL_INCLUDE_DIR manually. Let the command git submodule will do the work for you. $ git submodule update --init --recursive ... However this document will assume you wanted to use custom path. $ tree -L 2 /path/to/project /path/to/project \u251c\u2500\u2500 CMakeLists.txt \u251c... \u251c\u2500\u2500 gsl # <-- already placed GSL at your path \u2502 \u251c... \u2502 \u2514... \u251c\u2500\u2500 coroutine # <-- you submoduled this library \u2502 \u251c... \u2502 \u2514... \u251c... \u2514... In your CMakeLists.txt, call add_subdirectory . # if you submoduled the coroutine's master branch, # you don't have to set this cmake variable. set ( GSL_INCLUDE_DIR ${ CMAKE_CURRENT_SOURCE_DIR } /gsl/include ) add_subdirectory ( coroutine ) Test will be skipped automatically The library won't build test codes unless it is not a root project . Since you're using add_subdirectory , they will be skipped for your build time! # See the `coroutine/CMakeLists.txt` if ( TEST_DISABLED ) message ( STATUS \"Test is disabled.\" ) return () elseif ( IOS OR ANDROID ) message ( STATUS \"Mobile cross build doesn't support tests\" ) return () elseif ( NOT ${ CMAKE_SOURCE_DIR } STREQUAL ${ CMAKE_CURRENT_SOURCE_DIR } ) message ( STATUS \"This is not a root project. Skip tests\" ) return () endif () Call target_link_libraries The library's CMake configures some PUBLIC settings. So just using target_link_libraries for it will do all the necessary work for you. Such as compiler option, dependent system libraries, etc. target_link_libraries ( your_project_name PUBLIC coroutine ) Questions & Trouble Shooting (Report your trouble)! ...","title":"CMake"},{"location":"import-using-cmake/#how-to-import-cmake-project","text":"","title":"How To Import: CMake Project"},{"location":"import-using-cmake/#does-this-library-support-any-package-manager","text":"Actually, you don't have to use package manager for this libary. git submodule + add_subdirectory will be work well!","title":"Does this library support any package manager?"},{"location":"import-using-cmake/#try-with-the-vcpkg","text":"This repository is registered as package coroutine in microsoft/vcpkg . Try the awesome tool! $ vcpkg install coroutine The following packages will be built and installed: coroutine[core]:x64-osx Starting package 1/1: coroutine:x64-osx Building package coroutine[core]:x64-osx... -- ... The package coroutine:x64-osx provides CMake targets: find_package(coroutine CONFIG REQUIRED) target_link_libraries(main PRIVATE coroutine)","title":"Try with the Vcpkg"},{"location":"import-using-cmake/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"import-using-cmake/#check-your-environment","text":"If you didn't checked your project's configuration, please do review this document first .","title":"Check your environment"},{"location":"import-using-cmake/#if-possible-use-the-latest-cmake","text":"Any reason for this? Any guide for the installation? Currently the library expects CMake 3.8 or later, which supports C++ 17 for CXX_STANDARD cmake_minimum_required ( VERSION 3.8 )","title":"If possible, use the latest CMake"},{"location":"import-using-cmake/#installing-gslguideline-support-library","text":"The GSL is a header-only and light-weighted library. You can just use git clone it and import easily. cmake /path/to/project -DGSL_INCLUDE_DIR = /path/to/gsl/include","title":"Installing GSL(Guideline Support Library)"},{"location":"import-using-cmake/#call-add_subdirectory","text":"Suppose your project's file tree is like the following. Notice that the project submodules GSL already . So mostly you don't have to manage GSL_INCLUDE_DIR manually. Let the command git submodule will do the work for you. $ git submodule update --init --recursive ... However this document will assume you wanted to use custom path. $ tree -L 2 /path/to/project /path/to/project \u251c\u2500\u2500 CMakeLists.txt \u251c... \u251c\u2500\u2500 gsl # <-- already placed GSL at your path \u2502 \u251c... \u2502 \u2514... \u251c\u2500\u2500 coroutine # <-- you submoduled this library \u2502 \u251c... \u2502 \u2514... \u251c... \u2514... In your CMakeLists.txt, call add_subdirectory . # if you submoduled the coroutine's master branch, # you don't have to set this cmake variable. set ( GSL_INCLUDE_DIR ${ CMAKE_CURRENT_SOURCE_DIR } /gsl/include ) add_subdirectory ( coroutine )","title":"Call add_subdirectory"},{"location":"import-using-cmake/#test-will-be-skipped-automatically","text":"The library won't build test codes unless it is not a root project . Since you're using add_subdirectory , they will be skipped for your build time! # See the `coroutine/CMakeLists.txt` if ( TEST_DISABLED ) message ( STATUS \"Test is disabled.\" ) return () elseif ( IOS OR ANDROID ) message ( STATUS \"Mobile cross build doesn't support tests\" ) return () elseif ( NOT ${ CMAKE_SOURCE_DIR } STREQUAL ${ CMAKE_CURRENT_SOURCE_DIR } ) message ( STATUS \"This is not a root project. Skip tests\" ) return () endif ()","title":"Test will be skipped automatically"},{"location":"import-using-cmake/#call-target_link_libraries","text":"The library's CMake configures some PUBLIC settings. So just using target_link_libraries for it will do all the necessary work for you. Such as compiler option, dependent system libraries, etc. target_link_libraries ( your_project_name PUBLIC coroutine )","title":"Call target_link_libraries"},{"location":"import-using-cmake/#questions-trouble-shooting","text":"","title":"Questions &amp; Trouble Shooting"},{"location":"import-using-cmake/#report-your-trouble","text":"...","title":"(Report your trouble)!"},{"location":"import-using-visualstudio/","text":"How To Import: Visual Studio Before Import ... Check the Windows SDK and Visual Studio The coroutine.sln file might be accessing with the wrong version. Or the different version of the Visual Studio can bother you. Try the build first . If the step fails, please create a new issue ! I tested with the following configurations Visual Studio 2017 (v141, 15.12+) 10.0.14393: AppVeyor 10.0.17134 ... Visual Studio 2019 (v142, ...) 10.0.17134 ... Follow the steps! Create a new C++ Solution/Project Of course, the first step is to create importing Project. Open your Visual Studio and create a new VC++ Solution (or project, whatever). Then clone the repository. master branch will be ok. Also, you have to fetch submodules. PS D:\\ConsoleApp\\ConsoleApplication1> git clone https://github.com/luncliff/coroutine PS D:\\ConsoleApp\\ConsoleApplication1> cd .\\coroutine\\ PS D:\\ConsoleApp\\ConsoleApplication1\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/guideline'... Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' After the clone, the folder should be like the following. Let's open the VS and keep going. :) Import VC++ Project We're going to add this library's windows project to the solution. Oh, never forget the x64 platform config! This library doesn't target x86 . The arch is supported by MSVC, but it's not in the maintenance plan for now. Add Existing Project If you cloned the library like the above, you can find it after browsing the workspace. After import, open the Properties page and check the configruation. Change the 'Windows SDK Version' to installed one that you are going to use. It matters. Add Reference Now, change the reference of the ConsoleApplication1 project. Adjustment for the modules/windows.vcxproj Include Directories With basic include directories of the VC++ project, there are 3 additional paths. $(ProjectDir)..\\interface : include folder for library interfaces $(ProjectDir)..\\external\\guideline\\include : C++ Core Guideline Support Library. <gsl/gsl> $(ProjectDir) : internal codes So we have to inherit 2 paths in our new project( ConsoleApplication1 ). After changing the 'Additional Include Directories', update the code like the follwing. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types int main ( int , char * []) { std :: cout << \"Hello Coroutine! \\n \" ; return 0 ; } Now, try the build. (I will do that with x64|Debug ). The build must fail because we didn't changed compiler option. MSVC Compier Options To build the C++ 20 Coroutine code, we have to set the option /await . Also, the language standard C++ 17 is required( /std:c++17 or /std:c++latest ). In case of the coroutine's project, the option is just like this. <Project DefaultTargets= \"Build\" ToolsVersion= \"15.0\" xmlns= \"http://schemas.microsoft.com/developer/msbuild/2003\" > <!-- ... --> <ItemDefinitionGroup Condition= \"'$(Configuration)|$(Platform)'=='Debug|x64'\" > <!-- ... --> <AdditionalOptions> /await %(AdditionalOptions) </AdditionalOptions> <LanguageStandard> stdcpplatest </LanguageStandard> <!-- ... --> Therefore the property of our ConsoleApplication1 need to be changed like the image. Linker Options Well, you don't have to care! :) Just try the new build. If something goes wrong, create a new issue with your screenshot and reproduction steps so I can help you. Try this example So this is our new code. The function doesn't suspend and returns nothing. It works just like normal void(void) subroutine, but it's enough to confirm our compiler supports the feature. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types using std :: experimental :: suspend_never ; using coro :: no_return ; // Destroy coroutine frame after co_return. // It's fire and forget manner auto no_suspend_no_return () -> no_return { co_await suspend_never {}; std :: cout << \"Hello Coroutine! \\n \" ; co_return ; } int main ( int , char * []) { no_suspend_no_return (); return 0 ; } Glad for a new C++ Coroutine user! The screen shot is here. Questions & Trouble Shooting This section is reserved to answer the question, \"If the add reference doesn't work, what should user try?\" Build with the Clang-cl ? Wow, really? You must install the LLVM packages first. Follow this document . I'm considering VS 2019's CMake integration for Clang-cl build tutorial. I will add a new document ASAP.","title":"Visual Studio"},{"location":"import-using-visualstudio/#how-to-import-visual-studio","text":"","title":"How To Import: Visual Studio"},{"location":"import-using-visualstudio/#before-import","text":"","title":"Before Import ..."},{"location":"import-using-visualstudio/#check-the-windows-sdk-and-visual-studio","text":"The coroutine.sln file might be accessing with the wrong version. Or the different version of the Visual Studio can bother you. Try the build first . If the step fails, please create a new issue ! I tested with the following configurations Visual Studio 2017 (v141, 15.12+) 10.0.14393: AppVeyor 10.0.17134 ... Visual Studio 2019 (v142, ...) 10.0.17134 ...","title":"Check the Windows SDK and Visual Studio"},{"location":"import-using-visualstudio/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"import-using-visualstudio/#create-a-new-c-solutionproject","text":"Of course, the first step is to create importing Project. Open your Visual Studio and create a new VC++ Solution (or project, whatever). Then clone the repository. master branch will be ok. Also, you have to fetch submodules. PS D:\\ConsoleApp\\ConsoleApplication1> git clone https://github.com/luncliff/coroutine PS D:\\ConsoleApp\\ConsoleApplication1> cd .\\coroutine\\ PS D:\\ConsoleApp\\ConsoleApplication1\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/guideline'... Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' After the clone, the folder should be like the following. Let's open the VS and keep going. :)","title":"Create a new C++ Solution/Project"},{"location":"import-using-visualstudio/#import-vc-project","text":"We're going to add this library's windows project to the solution. Oh, never forget the x64 platform config! This library doesn't target x86 . The arch is supported by MSVC, but it's not in the maintenance plan for now.","title":"Import VC++ Project"},{"location":"import-using-visualstudio/#add-existing-project","text":"If you cloned the library like the above, you can find it after browsing the workspace. After import, open the Properties page and check the configruation. Change the 'Windows SDK Version' to installed one that you are going to use. It matters.","title":"Add Existing Project"},{"location":"import-using-visualstudio/#add-reference","text":"Now, change the reference of the ConsoleApplication1 project.","title":"Add Reference"},{"location":"import-using-visualstudio/#adjustment-for-the-moduleswindowsvcxproj","text":"","title":"Adjustment for the modules/windows.vcxproj"},{"location":"import-using-visualstudio/#include-directories","text":"With basic include directories of the VC++ project, there are 3 additional paths. $(ProjectDir)..\\interface : include folder for library interfaces $(ProjectDir)..\\external\\guideline\\include : C++ Core Guideline Support Library. <gsl/gsl> $(ProjectDir) : internal codes So we have to inherit 2 paths in our new project( ConsoleApplication1 ). After changing the 'Additional Include Directories', update the code like the follwing. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types int main ( int , char * []) { std :: cout << \"Hello Coroutine! \\n \" ; return 0 ; } Now, try the build. (I will do that with x64|Debug ). The build must fail because we didn't changed compiler option.","title":"Include Directories"},{"location":"import-using-visualstudio/#msvc-compier-options","text":"To build the C++ 20 Coroutine code, we have to set the option /await . Also, the language standard C++ 17 is required( /std:c++17 or /std:c++latest ). In case of the coroutine's project, the option is just like this. <Project DefaultTargets= \"Build\" ToolsVersion= \"15.0\" xmlns= \"http://schemas.microsoft.com/developer/msbuild/2003\" > <!-- ... --> <ItemDefinitionGroup Condition= \"'$(Configuration)|$(Platform)'=='Debug|x64'\" > <!-- ... --> <AdditionalOptions> /await %(AdditionalOptions) </AdditionalOptions> <LanguageStandard> stdcpplatest </LanguageStandard> <!-- ... --> Therefore the property of our ConsoleApplication1 need to be changed like the image.","title":"MSVC Compier Options"},{"location":"import-using-visualstudio/#linker-options","text":"Well, you don't have to care! :) Just try the new build. If something goes wrong, create a new issue with your screenshot and reproduction steps so I can help you.","title":"Linker Options"},{"location":"import-using-visualstudio/#try-this-example","text":"So this is our new code. The function doesn't suspend and returns nothing. It works just like normal void(void) subroutine, but it's enough to confirm our compiler supports the feature. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types using std :: experimental :: suspend_never ; using coro :: no_return ; // Destroy coroutine frame after co_return. // It's fire and forget manner auto no_suspend_no_return () -> no_return { co_await suspend_never {}; std :: cout << \"Hello Coroutine! \\n \" ; co_return ; } int main ( int , char * []) { no_suspend_no_return (); return 0 ; } Glad for a new C++ Coroutine user! The screen shot is here.","title":"Try this example"},{"location":"import-using-visualstudio/#questions-trouble-shooting","text":"This section is reserved to answer the question, \"If the add reference doesn't work, what should user try?\"","title":"Questions &amp; Trouble Shooting"},{"location":"import-using-visualstudio/#build-with-the-clang-cl","text":"Wow, really? You must install the LLVM packages first. Follow this document . I'm considering VS 2019's CMake integration for Clang-cl build tutorial. I will add a new document ASAP.","title":"Build with the Clang-cl ?"},{"location":"net-implementation-epoll/","text":"This document is under progress ... Epoll For Linux platform, it uses epoll . modules/linux/net.cpp Expect & Ensures Socket Socket object for the argument must be O_NONBLOCK flagged. int64_t socket_create ( const addrinfo & hint ) { int64_t sd = socket ( hint . ai_family , hint . ai_socktype , hint . ai_protocol ); if ( sd == - 1 ) FAIL ( strerror ( errno )); return sd ; } void socket_set_option_nonblock ( int64_t sd ) { // make non-block/async REQUIRE ( fcntl ( sd , F_SETFL , O_NONBLOCK | O_ASYNC ) != - 1 ); } The library assumes that all socket descriptors will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SHUT_RDWR ); close ( sd ); } Control Flow and Data The table shows all system calls that are used for each interface functions. Interface Internal send_to epoll_ctl , sendto recv_from epoll_ctl , recvfrom send_stream epoll_ctl , send recv_stream epoll_ctl , recv wait_io_tasks epoll_wait , epoll_create1 , close Concurrent I/O control I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume Request This step works just like Winsock based implementation. auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . sd = sd ; work . from6 = addressof ( remote ); work . addrlen = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } Progress Check fcntl checks the socket's flag for non blocking. If the socket is not flagged non-block, co_await will bypass the suspend step(which uses epoll ) and it will directed to blocking I/O. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true and bypass the epoll return true ; } Suspend coroutine_handle becomes user data of epoll event. However, if there is a pending recv , another recv request won't cancel the previous one . Therefore user have to be cautious about managing pending operations for the socket. struct event_data_t { int fd ; const size_t capacity ; unique_ptr < epoll_event [] > events ; // ... void try_add ( uint64_t sd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( fd , op , sd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } }; void io_recv_from :: suspend ( coroutine_task_t rh ) noexcept ( false ) { errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails } Polling and Resume Since only 1 event can be bound for a file descriptor, the implementation separates inbound and outbound. send , send_to uses inbound and recv , recv_from uses the other. wait_io_tasks function polls both like the following code. event_data_t inbound {}, outbound {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; for ( auto coro : inbound . wait ( half_time )) co_yield coro ; for ( auto coro : outbound . wait ( half_time )) co_yield coro ; } Limitations Current version doesn't provide interface for I/O cancel.","title":"Epoll"},{"location":"net-implementation-epoll/#epoll","text":"For Linux platform, it uses epoll . modules/linux/net.cpp","title":"Epoll"},{"location":"net-implementation-epoll/#expect-ensures","text":"","title":"Expect &amp; Ensures"},{"location":"net-implementation-epoll/#socket","text":"Socket object for the argument must be O_NONBLOCK flagged. int64_t socket_create ( const addrinfo & hint ) { int64_t sd = socket ( hint . ai_family , hint . ai_socktype , hint . ai_protocol ); if ( sd == - 1 ) FAIL ( strerror ( errno )); return sd ; } void socket_set_option_nonblock ( int64_t sd ) { // make non-block/async REQUIRE ( fcntl ( sd , F_SETFL , O_NONBLOCK | O_ASYNC ) != - 1 ); } The library assumes that all socket descriptors will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SHUT_RDWR ); close ( sd ); }","title":"Socket"},{"location":"net-implementation-epoll/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to epoll_ctl , sendto recv_from epoll_ctl , recvfrom send_stream epoll_ctl , send recv_stream epoll_ctl , recv wait_io_tasks epoll_wait , epoll_create1 , close","title":"Control Flow and Data"},{"location":"net-implementation-epoll/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume","title":"Concurrent I/O control"},{"location":"net-implementation-epoll/#request","text":"This step works just like Winsock based implementation. auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . sd = sd ; work . from6 = addressof ( remote ); work . addrlen = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); }","title":"Request"},{"location":"net-implementation-epoll/#progress-check","text":"fcntl checks the socket's flag for non blocking. If the socket is not flagged non-block, co_await will bypass the suspend step(which uses epoll ) and it will directed to blocking I/O. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true and bypass the epoll return true ; }","title":"Progress Check"},{"location":"net-implementation-epoll/#suspend","text":"coroutine_handle becomes user data of epoll event. However, if there is a pending recv , another recv request won't cancel the previous one . Therefore user have to be cautious about managing pending operations for the socket. struct event_data_t { int fd ; const size_t capacity ; unique_ptr < epoll_event [] > events ; // ... void try_add ( uint64_t sd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( fd , op , sd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } }; void io_recv_from :: suspend ( coroutine_task_t rh ) noexcept ( false ) { errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails }","title":"Suspend"},{"location":"net-implementation-epoll/#polling-and-resume","text":"Since only 1 event can be bound for a file descriptor, the implementation separates inbound and outbound. send , send_to uses inbound and recv , recv_from uses the other. wait_io_tasks function polls both like the following code. event_data_t inbound {}, outbound {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; for ( auto coro : inbound . wait ( half_time )) co_yield coro ; for ( auto coro : outbound . wait ( half_time )) co_yield coro ; }","title":"Polling and Resume"},{"location":"net-implementation-epoll/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"net-implementation-kqueue/","text":"This document is under progress ... KQueue For Mac OS(Darwin) platform, it uses kqueue . modules/darwin/net.cpp Expect & Ensures Socket All expectations for socket object are same with epoll based implementation . Control Flow and Data The table shows all system calls that are used for each interface functions. Interface Internal send_to kevent64 , sendto recv_from kevent64 , recvfrom send_stream kevent64 , send recv_stream kevent64 , recv wait_io_tasks kqueue , kevent64 , close Concurrent I/O control I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume Request It performs argument copy(packing) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . sd = sd ; work . addrlen = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } Progress Check The implementation equals to the case of epoll . If the socket is not O_NONBLOCK flagged, it won't use kqueue API. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return errc ; } Suspend Every requests will be one shot requests. Unlike epoll based implementation, it uses io_work for user data. void io_send :: suspend ( coroutine_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = sd ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); auto ec = kevent64 ( kq . fd , & req , 1 , // change nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; } Polling and Resume wait_io_tasks yields iterates kevent64 list. Each of their user data( io_work ) holds coroutine_handle , so the functuon yields them one by one. Current version doesn't use additional information in kevent64 , but the structure will be maintained to deliver it on demand. struct kqueue_data_t { int fd ; const size_t capacity ; unique_ptr < kevent64_s [] > events ; // ... }; kqueue_data_t kq {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); // wait for events ... auto count = kevent64 ( kq . fd , nullptr , 0 , // kq . events . get (), kq . capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { auto & ev = kq . events [ i ]; auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } resume operations perform actual i/o request and acquire its result. int64_t io_send :: resume () noexcept { const auto flag = addrlen ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; // -> io_work::error return sz ; } Limitations Current version doesn't provide interface for I/O cancel.","title":"Kqueue"},{"location":"net-implementation-kqueue/#kqueue","text":"For Mac OS(Darwin) platform, it uses kqueue . modules/darwin/net.cpp","title":"KQueue"},{"location":"net-implementation-kqueue/#expect-ensures","text":"","title":"Expect &amp; Ensures"},{"location":"net-implementation-kqueue/#socket","text":"All expectations for socket object are same with epoll based implementation .","title":"Socket"},{"location":"net-implementation-kqueue/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to kevent64 , sendto recv_from kevent64 , recvfrom send_stream kevent64 , send recv_stream kevent64 , recv wait_io_tasks kqueue , kevent64 , close","title":"Control Flow and Data"},{"location":"net-implementation-kqueue/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume","title":"Concurrent I/O control"},{"location":"net-implementation-kqueue/#request","text":"It performs argument copy(packing) auto send_stream ( uint64_t sd , io_buffer_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . sd = sd ; work . addrlen = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); }","title":"Request"},{"location":"net-implementation-kqueue/#progress-check","text":"The implementation equals to the case of epoll . If the socket is not O_NONBLOCK flagged, it won't use kqueue API. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return errc ; }","title":"Progress Check"},{"location":"net-implementation-kqueue/#suspend","text":"Every requests will be one shot requests. Unlike epoll based implementation, it uses io_work for user data. void io_send :: suspend ( coroutine_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = sd ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); auto ec = kevent64 ( kq . fd , & req , 1 , // change nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; }","title":"Suspend"},{"location":"net-implementation-kqueue/#polling-and-resume","text":"wait_io_tasks yields iterates kevent64 list. Each of their user data( io_work ) holds coroutine_handle , so the functuon yields them one by one. Current version doesn't use additional information in kevent64 , but the structure will be maintained to deliver it on demand. struct kqueue_data_t { int fd ; const size_t capacity ; unique_ptr < kevent64_s [] > events ; // ... }; kqueue_data_t kq {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); // wait for events ... auto count = kevent64 ( kq . fd , nullptr , 0 , // kq . events . get (), kq . capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { auto & ev = kq . events [ i ]; auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } resume operations perform actual i/o request and acquire its result. int64_t io_send :: resume () noexcept { const auto flag = addrlen ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; // -> io_work::error return sz ; }","title":"Polling and Resume"},{"location":"net-implementation-kqueue/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"net-implementation-winsock2/","text":"This document is under progress ... Coroutine + Socket Overlapped I/O + Completion Routine See Also CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Winsock Overlapped I/O modules/windows/net.cpp Remarks The library never invoke WSAStartup and WSACleanup . User must do it. Socket socket object for the argument must be WSA_FLAG_OVERLAPPED flagged. int64_t socket_create ( const addrinfo & hint ) { // use address hint in test class int64_t sd = :: WSASocketW ( hint . ai_family , hint . ai_socktype , hint . ai_protocol , nullptr , 0 , WSA_FLAG_OVERLAPPED ); if ( sd == INVALID_SOCKET ) fail_with_error_message ( WSAGetLastError ()); return sd ; } The library assumes that SOCKET will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SD_BOTH ); closesocket ( sd ); } Control Flow and Data The table shows all system calls that are used for each interface functions. Interface Internal send_to WSASendTo recv_from WSARecvFrom send_stream WSASend recv_stream WSARecv io_work_t containes OVERLAPPED struct . struct io_work_t : public OVERLAPPED { coroutine_task_t task {}; io_buffer_t buffer {}; union { sockaddr * addr {}; sockaddr_in6 * from6 ; const sockaddr_in6 * to6 ; sockaddr_in * from ; const sockaddr_in * to ; }; }; Since it uses completion routine to resume I/O coroutines, wait_io_tasks will always return 0 coroutine handle. // file: <coroutine/net.h> // - Note // This function is only non-windows platform. // Over windows api, it always yields nothing. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > ; Concurrent I/O control I/O Request I/O Progress Check I/O Suspend I/O Resume Request The interface function converts given arguments to invoke Winsock API. auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); work . buffer = buffer ; work . to6 = std :: addressof ( remote ); work . Internal = sd ; work . InternalHigh = sizeof ( remote ); // lead to co_await operations with `io_send_to` type return * reinterpret_cast < io_send_to *> ( std :: addressof ( work )); } Progress Check Always leads to suspend procedure. bool io_work_t :: ready () const noexcept { return false ; // trigger `await_suspend` } Suspend Actual request comes after coroutine_handle is forwarded. void io_send_to :: suspend ( coroutine_task_t rh ) noexcept ( false ) { const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = DWORD { 0 }; const auto sd = gsl :: narrow_cast < SOCKET > ( Internal ); auto bufs = make_wsa_buf ( buffer ); task = rh ; // coroutine for the i/o callback :: WSASendTo ( sd , & bufs , 1 , // nullptr , flag , addr , addrlen , // zero_overlapped ( this ), onWorkDone ); const auto ec = WSAGetLastError (); if ( ec == NO_ERROR || ec == ERROR_IO_PENDING ) return ; // ok. expected for async i/o throw std :: system_error { ec , std :: system_category (), \"WSASendTo\" }; } int64_t io_send_to :: resume () noexcept { return gsl :: narrow_cast < int64_t > ( InternalHigh ); } Resume (by Completion Routine) Completion routine resumes its coroutine frame. io_work works as a receiver for the operation results. void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); work -> Internal = errc ; // -> return of `await_resume()` work -> InternalHigh = sz ; // -> return of `work.error()` work -> task . resume (); } In general(x64), Internal and InternalHigh already have same value with errc , sz . The routine just ensures it. Limitations Current version doesn't provide interface for I/O cancel.","title":"Windows Socket 2"},{"location":"net-implementation-winsock2/#see-also","text":"CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\"","title":"See Also"},{"location":"net-implementation-winsock2/#winsock-overlapped-io","text":"modules/windows/net.cpp","title":"Winsock Overlapped I/O"},{"location":"net-implementation-winsock2/#remarks","text":"The library never invoke WSAStartup and WSACleanup . User must do it.","title":"Remarks"},{"location":"net-implementation-winsock2/#socket","text":"socket object for the argument must be WSA_FLAG_OVERLAPPED flagged. int64_t socket_create ( const addrinfo & hint ) { // use address hint in test class int64_t sd = :: WSASocketW ( hint . ai_family , hint . ai_socktype , hint . ai_protocol , nullptr , 0 , WSA_FLAG_OVERLAPPED ); if ( sd == INVALID_SOCKET ) fail_with_error_message ( WSAGetLastError ()); return sd ; } The library assumes that SOCKET will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SD_BOTH ); closesocket ( sd ); }","title":"Socket"},{"location":"net-implementation-winsock2/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to WSASendTo recv_from WSARecvFrom send_stream WSASend recv_stream WSARecv io_work_t containes OVERLAPPED struct . struct io_work_t : public OVERLAPPED { coroutine_task_t task {}; io_buffer_t buffer {}; union { sockaddr * addr {}; sockaddr_in6 * from6 ; const sockaddr_in6 * to6 ; sockaddr_in * from ; const sockaddr_in * to ; }; }; Since it uses completion routine to resume I/O coroutines, wait_io_tasks will always return 0 coroutine handle. // file: <coroutine/net.h> // - Note // This function is only non-windows platform. // Over windows api, it always yields nothing. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > ;","title":"Control Flow and Data"},{"location":"net-implementation-winsock2/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Resume","title":"Concurrent I/O control"},{"location":"net-implementation-winsock2/#request","text":"The interface function converts given arguments to invoke Winsock API. auto send_to ( uint64_t sd , const sockaddr_in6 & remote , io_buffer_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); work . buffer = buffer ; work . to6 = std :: addressof ( remote ); work . Internal = sd ; work . InternalHigh = sizeof ( remote ); // lead to co_await operations with `io_send_to` type return * reinterpret_cast < io_send_to *> ( std :: addressof ( work )); }","title":"Request"},{"location":"net-implementation-winsock2/#progress-check","text":"Always leads to suspend procedure. bool io_work_t :: ready () const noexcept { return false ; // trigger `await_suspend` }","title":"Progress Check"},{"location":"net-implementation-winsock2/#suspend","text":"Actual request comes after coroutine_handle is forwarded. void io_send_to :: suspend ( coroutine_task_t rh ) noexcept ( false ) { const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = DWORD { 0 }; const auto sd = gsl :: narrow_cast < SOCKET > ( Internal ); auto bufs = make_wsa_buf ( buffer ); task = rh ; // coroutine for the i/o callback :: WSASendTo ( sd , & bufs , 1 , // nullptr , flag , addr , addrlen , // zero_overlapped ( this ), onWorkDone ); const auto ec = WSAGetLastError (); if ( ec == NO_ERROR || ec == ERROR_IO_PENDING ) return ; // ok. expected for async i/o throw std :: system_error { ec , std :: system_category (), \"WSASendTo\" }; } int64_t io_send_to :: resume () noexcept { return gsl :: narrow_cast < int64_t > ( InternalHigh ); }","title":"Suspend"},{"location":"net-implementation-winsock2/#resume-by-completion-routine","text":"Completion routine resumes its coroutine frame. io_work works as a receiver for the operation results. void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); work -> Internal = errc ; // -> return of `await_resume()` work -> InternalHigh = sz ; // -> return of `work.error()` work -> task . resume (); } In general(x64), Internal and InternalHigh already have same value with errc , sz . The routine just ensures it.","title":"Resume (by Completion Routine)"},{"location":"net-implementation-winsock2/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"net-overview/","text":"The interface contains socket I/O functions with coroutine. See Also CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" Dependency The interface uses GSL(Guideline Support Library) and some of this library's features. For GSL itself, please see the GSL section in the C++ Core Guidelines . #include <coroutine/yield.hpp> #include <gsl/gsl> Variables constexpr The header defines 2 constexpr variable. static constexpr bool is_winsock = /* true or false */ ; static constexpr bool is_netinet = /* true or false */ ; Types io_control_block This is an alias of OVERLAPPED struct. For netinet, it's struct follows the OVERLAPPED . // follow the definition of Windows `OVERLAPPED` struct io_control_block { uint64_t internal ; // uint32_t errc; int32_t flag; uint64_t internal_high ; union { struct { int32_t offset ; // socklen_t addrlen; int32_t offset_high ; }; void * ptr ; }; int64_t handle ; // int64_t sd; }; endpoint_t Helper type for socket address usage. Notice that the type contains sockaddr_storage . union endpoint_t final { sockaddr_storage storage {}; sockaddr addr ; sockaddr_in in4 ; sockaddr_in6 in6 ; }; io_task_t This is an alias of coroutine_handle<void> . The coroutine frame becomes an user data in the underlying system's API // 1 task item == 1 resumable function using io_task_t = std :: experimental :: coroutine_handle < void > ; io_buffer_t The type is a view to the bytes(storage for read/write operation). Be aware that it doesn't have ownership. See gsl::span<T> for its usage. using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 ); io_work_t It is a struct to describe 1 I/O request to the underlying system's API class io_work_t : public io_control_block { io_task_t task {}; io_buffer_t buffer {}; endpoint_t * ep {}; public : bool ready () const noexcept ; uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 64 ); After co_await , error() returns the stored error from I/O operation. For its usage, see the examples in I/O operation functions. Operations Remarks The library doesn't use cancel/scatter/gather operations. The library doesn't provide create/destroy/option for the socket. Such an abstraction is tedious and distracts to understand both interface design and internal codes. It just expects that the given socket is non-block and async one, and it works as designed only for the case. Test helper codes below contain socket functions. You can copy-and-paste them :) test/test_network.h test/test_network.cpp wait_io_tasks Acquires currently resumable I/O coroutines. This function is for non-windows platform. Over Windows API, the implementation resumes I/O coroutines automatically. So it always yields nothing . Also, the library does not guarantee that all coroutines(I/O tasks) will be fetched at once. Therefore it is strongly recommended for user to have another method to detect that watching I/O coroutines are returned. User must repeat the resuming loop without break so that there is no leak of event. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > ; Example Use it with the constexpr variables . void io_polling_example () { if constexpr ( is_winsock == false ) { // the library doesn't guarantee they will be fetched at once // so user have to repeat enough to finish all i/o tasks for ( auto task : wait_io_tasks ( 10 ms )) task . resume (); } } send_to Request to internal API to send a buffer to specific endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_send_to final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in6 & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; Params sd : a bound socket descriptor remote : remote address to send buf buf : data(span of std::byte ) to send work : I/O request holder. Down-casted to io_send_to Return send_to : lvalue reference to an awaitable type( io_send_to ) await_resume : success: the length of sent bytes in int64_t failure: the error code will be stored to given work Example The following code shows how send_to can be used. auto example ( uint64_t sd , const sockaddr_in & remote , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_to ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz == storage . size ()); } recv_from Request to internal API to receive through a socket from the unspecified endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_recv_from final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; Params sd : a bound socket descriptor remote : memory to store sender's address buf : data(span of std::byte ) to receive work : I/O request holder. Down-casted to io_recv_from Return recv_from : lvalue reference to an awaitable type( io_recv_from ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example The following code shows how recv_from can be used. auto example ( uint64_t sd , sockaddr_in & remote , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_from ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); } send_stream Request to internal API to send to the connected peer and return a refernce of concrete io_work_t that can be used for co_await . class io_send final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_send & ; Params sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_send Return send_stream : lvalue reference to an awaitable type( io_send ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example The following code shows how send_stream can be used. auto example ( int64_t sd , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz > 0 ); } recv_stream Request to internal API to receive through the connected socket and return a refernce of concrete io_work_t that can be used for co_await . class io_recv final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_recv & ; Params sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_recv Return recv_stream : lvalue reference to an awaitable type( io_recv ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work Example The following code shows how recv_stream can be used. auto example ( int64_t sd , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); } Usage Pattern User must use 2 parts to use the interface. I/O coroutine I/O polling subroutine 1 I/O Reqeust == 1 Coroutine Each I/O request flows sequentially. Polling subroutine will yields coroutines with finished(errored) I/O. auto user_io_coroutine ( uint64_t socket ) -> some_return_type { io_work_t work {}; // control block object io_buffer_t buf {}; // { byte*, size_t } endpoint_t remote {}; // this is the only allowed usage pattern int64_t sz = co_await io_request ( socket , remote , buf , work ) if ( sz == - 1 ) { // ec is updated after the request auto ec = work . error (); // ... } // ... } The request can be one of following functions. Interface Description send_to Send to a specific endpoint( sockaddr ) recv_from Receive a packet and set the sender's endpoint( sockaddr ) send_stream Send to the socket's connected peer recv_stream Receive from the socket's connected peer Continuation of I/O Coroutines User can pool until all I/O coroutines are finished with wait_io_tasks function. It will yield at least 0 coroutine handle. auto example_io_polling ( bool & all_io_finished ) { // timeout with <chrono> using namespace std :: chrono_literals ; // ... while ( all_io_finished == false ) for ( auto coro : wait_io_tasks ( 10 ms )) coro . resume (); // ... } Examples resolve IPv6 Multicast TCPv6 Connect UDPv6 v4 mapped send_stream / recv_stream ( wait_io_tasks ) send_to / recv_from ( wait_io_tasks )","title":"Overview"},{"location":"net-overview/#see-also","text":"CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\"","title":"See Also"},{"location":"net-overview/#dependency","text":"The interface uses GSL(Guideline Support Library) and some of this library's features. For GSL itself, please see the GSL section in the C++ Core Guidelines . #include <coroutine/yield.hpp> #include <gsl/gsl>","title":"Dependency"},{"location":"net-overview/#variables","text":"","title":"Variables"},{"location":"net-overview/#constexpr","text":"The header defines 2 constexpr variable. static constexpr bool is_winsock = /* true or false */ ; static constexpr bool is_netinet = /* true or false */ ;","title":"constexpr"},{"location":"net-overview/#types","text":"","title":"Types"},{"location":"net-overview/#io_control_block","text":"This is an alias of OVERLAPPED struct. For netinet, it's struct follows the OVERLAPPED . // follow the definition of Windows `OVERLAPPED` struct io_control_block { uint64_t internal ; // uint32_t errc; int32_t flag; uint64_t internal_high ; union { struct { int32_t offset ; // socklen_t addrlen; int32_t offset_high ; }; void * ptr ; }; int64_t handle ; // int64_t sd; };","title":"io_control_block"},{"location":"net-overview/#endpoint_t","text":"Helper type for socket address usage. Notice that the type contains sockaddr_storage . union endpoint_t final { sockaddr_storage storage {}; sockaddr addr ; sockaddr_in in4 ; sockaddr_in6 in6 ; };","title":"endpoint_t"},{"location":"net-overview/#io_task_t","text":"This is an alias of coroutine_handle<void> . The coroutine frame becomes an user data in the underlying system's API // 1 task item == 1 resumable function using io_task_t = std :: experimental :: coroutine_handle < void > ;","title":"io_task_t"},{"location":"net-overview/#io_buffer_t","text":"The type is a view to the bytes(storage for read/write operation). Be aware that it doesn't have ownership. See gsl::span<T> for its usage. using io_buffer_t = gsl :: span < std :: byte > ; static_assert ( sizeof ( io_buffer_t ) <= sizeof ( void * ) * 2 );","title":"io_buffer_t"},{"location":"net-overview/#io_work_t","text":"It is a struct to describe 1 I/O request to the underlying system's API class io_work_t : public io_control_block { io_task_t task {}; io_buffer_t buffer {}; endpoint_t * ep {}; public : bool ready () const noexcept ; uint32_t error () const noexcept ; }; static_assert ( sizeof ( io_work_t ) <= 64 ); After co_await , error() returns the stored error from I/O operation. For its usage, see the examples in I/O operation functions.","title":"io_work_t"},{"location":"net-overview/#operations","text":"","title":"Operations"},{"location":"net-overview/#remarks","text":"The library doesn't use cancel/scatter/gather operations. The library doesn't provide create/destroy/option for the socket. Such an abstraction is tedious and distracts to understand both interface design and internal codes. It just expects that the given socket is non-block and async one, and it works as designed only for the case. Test helper codes below contain socket functions. You can copy-and-paste them :) test/test_network.h test/test_network.cpp","title":"Remarks"},{"location":"net-overview/#wait_io_tasks","text":"Acquires currently resumable I/O coroutines. This function is for non-windows platform. Over Windows API, the implementation resumes I/O coroutines automatically. So it always yields nothing . Also, the library does not guarantee that all coroutines(I/O tasks) will be fetched at once. Therefore it is strongly recommended for user to have another method to detect that watching I/O coroutines are returned. User must repeat the resuming loop without break so that there is no leak of event. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> coro :: enumerable < io_task_t > ;","title":"wait_io_tasks"},{"location":"net-overview/#example","text":"Use it with the constexpr variables . void io_polling_example () { if constexpr ( is_winsock == false ) { // the library doesn't guarantee they will be fetched at once // so user have to repeat enough to finish all i/o tasks for ( auto task : wait_io_tasks ( 10 ms )) task . resume (); } }","title":"Example"},{"location":"net-overview/#send_to","text":"Request to internal API to send a buffer to specific endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_send_to final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send_to ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ; [[ nodiscard ]] auto send_to ( uint64_t sd , const sockaddr_in6 & remote , // io_buffer_t buf , io_work_t & work ) noexcept ( false ) // -> io_send_to & ;","title":"send_to"},{"location":"net-overview/#params","text":"sd : a bound socket descriptor remote : remote address to send buf buf : data(span of std::byte ) to send work : I/O request holder. Down-casted to io_send_to","title":"Params"},{"location":"net-overview/#return","text":"send_to : lvalue reference to an awaitable type( io_send_to ) await_resume : success: the length of sent bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"net-overview/#example_1","text":"The following code shows how send_to can be used. auto example ( uint64_t sd , const sockaddr_in & remote , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_to ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz == storage . size ()); }","title":"Example"},{"location":"net-overview/#recv_from","text":"Request to internal API to receive through a socket from the unspecified endpoint and return a refernce of concrete io_work_t that can be used for co_await . class io_recv_from final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv_from ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in6 & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ; [[ nodiscard ]] auto recv_from ( uint64_t sd , sockaddr_in & remote , io_buffer_t buf , // io_work_t & work ) noexcept ( false ) // -> io_recv_from & ;","title":"recv_from"},{"location":"net-overview/#params_1","text":"sd : a bound socket descriptor remote : memory to store sender's address buf : data(span of std::byte ) to receive work : I/O request holder. Down-casted to io_recv_from","title":"Params"},{"location":"net-overview/#return_1","text":"recv_from : lvalue reference to an awaitable type( io_recv_from ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"net-overview/#example_2","text":"The following code shows how recv_from can be used. auto example ( uint64_t sd , sockaddr_in & remote , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_from ( sd , remote , storage , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); }","title":"Example"},{"location":"net-overview/#send_stream","text":"Request to internal API to send to the connected peer and return a refernce of concrete io_work_t that can be used for co_await . class io_send final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_send ) == sizeof ( io_work_t )); [[ nodiscard ]] auto send_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_send & ;","title":"send_stream"},{"location":"net-overview/#params_2","text":"sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_send","title":"Params"},{"location":"net-overview/#return_2","text":"send_stream : lvalue reference to an awaitable type( io_send ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"net-overview/#example_3","text":"The following code shows how send_stream can be used. auto example ( int64_t sd , int64_t & ssz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; ssz = co_await send_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( ssz > 0 ); }","title":"Example"},{"location":"net-overview/#recv_stream","text":"Request to internal API to receive through the connected socket and return a refernce of concrete io_work_t that can be used for co_await . class io_recv final : public io_work_t { public : bool await_ready () const noexcept ; void await_suspend ( io_task_t t ) noexcept ( false ); int64_t await_resume () noexcept ; }; static_assert ( sizeof ( io_recv ) == sizeof ( io_work_t )); [[ nodiscard ]] auto recv_stream ( uint64_t sd , io_buffer_t buf , uint32_t flag , // io_work_t & work ) noexcept ( false ) // -> io_recv & ;","title":"recv_stream"},{"location":"net-overview/#params_3","text":"sd : a descriptor of the connected socket buf : data(span of std::byte ) to receive flag : operation flag for the underlying system's API work : I/O request holder. Down-casted to io_recv","title":"Params"},{"location":"net-overview/#return_3","text":"recv_stream : lvalue reference to an awaitable type( io_recv ) await_resume : success: the length of received bytes in int64_t failure: the error code will be stored to given work","title":"Return"},{"location":"net-overview/#example_4","text":"The following code shows how recv_stream can be used. auto example ( int64_t sd , int64_t & rsz ) -> no_return { io_work_t work {}; array < byte , 1000 > storage {}; rsz = co_await recv_stream ( sd , storage , 0 , work ); if ( auto ec = work . error ()) FAIL ( system_category (). message ( ec )); REQUIRE ( rsz > 0 ); }","title":"Example"},{"location":"net-overview/#usage-pattern","text":"User must use 2 parts to use the interface. I/O coroutine I/O polling subroutine","title":"Usage Pattern"},{"location":"net-overview/#1-io-reqeust-1-coroutine","text":"Each I/O request flows sequentially. Polling subroutine will yields coroutines with finished(errored) I/O. auto user_io_coroutine ( uint64_t socket ) -> some_return_type { io_work_t work {}; // control block object io_buffer_t buf {}; // { byte*, size_t } endpoint_t remote {}; // this is the only allowed usage pattern int64_t sz = co_await io_request ( socket , remote , buf , work ) if ( sz == - 1 ) { // ec is updated after the request auto ec = work . error (); // ... } // ... } The request can be one of following functions. Interface Description send_to Send to a specific endpoint( sockaddr ) recv_from Receive a packet and set the sender's endpoint( sockaddr ) send_stream Send to the socket's connected peer recv_stream Receive from the socket's connected peer","title":"1 I/O Reqeust == 1 Coroutine"},{"location":"net-overview/#continuation-of-io-coroutines","text":"User can pool until all I/O coroutines are finished with wait_io_tasks function. It will yield at least 0 coroutine handle. auto example_io_polling ( bool & all_io_finished ) { // timeout with <chrono> using namespace std :: chrono_literals ; // ... while ( all_io_finished == false ) for ( auto coro : wait_io_tasks ( 10 ms )) coro . resume (); // ... }","title":"Continuation of I/O Coroutines"},{"location":"net-overview/#examples","text":"resolve IPv6 Multicast TCPv6 Connect UDPv6 v4 mapped send_stream / recv_stream ( wait_io_tasks ) send_to / recv_from ( wait_io_tasks )","title":"Examples"},{"location":"return-frame/","text":"See Also C++ Coroutines: Understanding the promise type Exploring The C++ Coroutine Coroutine Promise Requirements (N4736) frame as a ReturnType When user wants to (or have to) manage the destruction of coroutine frame, frame opens a way to acquire the coroutine_handle<void> . Basically, this type is a shallow extension of coroutine_handle<void> . Example The type can be empty. In the case, using done() member function will access to nullptr . #include <coroutine/return.h> using namespace coro ; auto coro_frame_empty_test () -> void { frame fh {}; auto coro = static_cast < coroutine_handle < void >> ( fh ); REQUIRE ( coro . address () == nullptr ); } When the coroutine frame's destuction need to be controlled manually, just suspend( co_await ) or return( co_return , the final suspend) in the function. #include <coroutine/return.h> using namespace coro ; auto invoke_and_suspend () -> frame { co_await suspend_always {}; co_return ; }; auto coro_frame_first_suspend_test () -> void { auto frame = invoke_and_suspend (); // allow access to `coroutine_handle<void>` // after first suspend(which can be `co_return`) coroutine_handle < void >& coro = frame ; REQUIRE ( static_cast < bool > ( coro )); // not null REQUIRE ( coro . done () == false ); // it is susepended, but not return. frame . destroy (); } Remarks The coroutine's frame will remain 'final suspended' after co_return . See the final_suspend in the definiton below. Like no_return , the type doesn't allows co_return; . Definition (Promise) The type's size is equal to that of coroutine_handle<void> . namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final { auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_always {}; // !!!!! } void return_void () noexcept ; void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * ; static auto get_return_object_on_allocation_failure () noexcept -> promise_type * ; }; public : void await_suspend ( coroutine_handle < void > coro ) noexcept ; frame () noexcept = default ; frame ( promise_type * p ) noexcept { this -> await_suspend ( coroutine_handle < promise_type >:: from_promise ( * p )); } }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro frame as an Awaitable The type can be also used as an awaitable to receive coroutine_handle<void> . You may think this harms the SRP(Single Responsibility Principle), but writing another type for the purpose will make the code tedious. Remark The following example shows frame doesn't guarantee it's target(coroutine's frame) is alive. See the following example. In the co_await expression, it must be used by reference . Example Please, be cautious. #include <gsl/gsl> #include <coroutine/return.h> using namespace coro ; auto save_current_handle_to_frame ( frame & fh , int & status ) -> no_return { auto defer = gsl :: finally ([ & ]() { status = 3 ; // change state on destruction phase }); status = 1 ; co_await fh ; // frame type as an awaitable. status = 2 ; co_await fh ; co_return ; } auto coro_frame_awaitable_test () -> void { int status = 0 ; frame coro {}; save_current_handle_to_frame ( coro , status ); REQUIRE ( status == 1 ); // `frame` inherits `coroutine_handle<void>` coro . resume (); REQUIRE ( status == 2 ); // coroutine reached end. // so `defer` in the routine will change status coro . resume (); REQUIRE ( status == 3 ); // however, `no_return` destroyed the coroutine's frame. // so `destroy` through `coro` will be undefined behavior... } Definition (Awaitable) It inherits await_ready and await_resume from the suspend_always type. However, it overrides await_suspend to save given handle. namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final ; public : // override `suspend_always::await_suspend` // assumed to be used as an argument of `co_await` by reference void await_suspend ( coroutine_handle < void > coro ) noexcept { coroutine_handle < void >& self = * this ; self = coro ; } frame () noexcept = default ; frame ( promise_type * p ) noexcept ; }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"frame"},{"location":"return-frame/#see-also","text":"C++ Coroutines: Understanding the promise type Exploring The C++ Coroutine Coroutine Promise Requirements (N4736)","title":"See Also"},{"location":"return-frame/#frame-as-a-returntype","text":"When user wants to (or have to) manage the destruction of coroutine frame, frame opens a way to acquire the coroutine_handle<void> . Basically, this type is a shallow extension of coroutine_handle<void> .","title":"frame as a ReturnType"},{"location":"return-frame/#example","text":"The type can be empty. In the case, using done() member function will access to nullptr . #include <coroutine/return.h> using namespace coro ; auto coro_frame_empty_test () -> void { frame fh {}; auto coro = static_cast < coroutine_handle < void >> ( fh ); REQUIRE ( coro . address () == nullptr ); } When the coroutine frame's destuction need to be controlled manually, just suspend( co_await ) or return( co_return , the final suspend) in the function. #include <coroutine/return.h> using namespace coro ; auto invoke_and_suspend () -> frame { co_await suspend_always {}; co_return ; }; auto coro_frame_first_suspend_test () -> void { auto frame = invoke_and_suspend (); // allow access to `coroutine_handle<void>` // after first suspend(which can be `co_return`) coroutine_handle < void >& coro = frame ; REQUIRE ( static_cast < bool > ( coro )); // not null REQUIRE ( coro . done () == false ); // it is susepended, but not return. frame . destroy (); }","title":"Example"},{"location":"return-frame/#remarks","text":"The coroutine's frame will remain 'final suspended' after co_return . See the final_suspend in the definiton below. Like no_return , the type doesn't allows co_return; .","title":"Remarks"},{"location":"return-frame/#definition-promise","text":"The type's size is equal to that of coroutine_handle<void> . namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final { auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_always {}; // !!!!! } void return_void () noexcept ; void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * ; static auto get_return_object_on_allocation_failure () noexcept -> promise_type * ; }; public : void await_suspend ( coroutine_handle < void > coro ) noexcept ; frame () noexcept = default ; frame ( promise_type * p ) noexcept { this -> await_suspend ( coroutine_handle < promise_type >:: from_promise ( * p )); } }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Definition (Promise)"},{"location":"return-frame/#frame-as-an-awaitable","text":"The type can be also used as an awaitable to receive coroutine_handle<void> . You may think this harms the SRP(Single Responsibility Principle), but writing another type for the purpose will make the code tedious.","title":"frame as an Awaitable"},{"location":"return-frame/#remark","text":"The following example shows frame doesn't guarantee it's target(coroutine's frame) is alive. See the following example. In the co_await expression, it must be used by reference .","title":"Remark"},{"location":"return-frame/#example_1","text":"Please, be cautious. #include <gsl/gsl> #include <coroutine/return.h> using namespace coro ; auto save_current_handle_to_frame ( frame & fh , int & status ) -> no_return { auto defer = gsl :: finally ([ & ]() { status = 3 ; // change state on destruction phase }); status = 1 ; co_await fh ; // frame type as an awaitable. status = 2 ; co_await fh ; co_return ; } auto coro_frame_awaitable_test () -> void { int status = 0 ; frame coro {}; save_current_handle_to_frame ( coro , status ); REQUIRE ( status == 1 ); // `frame` inherits `coroutine_handle<void>` coro . resume (); REQUIRE ( status == 2 ); // coroutine reached end. // so `defer` in the routine will change status coro . resume (); REQUIRE ( status == 3 ); // however, `no_return` destroyed the coroutine's frame. // so `destroy` through `coro` will be undefined behavior... }","title":"Example"},{"location":"return-frame/#definition-awaitable","text":"It inherits await_ready and await_resume from the suspend_always type. However, it overrides await_suspend to save given handle. namespace coro { // provide interface to receive handle class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final ; public : // override `suspend_always::await_suspend` // assumed to be used as an argument of `co_await` by reference void await_suspend ( coroutine_handle < void > coro ) noexcept { coroutine_handle < void >& self = * this ; self = coro ; } frame () noexcept = default ; frame ( promise_type * p ) noexcept ; }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Definition (Awaitable)"},{"location":"return-no_return/","text":"See Also C++ coroutiness: Understanding the promise type Exploring The C++ coroutines Coroutine Promise Requirements (N4736) no_return This is a void return type for the general coroutine functions. Since a coroutine might suspend without return, it is not recommended to rely heavily on co_return from its caller/resumer. If the return can be ignored, class no_return can do the work. Remarks Since the promise_type does not final suspend, a frame of the coroutine that return no_return type will be destroyed immediately . Example If you doesn't care about coroutine's life cycle, use no_return . At least the routine will be resumed(continued) properly, co_return will destroy the frame #include <coroutine/return.h> using namespace coro ; auto fire_and_forget () -> no_return { co_await suspend_never {}; co_return ; }; auto example_caller () -> void { fire_and_forget (); // spawn a new coroutine frame. // the routine will be finished somehow // and destroy the frame. // do some other works ... } Definition It's definition is in the <coroutine/return.h> namespace coro { // General `void` return for the coroutine functions class no_return final { public : class promise_type final { public : // No suspend for init/final suspension point auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * { return this ; } static auto get_return_object_on_allocation_failure () noexcept -> promise_type * { return nullptr ; } }; public : no_return ( const promise_type * ) noexcept { // the type truncates all given info about its frame } }; } // namespace coro Possible customization points are ... unhandled_exception : We can throw the exception again and handle it , but mostly it depends on the scenario. This version assumes it's a somthing irrecoverable. get_return_object_on_allocation_failure : with operator new and operator delete , you can customise memory management for the coroutine frames.","title":"no_return"},{"location":"return-no_return/#see-also","text":"C++ coroutiness: Understanding the promise type Exploring The C++ coroutines Coroutine Promise Requirements (N4736)","title":"See Also"},{"location":"return-no_return/#no_return","text":"This is a void return type for the general coroutine functions. Since a coroutine might suspend without return, it is not recommended to rely heavily on co_return from its caller/resumer. If the return can be ignored, class no_return can do the work.","title":"no_return"},{"location":"return-no_return/#remarks","text":"Since the promise_type does not final suspend, a frame of the coroutine that return no_return type will be destroyed immediately .","title":"Remarks"},{"location":"return-no_return/#example","text":"If you doesn't care about coroutine's life cycle, use no_return . At least the routine will be resumed(continued) properly, co_return will destroy the frame #include <coroutine/return.h> using namespace coro ; auto fire_and_forget () -> no_return { co_await suspend_never {}; co_return ; }; auto example_caller () -> void { fire_and_forget (); // spawn a new coroutine frame. // the routine will be finished somehow // and destroy the frame. // do some other works ... }","title":"Example"},{"location":"return-no_return/#definition","text":"It's definition is in the <coroutine/return.h> namespace coro { // General `void` return for the coroutine functions class no_return final { public : class promise_type final { public : // No suspend for init/final suspension point auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part std :: terminate (); } auto get_return_object () noexcept -> promise_type * { return this ; } static auto get_return_object_on_allocation_failure () noexcept -> promise_type * { return nullptr ; } }; public : no_return ( const promise_type * ) noexcept { // the type truncates all given info about its frame } }; } // namespace coro Possible customization points are ... unhandled_exception : We can throw the exception again and handle it , but mostly it depends on the scenario. This version assumes it's a somthing irrecoverable. get_return_object_on_allocation_failure : with operator new and operator delete , you can customise memory management for the coroutine frames.","title":"Definition"},{"location":"return-overview/","text":"#include <coroutine/return.h> using namespace coro ; References N4820 Working Draft N4736 Working Draft Background One of the entry barriers for the coroutine function is to write a return type. The return type's promise_type must fulfills the Coroutine Promise Requirement (Actually it's coroutine_traits<R>::promise_type , but just let me skip the detail for now). To save your time, start with the article of Lewiss Baker . I also wrote about it with N4402 , and with my talk in C++ Korea (see the page 60) . In my opinion, N4402 was short enough and explains well about the role of those requirements. Contents Currently, this library provides 2 types. #include <coroutine/return.h> using namespace coro ; no_return frame You may noticed that there is no task<T> . I don't have a plan to support the type for 2 reasons. To encourage use of https://github.com/lewissbaker/cppcoro which already implemented it To encourage use of the suspension( co_await and co_yield ) insead of the return( co_return ) In my perspective, the coroutine is a routine with multiple entry points and multiple suspend points. Therefore we should be familiar with the suspension and have concern about its usage rather than just using return(the last suspension).","title":"Overview"},{"location":"return-overview/#references","text":"N4820 Working Draft N4736 Working Draft","title":"References"},{"location":"return-overview/#background","text":"One of the entry barriers for the coroutine function is to write a return type. The return type's promise_type must fulfills the Coroutine Promise Requirement (Actually it's coroutine_traits<R>::promise_type , but just let me skip the detail for now). To save your time, start with the article of Lewiss Baker . I also wrote about it with N4402 , and with my talk in C++ Korea (see the page 60) . In my opinion, N4402 was short enough and explains well about the role of those requirements.","title":"Background"},{"location":"return-overview/#contents","text":"Currently, this library provides 2 types. #include <coroutine/return.h> using namespace coro ; no_return frame You may noticed that there is no task<T> . I don't have a plan to support the type for 2 reasons. To encourage use of https://github.com/lewissbaker/cppcoro which already implemented it To encourage use of the suspension( co_await and co_yield ) insead of the return( co_return ) In my perspective, the coroutine is a routine with multiple entry points and multiple suspend points. Therefore we should be familiar with the suspension and have concern about its usage rather than just using return(the last suspension).","title":"Contents"},{"location":"yield-enumerable/","text":"Generator with the coroutine See Also <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck enumerable<T> This is an implementation of the 'Coroutine-based Generator' concept. However, because of some known implementations, the name can be considered as a reserved one. In this library, the impl is is named as enumerable . Even though there are existing implementations like the generator of VC++, I had to write my own one to test coroutine_handle<void> because the type is compiler-dependent. If you're clang/libc++ user, you can use mine or generator of the cppcoro . template < typename T > class enumerable final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; enumerable contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements. Template Parameters T : The type of element in the enumerable. Default Operations Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class enumerable final { public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( promise_type * ptr ) noexcept ; ~ enumerable () noexcept ; }; Coroutine frame for the generator follows RAII. So it will destroy its handle in destructor. Functions The type supports ranged- for statment. Function Description begin Start fetching elements until co_return . end End of the enumerable. template < typename T > class enumerable final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; }; Type: promise_type The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the generator coroutine yield_value Yield the given element and allow its consumer to access it Remark It only takes lvalue reference( T& ) for the operand of co_yield . template < typename T > class enumerable final { public : class promise_type final { public : auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; auto yield_value ( reference ref ) noexcept ; void return_void () noexcept ; void unhandled_exception () noexcept ; promise_type * get_return_object () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; Type: iterator Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent misusage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Also, as an iterator type, it supports * , -> , == , != . template < typename T > class enumerable final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; }; Examples You can see the usage with test codes. Use of co_yield What if the function yields 0-time? Move Semantics Iteration std::accumulate std::max_element","title":"Generator"},{"location":"yield-enumerable/#see-also","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"See Also"},{"location":"yield-enumerable/#enumerablelttgt","text":"This is an implementation of the 'Coroutine-based Generator' concept. However, because of some known implementations, the name can be considered as a reserved one. In this library, the impl is is named as enumerable . Even though there are existing implementations like the generator of VC++, I had to write my own one to test coroutine_handle<void> because the type is compiler-dependent. If you're clang/libc++ user, you can use mine or generator of the cppcoro . template < typename T > class enumerable final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; enumerable contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements.","title":"enumerable&lt;T&gt;"},{"location":"yield-enumerable/#template-parameters","text":"T : The type of element in the enumerable.","title":"Template Parameters"},{"location":"yield-enumerable/#default-operations","text":"Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class enumerable final { public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( promise_type * ptr ) noexcept ; ~ enumerable () noexcept ; }; Coroutine frame for the generator follows RAII. So it will destroy its handle in destructor.","title":"Default Operations"},{"location":"yield-enumerable/#functions","text":"The type supports ranged- for statment. Function Description begin Start fetching elements until co_return . end End of the enumerable. template < typename T > class enumerable final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; };","title":"Functions"},{"location":"yield-enumerable/#type-promise_type","text":"The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the generator coroutine yield_value Yield the given element and allow its consumer to access it","title":"Type: promise_type"},{"location":"yield-enumerable/#remark","text":"It only takes lvalue reference( T& ) for the operand of co_yield . template < typename T > class enumerable final { public : class promise_type final { public : auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; auto yield_value ( reference ref ) noexcept ; void return_void () noexcept ; void unhandled_exception () noexcept ; promise_type * get_return_object () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; };","title":"Remark"},{"location":"yield-enumerable/#type-iterator","text":"Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent misusage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Also, as an iterator type, it supports * , -> , == , != . template < typename T > class enumerable final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Type: iterator"},{"location":"yield-enumerable/#examples","text":"You can see the usage with test codes. Use of co_yield What if the function yields 0-time? Move Semantics Iteration std::accumulate std::max_element","title":"Examples"},{"location":"yield-overview/","text":"#include <coroutine/yield.hpp> using namespace coro ; References <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck Background I strongly recomment the last two materials. Andreas Reischuck's explanation will be a good time saver for you. ToDo: The essense of co_yield ? Contents enumerable<T> sequence<T>","title":"Overview"},{"location":"yield-overview/#references","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"References"},{"location":"yield-overview/#background","text":"I strongly recomment the last two materials. Andreas Reischuck's explanation will be a good time saver for you. ToDo: The essense of co_yield ?","title":"Background"},{"location":"yield-overview/#contents","text":"enumerable<T> sequence<T>","title":"Contents"},{"location":"yield-sequence/","text":"Generator + Async Iterator See Also <experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck sequence<T> sequence is an abstraction for the async generator. It is not named async_generator to imply that it's just one implementation of the concept. This type should be used carefully . It is not recommended in general, and there might be a bug(failure) on release mode with clang compiler . Contrary to that, MSVC works well with the optimization flag . template < typename T > class sequence final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; sequence contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements. Template Parameters T : the type of element in the sequence. Default Operations Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class sequence final { public : sequence ( sequence & ) = delete ; sequence & operator = ( sequence & ) = delete ; sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; It is expected that the user code will destroy the coroutine frame of the sequence manually . This is inconvenient but must be ensured like the following example. TEST_CASE ( \"async_generator\" , \"[generic]\" ) { using namespace std :: experimental ; // for async generator, // its coroutine frame must be alive for some case. return_frame frame {}; auto ensure_destroy_frame = gsl :: finally ([ = ]() { if ( auto coro = static_cast < coroutine_handle < void >> ( frame )) coro . destroy (); }); SECTION ( \"yield once\" ) { auto example = []() -> sequence < int > { int v = 333 ; co_yield v ; co_return ; }; auto use_sequence = [ = ]( int & ref ) -> return_frame { for co_await ( int v : example ()) ref = v ; co_return ; }; int value = 0 ; REQUIRE_NOTHROW ( frame = use_sequence ( value )); REQUIRE ( value == 333 ); } // ... } Functions Function Description begin Start the sequence coroutine and fetch elements until co_yield receives some awaitable. end End of the sequence. template < typename T > class sequence final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; }; Type: promise_type The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the sequence coroutine yield_value<Awaitable> Trigger suspend until the given Awaitable is resumed. yield_value Yield the given element and notify to consumer coroutine When the next element is unavailable, programmer suspend it by co_yield ing an awaitable. The promise_type allows to distinguish between the new element and programmer's awaitable by using itself as an awaitable. Function Description await_ready true if consumer is waiting for the sequence coroutine. await_suspend Save the sequence coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (user of the sequence ). template < typename T > class sequence final { public : class promise_type final { public : void unhandled_exception () noexcept ; auto get_return_object () noexcept -> promise_type * ; auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; promise_type & yield_value ( reference ref ) noexcept ; template < typename Awaitable > Awaitable & yield_value ( Awaitable && a ) noexcept ; void return_void () noexcept ; bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; void await_resume () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; Type: iterator Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Like normal iterator types, it supports * , -> , == , != . However, the iterator itself is an awaitable . Function Description await_ready false if the element is not available. true for the other case. await_suspend Save the current coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (this). template < typename T > class sequence final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; iterator & await_resume () noexcept ; reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; }; Examples You can see the usage with test codes. Use of co_yield with awaitable What if the function yields 0-time? Destruction Frame's status Iteration Suspend with co_await Suspend with co_yield See Also In this library: Type frame","title":"Async Generator"},{"location":"yield-sequence/#see-also","text":"<experimental/generator> : implementation in VC++ GitHub - kirkshoop/await 2016 await/yield: C++ coroutines - Zbigniew Skowron Meeting C++ 2018: Coroutine TS A new way of thinking - Andreas Reischuck","title":"See Also"},{"location":"yield-sequence/#sequencelttgt","text":"sequence is an abstraction for the async generator. It is not named async_generator to imply that it's just one implementation of the concept. This type should be used carefully . It is not recommended in general, and there might be a bug(failure) on release mode with clang compiler . Contrary to that, MSVC works well with the optimization flag . template < typename T > class sequence final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; sequence contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements.","title":"sequence&lt;T&gt;"},{"location":"yield-sequence/#template-parameters","text":"T : the type of element in the sequence.","title":"Template Parameters"},{"location":"yield-sequence/#default-operations","text":"Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class sequence final { public : sequence ( sequence & ) = delete ; sequence & operator = ( sequence & ) = delete ; sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; It is expected that the user code will destroy the coroutine frame of the sequence manually . This is inconvenient but must be ensured like the following example. TEST_CASE ( \"async_generator\" , \"[generic]\" ) { using namespace std :: experimental ; // for async generator, // its coroutine frame must be alive for some case. return_frame frame {}; auto ensure_destroy_frame = gsl :: finally ([ = ]() { if ( auto coro = static_cast < coroutine_handle < void >> ( frame )) coro . destroy (); }); SECTION ( \"yield once\" ) { auto example = []() -> sequence < int > { int v = 333 ; co_yield v ; co_return ; }; auto use_sequence = [ = ]( int & ref ) -> return_frame { for co_await ( int v : example ()) ref = v ; co_return ; }; int value = 0 ; REQUIRE_NOTHROW ( frame = use_sequence ( value )); REQUIRE ( value == 333 ); } // ... }","title":"Default Operations"},{"location":"yield-sequence/#functions","text":"Function Description begin Start the sequence coroutine and fetch elements until co_yield receives some awaitable. end End of the sequence. template < typename T > class sequence final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; };","title":"Functions"},{"location":"yield-sequence/#type-promise_type","text":"The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the sequence coroutine yield_value<Awaitable> Trigger suspend until the given Awaitable is resumed. yield_value Yield the given element and notify to consumer coroutine When the next element is unavailable, programmer suspend it by co_yield ing an awaitable. The promise_type allows to distinguish between the new element and programmer's awaitable by using itself as an awaitable. Function Description await_ready true if consumer is waiting for the sequence coroutine. await_suspend Save the sequence coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (user of the sequence ). template < typename T > class sequence final { public : class promise_type final { public : void unhandled_exception () noexcept ; auto get_return_object () noexcept -> promise_type * ; auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; promise_type & yield_value ( reference ref ) noexcept ; template < typename Awaitable > Awaitable & yield_value ( Awaitable && a ) noexcept ; void return_void () noexcept ; bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; void await_resume () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; };","title":"Type: promise_type"},{"location":"yield-sequence/#type-iterator","text":"Notice the iterator uses std::forward_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Like normal iterator types, it supports * , -> , == , != . However, the iterator itself is an awaitable . Function Description await_ready false if the element is not available. true for the other case. await_suspend Save the current coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (this). template < typename T > class sequence final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; iterator & await_resume () noexcept ; reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Type: iterator"},{"location":"yield-sequence/#examples","text":"You can see the usage with test codes. Use of co_yield with awaitable What if the function yields 0-time? Destruction Frame's status Iteration Suspend with co_await Suspend with co_yield","title":"Examples"},{"location":"yield-sequence/#see-also_1","text":"In this library: Type frame","title":"See Also"},{"location":"articles/awaitable-event/","text":"Awaitable event using the coroutine, epoll , and eventfd The note explains the detail of event in coroutine/concrt.h Summary Look & feel of the interface via test code . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); } Note Motivation It would be convenient if there is a simple event type for co_await operator. Linux system's eventfd might be able to do the work. Requirement The requirement for the event type is simple. It doesn\u2019t support copy construction/assignment It doesn\u2019t support move construction/assignment The type can\u2019t be inherited( final ) It can be an operand of co_await operator The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. The first 3 requirement is quite strict, but it\u2019s for simplicity. Normally it won\u2019t be that hazardous for move operation. But moving from coroutine\u2019s frame to another space is a tricky situation. So I\u2019ve banned move semantics to prevent misusage like that. Design Win32 API supports internal thread pool , but Linux system API does not. So user code has to poll those created events. Fortunately, Linux supports epoll to allow the behavior. We can derive 2 behavior constraint from the interface limitation. To acquire a list of signaled events, user code has to perform a polling operation Limitation from epoll \u2019s use-case User has to resume coroutines that are suspended for an event object Limitation from coroutine_handle<void> and absence of embedded thread pool/APC support This was the rough version of the interface type & function. // Awaitable event type. class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // it's lightweight ! public : event (); ~ event (); void set (); bool await_ready () const ; void await_suspend ( coroutine_handle < void > coro ); void await_resume (); }; // Enumerate all suspended coroutines that are waiting for signaled events. auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; coro::enumerable<T> is my own implementation of the generator<T> in <experimental/generator> state is a space for eventfd , and signaled_event_tasks performs polling operation on the epoll file descriptor. Concerns You may think about why I didn\u2019t adopt design like io_context in Boost ASIO . Which provides an explicit point of creation and polling operation. For instance, with Boost ASIO, user code must create objects(e.g, socket) via boost::asio::io_context object. // see: https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/allocation/server.cpp class server { private : boost :: asio :: io_context & io_context_ ; tcp :: acceptor acceptor_ ; public : server ( boost :: asio :: io_context & io_context , short port ) : io_context_ ( io_context ), acceptor_ ( io_context , tcp :: endpoint ( tcp :: v4 (), port )) // <------ { session_ptr new_session ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } void handle_accept ( session_ptr new_session , const boost :: system :: error_code & error ) { if ( ! error ) { new_session -> start (); } new_session . reset ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } }; int main ( int argc , char * argv []) { try { // ... boost :: asio :: io_context io_context ; // <------ server s ( io_context , atoi ( argv [ 1 ])); io_context . run (); // <------ } catch ( std :: exception & e ) { std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; } As you can see, such design enforces to use reference in construction like server \u2019s constructor. Since there might be multiple instances of server in one program, this is sound and appropriate. However, event is used in system level, and we don\u2019t have to consider the owner of event objects because it is always system itself. This is why I didn\u2019t designed some type like event_context . Therefore, it will be enough to replace io_context.run() to signaled_event_tasks() . Implementation Each description is based on the actual code. In this note, I will explain with a simplified code. (skip some header, exception spec, etc.) Wrapping epoll Polling epoll Event interface Event state managment Event await operations Wrapping epoll linux/event_poll.h linux/event_poll.cpp I don't prefer writing wrapper for the system API, but I have another feature(networking) that uses it. Before the start, if you're not familiar with epoll , I do recommend you to find some articles and read them first. (I'm sorry!) Ok, let me start ... The wrapper follows RAII and provides some member functions. try_add : add or modify given epoll_event using epoll_ctl remove : epoll_ctl with EPOLL_CTL_DEL wait : wait for epoll_event s and allows iterate them for each epoll_wait #include <fcntl.h> #include <sys/epoll.h> #include <unistd.h> struct event_poll_t final : no_copy_move { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () ; ~ event_poll_t () ; void try_add ( uint64_t fd , epoll_event & req ) ; void remove ( uint64_t fd ); auto wait ( int timeout ) -> coro :: enumerable < epoll_event > ; }; As you can expect, it internally allocates an array to receive events from epoll_wait event_poll_t :: event_poll_t () : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () { close ( epfd ); } With the RAII, epoll_ctl can be wrapped with exception throwing code. You might be able to write your own version if you hate using the exception. void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try again with mod goto TRY_OP ; } // failed throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl EPOLL_CTL_DEL\" }; } It's not that complicated :) Polling epoll linux/event_poll.cpp Since event_poll_t is internal type, it is free to co_yield internal type objects like epoll_event . Type for the wait timeout uses int instead of chrono::duration because epoll_wait allows negative( -1 ) timeout. auto event_poll_t :: wait ( int timeout ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } In another translation unit, signaled_event_tasks queries the event_poll_t and yield coroutine handles from the user data in epoll_event . // signaled event list event_poll_t selist {}; auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Ok, now user code will invoke the function to acquire coroutines with the signaled event. Since its return type is coroutine generator, they can use for statement like the following test code . TEST_CASE ( \"wait for one event\" , \"[event]\" ) { // ... for ( auto task : signaled_event_tasks ()) { task . resume (); // ... } // ... } Event interface coroutine/concrt.h Now, it's time to implement event type. I will write some private member functions for each of await_ready , await_suspend , and await_resume . You may ask why I'm not implementing await_* functions directly. Well, that's because I've met an issue that exporting await_* functions for DLL leads to an internal compiler error . At least vc140 and vc141 did in my experience. My approach is to export those interface functions as private and redirecting to them using public functions to allow co_await statement // note: // _INTERFACE_ is __declspec(dllexport) or __attribute__((visibility(\"default\"))) class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // <--- will explain in next section private : _INTERFACE_ void on_suspend ( task ) ; _INTERFACE_ bool is_ready () const ; _INTERFACE_ void on_resume () ; public : _INTERFACE_ event () ; _INTERFACE_ ~ event () ; // signal the event object _INTERFACE_ void set () ; // ... redirect to private member functions safely ... bool await_ready () const { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) { return this -> on_suspend ( coro ); } void await_resume () { return this -> on_resume (); } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Its member functions will be explained below. Before that, let's see how the type implemented constructor and destructor . It's not complicated! event :: event () : state {} { const auto fd = eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } You can see a weird function, get_eventfd . Event's state managment Just like the code above, event 's state is from eventfd function. However, we need a piece of information to estimate the event is signaled . class event final : no_copy_move { private : uint64_t state ; }; Instead of using an internal counter of eventfd , I used a bit mask to distinguish that the event object is signaled . Please follow the comments. I wrote carefully! // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) { return static_cast < int64_t > ( ~ emask & state ); } uint64_t make_signaled ( int64_t efd ) ; Was the comment enough? With those helper functions, set operation becomes really simple. void event :: set () { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); state = make_signaled ( fd ); // if it didn't throwed // it's signaled state from now } Let me remind you of one of the requirements. For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. Let's just assume that our event 's fd is already registered to epoll . To make epoll return this event in epoll_wait , we will use write . And, of course, bit masking must come after the success of the operation! uint64_t make_signaled ( int64_t efd ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd auto sz = write ( efd , & efd , sizeof ( efd )); if ( sz == - 1 ) throw system_error { errno , system_category (), \"write\" }; return emask | static_cast < uint64_t > ( efd ); } Remember that we flagged EFD_NONBLOCK for eventfd function in the constructor. It was intended :) Event's await operations The last part of the implementation is for co_await statement. await_ready and await_resume is simple with the masking function. bool event :: is_ready () const { return is_signaled ( state ); } void event :: on_resume () { // make non-signaled state this -> state = static_cast < decltype ( state ) > ( get_eventfd ( state )); } The transition to non-signaled state is based on the requirement. And after set member function, await_ready will return true and will bypass await_suspend . The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend . Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement . Now, our keystone function is like this. We declared global variable with event_poll_t type when writing signaled_event_tasks . When the coroutine enters await_suspend , we have to send the coroutine_handle<void> to the event_poll_t . // signaled event list. event_poll_t selist {}; void event :: on_suspend ( task t ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded // to `signaled_event_tasks` by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } Here, we use epoll_event 's user data to save the coroutine frame's address. Compare the code with the implementation of the signaled_event_tasks below. It constructs coroutine handle from e.data.ptr . auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Summary for the implementation It wasn't that hard to combine coroutine with epoll and evnetfd . Let's cover the event again. // event type uses `eventfd` and bit masking for state check class event final : no_copy_move { public : using task = coroutine_handle < void > ; // becomes user data of `epoll_event` private : uint64_t state ; // msb + file descriptor public : event (); // create fd with `eventfd` ~ event (); // `close` the fd // if it's signaled (msb is 1), no suspend bool await_ready (); // bind current fd to epoll // and its epoll_event will hold the coroutine's handle void await_suspend ( coroutine_handle < void > coro ); // make non-signaled (reset msb to 0) void await_resume (); // if there is a suspended coroutine, // it means that the event's fd is alreadty registered via `await_suspend` // so we will invoke `write` for the fd. // `epoll` in the `signaled_event_tasks` will report that using `epoll_wait` // if it's not suspended (== no waiting coroutine), // `write` on it won't matter void set (); }; the exported function signaled_event_tasks allows user code to acquire suspended(event-waiting) coroutines. It might be unsatisfying that those coroutines are not resumed automatically, but if we already have a main loop for event handling, this function can be placed at the point without concerns. // access to hidden(global) `epoll` and invoke `epoll_wait`. // `epoll_wait` will return `epoll_event`s with `coroutine_handle<void>` // this function extracts and yields them to caller auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Whoa, that's all for the implementation details. Conclusion Now we can write a coroutine code like the summary section. epoll and eventfd is simple enough to use, but almost all of their examples use thread(or system process). With the C++ 20 coroutine, we can use the pair in a more graceful manner . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } // we must enter the loop REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"POSIX event"},{"location":"articles/awaitable-event/#awaitable-event-using-the-coroutine-epoll-and-eventfd","text":"The note explains the detail of event in coroutine/concrt.h","title":"Awaitable event using the coroutine, epoll, and eventfd"},{"location":"articles/awaitable-event/#summary","text":"Look & feel of the interface via test code . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Summary"},{"location":"articles/awaitable-event/#note","text":"","title":"Note"},{"location":"articles/awaitable-event/#motivation","text":"It would be convenient if there is a simple event type for co_await operator. Linux system's eventfd might be able to do the work.","title":"Motivation"},{"location":"articles/awaitable-event/#requirement","text":"The requirement for the event type is simple. It doesn\u2019t support copy construction/assignment It doesn\u2019t support move construction/assignment The type can\u2019t be inherited( final ) It can be an operand of co_await operator The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. The first 3 requirement is quite strict, but it\u2019s for simplicity. Normally it won\u2019t be that hazardous for move operation. But moving from coroutine\u2019s frame to another space is a tricky situation. So I\u2019ve banned move semantics to prevent misusage like that.","title":"Requirement"},{"location":"articles/awaitable-event/#design","text":"Win32 API supports internal thread pool , but Linux system API does not. So user code has to poll those created events. Fortunately, Linux supports epoll to allow the behavior. We can derive 2 behavior constraint from the interface limitation. To acquire a list of signaled events, user code has to perform a polling operation Limitation from epoll \u2019s use-case User has to resume coroutines that are suspended for an event object Limitation from coroutine_handle<void> and absence of embedded thread pool/APC support This was the rough version of the interface type & function. // Awaitable event type. class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // it's lightweight ! public : event (); ~ event (); void set (); bool await_ready () const ; void await_suspend ( coroutine_handle < void > coro ); void await_resume (); }; // Enumerate all suspended coroutines that are waiting for signaled events. auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; coro::enumerable<T> is my own implementation of the generator<T> in <experimental/generator> state is a space for eventfd , and signaled_event_tasks performs polling operation on the epoll file descriptor.","title":"Design"},{"location":"articles/awaitable-event/#concerns","text":"You may think about why I didn\u2019t adopt design like io_context in Boost ASIO . Which provides an explicit point of creation and polling operation. For instance, with Boost ASIO, user code must create objects(e.g, socket) via boost::asio::io_context object. // see: https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/allocation/server.cpp class server { private : boost :: asio :: io_context & io_context_ ; tcp :: acceptor acceptor_ ; public : server ( boost :: asio :: io_context & io_context , short port ) : io_context_ ( io_context ), acceptor_ ( io_context , tcp :: endpoint ( tcp :: v4 (), port )) // <------ { session_ptr new_session ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } void handle_accept ( session_ptr new_session , const boost :: system :: error_code & error ) { if ( ! error ) { new_session -> start (); } new_session . reset ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } }; int main ( int argc , char * argv []) { try { // ... boost :: asio :: io_context io_context ; // <------ server s ( io_context , atoi ( argv [ 1 ])); io_context . run (); // <------ } catch ( std :: exception & e ) { std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; } As you can see, such design enforces to use reference in construction like server \u2019s constructor. Since there might be multiple instances of server in one program, this is sound and appropriate. However, event is used in system level, and we don\u2019t have to consider the owner of event objects because it is always system itself. This is why I didn\u2019t designed some type like event_context . Therefore, it will be enough to replace io_context.run() to signaled_event_tasks() .","title":"Concerns"},{"location":"articles/awaitable-event/#implementation","text":"Each description is based on the actual code. In this note, I will explain with a simplified code. (skip some header, exception spec, etc.) Wrapping epoll Polling epoll Event interface Event state managment Event await operations","title":"Implementation"},{"location":"articles/awaitable-event/#wrapping-epoll","text":"linux/event_poll.h linux/event_poll.cpp I don't prefer writing wrapper for the system API, but I have another feature(networking) that uses it. Before the start, if you're not familiar with epoll , I do recommend you to find some articles and read them first. (I'm sorry!) Ok, let me start ... The wrapper follows RAII and provides some member functions. try_add : add or modify given epoll_event using epoll_ctl remove : epoll_ctl with EPOLL_CTL_DEL wait : wait for epoll_event s and allows iterate them for each epoll_wait #include <fcntl.h> #include <sys/epoll.h> #include <unistd.h> struct event_poll_t final : no_copy_move { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () ; ~ event_poll_t () ; void try_add ( uint64_t fd , epoll_event & req ) ; void remove ( uint64_t fd ); auto wait ( int timeout ) -> coro :: enumerable < epoll_event > ; }; As you can expect, it internally allocates an array to receive events from epoll_wait event_poll_t :: event_poll_t () : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () { close ( epfd ); } With the RAII, epoll_ctl can be wrapped with exception throwing code. You might be able to write your own version if you hate using the exception. void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try again with mod goto TRY_OP ; } // failed throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl EPOLL_CTL_DEL\" }; } It's not that complicated :)","title":"Wrapping epoll"},{"location":"articles/awaitable-event/#polling-epoll","text":"linux/event_poll.cpp Since event_poll_t is internal type, it is free to co_yield internal type objects like epoll_event . Type for the wait timeout uses int instead of chrono::duration because epoll_wait allows negative( -1 ) timeout. auto event_poll_t :: wait ( int timeout ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } In another translation unit, signaled_event_tasks queries the event_poll_t and yield coroutine handles from the user data in epoll_event . // signaled event list event_poll_t selist {}; auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Ok, now user code will invoke the function to acquire coroutines with the signaled event. Since its return type is coroutine generator, they can use for statement like the following test code . TEST_CASE ( \"wait for one event\" , \"[event]\" ) { // ... for ( auto task : signaled_event_tasks ()) { task . resume (); // ... } // ... }","title":"Polling epoll"},{"location":"articles/awaitable-event/#event-interface","text":"coroutine/concrt.h Now, it's time to implement event type. I will write some private member functions for each of await_ready , await_suspend , and await_resume . You may ask why I'm not implementing await_* functions directly. Well, that's because I've met an issue that exporting await_* functions for DLL leads to an internal compiler error . At least vc140 and vc141 did in my experience. My approach is to export those interface functions as private and redirecting to them using public functions to allow co_await statement // note: // _INTERFACE_ is __declspec(dllexport) or __attribute__((visibility(\"default\"))) class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // <--- will explain in next section private : _INTERFACE_ void on_suspend ( task ) ; _INTERFACE_ bool is_ready () const ; _INTERFACE_ void on_resume () ; public : _INTERFACE_ event () ; _INTERFACE_ ~ event () ; // signal the event object _INTERFACE_ void set () ; // ... redirect to private member functions safely ... bool await_ready () const { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) { return this -> on_suspend ( coro ); } void await_resume () { return this -> on_resume (); } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Its member functions will be explained below. Before that, let's see how the type implemented constructor and destructor . It's not complicated! event :: event () : state {} { const auto fd = eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } You can see a weird function, get_eventfd .","title":"Event interface"},{"location":"articles/awaitable-event/#events-state-managment","text":"Just like the code above, event 's state is from eventfd function. However, we need a piece of information to estimate the event is signaled . class event final : no_copy_move { private : uint64_t state ; }; Instead of using an internal counter of eventfd , I used a bit mask to distinguish that the event object is signaled . Please follow the comments. I wrote carefully! // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) { return static_cast < int64_t > ( ~ emask & state ); } uint64_t make_signaled ( int64_t efd ) ; Was the comment enough? With those helper functions, set operation becomes really simple. void event :: set () { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); state = make_signaled ( fd ); // if it didn't throwed // it's signaled state from now } Let me remind you of one of the requirements. For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. Let's just assume that our event 's fd is already registered to epoll . To make epoll return this event in epoll_wait , we will use write . And, of course, bit masking must come after the success of the operation! uint64_t make_signaled ( int64_t efd ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd auto sz = write ( efd , & efd , sizeof ( efd )); if ( sz == - 1 ) throw system_error { errno , system_category (), \"write\" }; return emask | static_cast < uint64_t > ( efd ); } Remember that we flagged EFD_NONBLOCK for eventfd function in the constructor. It was intended :)","title":"Event's state managment"},{"location":"articles/awaitable-event/#events-await-operations","text":"The last part of the implementation is for co_await statement. await_ready and await_resume is simple with the masking function. bool event :: is_ready () const { return is_signaled ( state ); } void event :: on_resume () { // make non-signaled state this -> state = static_cast < decltype ( state ) > ( get_eventfd ( state )); } The transition to non-signaled state is based on the requirement. And after set member function, await_ready will return true and will bypass await_suspend . The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend . Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement . Now, our keystone function is like this. We declared global variable with event_poll_t type when writing signaled_event_tasks . When the coroutine enters await_suspend , we have to send the coroutine_handle<void> to the event_poll_t . // signaled event list. event_poll_t selist {}; void event :: on_suspend ( task t ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded // to `signaled_event_tasks` by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } Here, we use epoll_event 's user data to save the coroutine frame's address. Compare the code with the implementation of the signaled_event_tasks below. It constructs coroutine handle from e.data.ptr . auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } }","title":"Event's await operations"},{"location":"articles/awaitable-event/#summary-for-the-implementation","text":"It wasn't that hard to combine coroutine with epoll and evnetfd . Let's cover the event again. // event type uses `eventfd` and bit masking for state check class event final : no_copy_move { public : using task = coroutine_handle < void > ; // becomes user data of `epoll_event` private : uint64_t state ; // msb + file descriptor public : event (); // create fd with `eventfd` ~ event (); // `close` the fd // if it's signaled (msb is 1), no suspend bool await_ready (); // bind current fd to epoll // and its epoll_event will hold the coroutine's handle void await_suspend ( coroutine_handle < void > coro ); // make non-signaled (reset msb to 0) void await_resume (); // if there is a suspended coroutine, // it means that the event's fd is alreadty registered via `await_suspend` // so we will invoke `write` for the fd. // `epoll` in the `signaled_event_tasks` will report that using `epoll_wait` // if it's not suspended (== no waiting coroutine), // `write` on it won't matter void set (); }; the exported function signaled_event_tasks allows user code to acquire suspended(event-waiting) coroutines. It might be unsatisfying that those coroutines are not resumed automatically, but if we already have a main loop for event handling, this function can be placed at the point without concerns. // access to hidden(global) `epoll` and invoke `epoll_wait`. // `epoll_wait` will return `epoll_event`s with `coroutine_handle<void>` // this function extracts and yields them to caller auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Whoa, that's all for the implementation details.","title":"Summary for the implementation"},{"location":"articles/awaitable-event/#conclusion","text":"Now we can write a coroutine code like the summary section. epoll and eventfd is simple enough to use, but almost all of their examples use thread(or system process). With the C++ 20 coroutine, we can use the pair in a more graceful manner . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } // we must enter the loop REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Conclusion"},{"location":"articles/combining-coroutines-and-pthread_create/","text":"Combining C++ Coroutines and pthread_create Like pthread_create , system functions with callback, have a void* user_data in their signature. Let's discover how co_await can be used for the case, and how the coroutine_handle<void> is forwarded. Also, we will write some code to imply our design intent. Imagine the look and feel Before start, consider the look & feel of this. auto work_on_new_thread ( pthread_t & tid , // const pthread_attr_t * attr ) noexcept ( false ) -> no_return { // this line is executed on the spawner thread co_await spawn_pthread ( tid , attr ); // this line is executed on the pthread with 'tid' } We are going to write something like above, but it will be a different one. Can you imagine how such code can be possible? start_routine to resume the coroutine Definately the most important functions are life cycle functions. pthread_create pthread_join #include <pthread.h> // create a new thread int pthread_create ( pthread_t * thread , const pthread_attr_t * attr , void * ( * start_routine ) ( void * ), void * arg ); // join with a terminated thread int pthread_join ( pthread_t thread , void ** retval ); Here, we can control 2 parameters. start_routine to designate what to do, and arg to send user's data to the routine. With them we can imagine some code in the system will be like this. void * out ; void pthread_entry_point (...){ // ... PC(Program Counter) jumps to here ... out = start_routine ( arg ); // perform `pthread_exit` ... // deliver 'out' to `pthread_join` or somewhere ... } We will define a simple function for the start_routine . It constructs the coroutine_handle and resume it after checking with done . void * resume_on_pthread ( void * ptr ){ // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); } And some await_suspend will invoke the function with void* from a coroutine_handle<void> . struct pthread_spawner_t { constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } }; Needs for the customized return type A coroutine's frame is preserved if its coroutine_traits<R>::promise_type makes final suspension. Such a code intends manual destruction of the frame, like generator<T> . // From VC++, <experimental/generator> namespace experimental { template < typename _Ty , typename _Alloc = allocator < char >> struct generator { struct promise_type { _Ty const * _CurrentValue ; // ... bool final_suspend () { return ( true ); } // ... }; // ... ~ generator () { if ( _Coro ) { // manual destruction of // the generator coroutine's frame _Coro . destroy (); } } private : coroutine_handle < promise_type > _Coro = nullptr ; }; } // namespace experimental Notice that resume_on_pthread returns the address of the given coroutine frame. The code is dangerous because there is no way to know whether the frame is preserved final_suspend ed after resume or not. In case of final_suspend ed, we can receive the address with pthread_join , and safely destroy it. auto join_and_destroy ( pthread_t tid ){ void * ptr {}; pthread_join ( tid , & ptr ); // assume it always success for simplicity auto coro = coroutine_handle < void >:: from_address ( ptr ); if ( coro ) coro . destroy (); } But for the case it didn't final_suspend , which means its frame is destroyed after co_return , the code will double-delete the frame. Preserving frame for pthread_join In short, the purpose of the custom type is that ... meet the condition final_suspend == true so pthread_join can receive the frame perform destroy of the frame after the pthread_join class pthread_joiner_t final { public : struct promise_type { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ // preserve the frame after `co_return` return suspend_always {}; } void return_void (){ // we already returns coroutine's frame. // so `co_return` can't have its operand } void unhandled_exception (){ // ... } auto get_return_object () -> promise_type * { return this ; } }; public : pthread_joiner_t ( promise_type * ) : tid {} { } ~ pthread_joiner_t () noexcept ( false ) { // just like `join_and_destroy` above ... void * ptr {}; // we must acquire `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } private : pthread_t tid ; }; So if we use it as a return for the coroutine function, it will be like the following. Search and see the pthread_spawner_t together. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); // It can be useful if it supports `operator pthread_t()`. Consider it! // pthread_t worker_id = joiner; } It seems, we are almost done, but it's not. Pairing pthread_joiner_t with pthread_spawner_t pthread_spawner_t is not a simple awaitable that can be used anywhere, it must be available only when pthread_joiner_t is the return type. To imply the design intent, we will define the await_transform in pthread_joiner_t , so it becomes the only type which allows pthread_spawner_t . class pthread_joiner_t final { public : struct promise_type ; // nest(hide) the `pthread_spawner_t` and allow access to `promise_type` class pthread_spawner_t final { friend class promise_type ; public : // awaitable interface must be open to public constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; pthread_create ( & tid , this -> attr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; struct promise_type { // ... same with above ... // We can consider the `pthread_attr_t*` as an intent // to create a new pthread. // Therefore, `promise_type` will transform the type // to `pthread_spawner_t` and // trigger thread creation with the receiving `co_await` auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr } } }; // ... same with above ... private : pthread_t tid ; }; Unlike the change above, the example still remains simple. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { // pthread_attr_t doesn't implement the awaitable interface, // but we can use it since we implemented `await_transform` // in the `pthread_joiner_t::promise_type`. co_await attr ; // ... } void owner_subroutine (){ // a wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); } Acquiring pthread_t for the pthread_joiner_t Now the last part is to store the new pthread's id in the pthread_joiner_t . Before writing a code, we must decide where to place the therad's id. In the first example of the pthread_joiner_t , I placed pthread_t as a member variable. That's pretty general for most of type for subroutines . Suppose you have to write a coroutine that knows it's activator's address. To be more precise, the address of its return type's object. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { // Can we know the address of the returned pthread_joiner_t object ? // Even if that is possible, using the address is a sound design ? } Definatly that will lead to the bad code. Notice that we are preserving the coroutine frame until pthread_join . In other word, it is a valid behavior to access the frame before pthread_join . So we will save the thread's id in the coroutine's frame, and access to it when the thread's id is requested. Placing the object in the coroutine's frame isn't that hard. Since the promise_type object is placed in the frame , accessing to it can be done with 1 pointer. I already show you how to get a ponter to promise_type . Let me show you again. class pthread_joiner_t final { public : struct promise_type ; class pthread_spawner_t ; struct promise_type { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_always {}; } void unhandled_exception (){ } auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr }; } auto get_return_object () -> promise_type * { return this ; } // notice this is a public pthread_t tid {}; }; public : // we will receive the pointer from `get_return_object` pthread_joiner_t ( promise_type * p ) : promise { p } { } ~ pthread_joiner_t () noexcept ( false ) { // ... } // and we can access to the `tid` through the pointer operator pthread_t () const noexcept { return promise -> tid ; } private : promise_type * promise ; }; So the last job is to update tid in the promise_type . To do so, let's rewrite the pthread_spawner_t again. class pthread_joiner_t final { public : struct promise_type ; // nest(hide) the `pthread_spawner_t` and allow access to `promise_type` class pthread_spawner_t final { friend class promise_type ; public : // awaitable interface must be open to public constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_create ( this -> tid , this -> attr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } private : // receives 2 pointer pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr }{ } pthread_t * tid ; const pthread_attr_t * const attr ; }; struct promise_type { auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // ... pthread_t tid {}; }; // ... }; Combining all together You can run the example with the WandBox. https://wandbox.org/permlink/qQ1vbwshsoujYnI0 In this article we explored how the awaitable can wrap the system function when it's using a callback which has a void* parameter. Step by step, we defined the return type and awaitable type for the coroutines. Function resume_on_pthread for the start_routine of the pthread_create It assumes that the argument is a coroutine_handle<void> It resumes the coroutine_handle<void> It returns the coroutine frame's address A simple awaitable type that wraps pthread_create Invoke pthread_create in its await_suspend coroutine_handle<void> becomes arg of the pthread_create Return type: pthread_joiner_t pthread_join and receives the frame's address Destroy the coroutine frame Coroutine Promise Requirement ( pthread_joiner_t::promise_type ) final_suspend == true to prevent destruction of the frame after co_return await_transform to allow co_await on pthread_attr_t* In other words, pthread_attr_t* becomes an awaitable only when the pthread_joiner_t is return type. Define return_void since resume_on_pthread already has a return value Awaitable type: pthread_spawner_t Advanced awaitable type It saves the new pthread's id in the promise_type Nested in the pthread_joiner_t to prevent misusage There is no direct use of pthread_spawner_t However, we only wrapped pthread life cycle functions. So if the coroutine invokes pthread_exit instead of co_return , the assumption of the pthread_joiner_t will be broken. I couldn't find a way to deal with the case.","title":"Combining C++ coroutines and `pthread_create`"},{"location":"articles/combining-coroutines-and-pthread_create/#combining-c-coroutines-and-pthread_create","text":"Like pthread_create , system functions with callback, have a void* user_data in their signature. Let's discover how co_await can be used for the case, and how the coroutine_handle<void> is forwarded. Also, we will write some code to imply our design intent.","title":"Combining C++ Coroutines and pthread_create"},{"location":"articles/combining-coroutines-and-pthread_create/#imagine-the-look-and-feel","text":"Before start, consider the look & feel of this. auto work_on_new_thread ( pthread_t & tid , // const pthread_attr_t * attr ) noexcept ( false ) -> no_return { // this line is executed on the spawner thread co_await spawn_pthread ( tid , attr ); // this line is executed on the pthread with 'tid' } We are going to write something like above, but it will be a different one. Can you imagine how such code can be possible?","title":"Imagine the look and feel"},{"location":"articles/combining-coroutines-and-pthread_create/#start_routine-to-resume-the-coroutine","text":"Definately the most important functions are life cycle functions. pthread_create pthread_join #include <pthread.h> // create a new thread int pthread_create ( pthread_t * thread , const pthread_attr_t * attr , void * ( * start_routine ) ( void * ), void * arg ); // join with a terminated thread int pthread_join ( pthread_t thread , void ** retval ); Here, we can control 2 parameters. start_routine to designate what to do, and arg to send user's data to the routine. With them we can imagine some code in the system will be like this. void * out ; void pthread_entry_point (...){ // ... PC(Program Counter) jumps to here ... out = start_routine ( arg ); // perform `pthread_exit` ... // deliver 'out' to `pthread_join` or somewhere ... } We will define a simple function for the start_routine . It constructs the coroutine_handle and resume it after checking with done . void * resume_on_pthread ( void * ptr ){ // assume we will receive an address of the coroutine frame auto task = coroutine_handle < void >:: from_address ( ptr ); if ( task . done () == false ) task . resume (); return task . address (); // coroutine_handle<void>::address(); } And some await_suspend will invoke the function with void* from a coroutine_handle<void> . struct pthread_spawner_t { constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; pthread_create ( & tid , nullptr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } };","title":"start_routine to resume the coroutine"},{"location":"articles/combining-coroutines-and-pthread_create/#needs-for-the-customized-return-type","text":"A coroutine's frame is preserved if its coroutine_traits<R>::promise_type makes final suspension. Such a code intends manual destruction of the frame, like generator<T> . // From VC++, <experimental/generator> namespace experimental { template < typename _Ty , typename _Alloc = allocator < char >> struct generator { struct promise_type { _Ty const * _CurrentValue ; // ... bool final_suspend () { return ( true ); } // ... }; // ... ~ generator () { if ( _Coro ) { // manual destruction of // the generator coroutine's frame _Coro . destroy (); } } private : coroutine_handle < promise_type > _Coro = nullptr ; }; } // namespace experimental Notice that resume_on_pthread returns the address of the given coroutine frame. The code is dangerous because there is no way to know whether the frame is preserved final_suspend ed after resume or not. In case of final_suspend ed, we can receive the address with pthread_join , and safely destroy it. auto join_and_destroy ( pthread_t tid ){ void * ptr {}; pthread_join ( tid , & ptr ); // assume it always success for simplicity auto coro = coroutine_handle < void >:: from_address ( ptr ); if ( coro ) coro . destroy (); } But for the case it didn't final_suspend , which means its frame is destroyed after co_return , the code will double-delete the frame.","title":"Needs for the customized return type"},{"location":"articles/combining-coroutines-and-pthread_create/#preserving-frame-for-pthread_join","text":"In short, the purpose of the custom type is that ... meet the condition final_suspend == true so pthread_join can receive the frame perform destroy of the frame after the pthread_join class pthread_joiner_t final { public : struct promise_type { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ // preserve the frame after `co_return` return suspend_always {}; } void return_void (){ // we already returns coroutine's frame. // so `co_return` can't have its operand } void unhandled_exception (){ // ... } auto get_return_object () -> promise_type * { return this ; } }; public : pthread_joiner_t ( promise_type * ) : tid {} { } ~ pthread_joiner_t () noexcept ( false ) { // just like `join_and_destroy` above ... void * ptr {}; // we must acquire `tid` before the destruction if ( int ec = pthread_join ( tid , & ptr )){ throw system_error { ec , system_category (), \"pthread_join\" }; } if ( auto frame = coroutine_handle < void >:: from_address ( ptr )){ frame . destroy (); } } private : pthread_t tid ; }; So if we use it as a return for the coroutine function, it will be like the following. Search and see the pthread_spawner_t together. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { co_await pthread_spawner_t { attr }; // ... } void owner_subroutine (){ // A wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); // It can be useful if it supports `operator pthread_t()`. Consider it! // pthread_t worker_id = joiner; } It seems, we are almost done, but it's not.","title":"Preserving frame for pthread_join"},{"location":"articles/combining-coroutines-and-pthread_create/#pairing-pthread_joiner_t-with-pthread_spawner_t","text":"pthread_spawner_t is not a simple awaitable that can be used anywhere, it must be available only when pthread_joiner_t is the return type. To imply the design intent, we will define the await_transform in pthread_joiner_t , so it becomes the only type which allows pthread_spawner_t . class pthread_joiner_t final { public : struct promise_type ; // nest(hide) the `pthread_spawner_t` and allow access to `promise_type` class pthread_spawner_t final { friend class promise_type ; public : // awaitable interface must be open to public constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_t tid {}; pthread_create ( & tid , this -> attr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } private : explicit pthread_spawner_t ( const pthread_attr_t * _attr ) : attr { _attr }{} const pthread_attr_t * const attr ; }; struct promise_type { // ... same with above ... // We can consider the `pthread_attr_t*` as an intent // to create a new pthread. // Therefore, `promise_type` will transform the type // to `pthread_spawner_t` and // trigger thread creation with the receiving `co_await` auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr } } }; // ... same with above ... private : pthread_t tid ; }; Unlike the change above, the example still remains simple. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { // pthread_attr_t doesn't implement the awaitable interface, // but we can use it since we implemented `await_transform` // in the `pthread_joiner_t::promise_type`. co_await attr ; // ... } void owner_subroutine (){ // a wrapper subroutine to guarantee join. auto joiner = resume_on_new_thread ( nullptr ); }","title":"Pairing pthread_joiner_t with pthread_spawner_t"},{"location":"articles/combining-coroutines-and-pthread_create/#acquiring-pthread_t-for-the-pthread_joiner_t","text":"Now the last part is to store the new pthread's id in the pthread_joiner_t . Before writing a code, we must decide where to place the therad's id. In the first example of the pthread_joiner_t , I placed pthread_t as a member variable. That's pretty general for most of type for subroutines . Suppose you have to write a coroutine that knows it's activator's address. To be more precise, the address of its return type's object. auto resume_on_new_thread ( const pthread_attr_t * attr ) -> pthread_joiner_t { // Can we know the address of the returned pthread_joiner_t object ? // Even if that is possible, using the address is a sound design ? } Definatly that will lead to the bad code. Notice that we are preserving the coroutine frame until pthread_join . In other word, it is a valid behavior to access the frame before pthread_join . So we will save the thread's id in the coroutine's frame, and access to it when the thread's id is requested. Placing the object in the coroutine's frame isn't that hard. Since the promise_type object is placed in the frame , accessing to it can be done with 1 pointer. I already show you how to get a ponter to promise_type . Let me show you again. class pthread_joiner_t final { public : struct promise_type ; class pthread_spawner_t ; struct promise_type { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_always {}; } void unhandled_exception (){ } auto await_transform ( const pthread_attr_t * attr ){ return pthread_spawner_t { attr }; } auto get_return_object () -> promise_type * { return this ; } // notice this is a public pthread_t tid {}; }; public : // we will receive the pointer from `get_return_object` pthread_joiner_t ( promise_type * p ) : promise { p } { } ~ pthread_joiner_t () noexcept ( false ) { // ... } // and we can access to the `tid` through the pointer operator pthread_t () const noexcept { return promise -> tid ; } private : promise_type * promise ; }; So the last job is to update tid in the promise_type . To do so, let's rewrite the pthread_spawner_t again. class pthread_joiner_t final { public : struct promise_type ; // nest(hide) the `pthread_spawner_t` and allow access to `promise_type` class pthread_spawner_t final { friend class promise_type ; public : // awaitable interface must be open to public constexpr bool await_ready () const noexcept { return false ; // always false to utilize `await_suspend` } void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { pthread_create ( this -> tid , this -> attr , resume_on_pthread , rh . address ()); // skipped error check for simplicity :) } void await_resume () noexcept { // this function will in the call stack of `resume_on_pthread` ... } private : // receives 2 pointer pthread_spawner_t ( pthread_t * _tid , const pthread_attr_t * _attr ) : tid { _tid }, attr { _attr }{ } pthread_t * tid ; const pthread_attr_t * const attr ; }; struct promise_type { auto await_transform ( const pthread_attr_t * attr ){ // provide the address at this point return pthread_spawner_t { addressof ( this -> tid ), attr }; } // ... pthread_t tid {}; }; // ... };","title":"Acquiring pthread_t for the pthread_joiner_t"},{"location":"articles/combining-coroutines-and-pthread_create/#combining-all-together","text":"You can run the example with the WandBox. https://wandbox.org/permlink/qQ1vbwshsoujYnI0 In this article we explored how the awaitable can wrap the system function when it's using a callback which has a void* parameter. Step by step, we defined the return type and awaitable type for the coroutines. Function resume_on_pthread for the start_routine of the pthread_create It assumes that the argument is a coroutine_handle<void> It resumes the coroutine_handle<void> It returns the coroutine frame's address A simple awaitable type that wraps pthread_create Invoke pthread_create in its await_suspend coroutine_handle<void> becomes arg of the pthread_create Return type: pthread_joiner_t pthread_join and receives the frame's address Destroy the coroutine frame Coroutine Promise Requirement ( pthread_joiner_t::promise_type ) final_suspend == true to prevent destruction of the frame after co_return await_transform to allow co_await on pthread_attr_t* In other words, pthread_attr_t* becomes an awaitable only when the pthread_joiner_t is return type. Define return_void since resume_on_pthread already has a return value Awaitable type: pthread_spawner_t Advanced awaitable type It saves the new pthread's id in the promise_type Nested in the pthread_joiner_t to prevent misusage There is no direct use of pthread_spawner_t However, we only wrapped pthread life cycle functions. So if the coroutine invokes pthread_exit instead of co_return , the assumption of the pthread_joiner_t will be broken. I couldn't find a way to deal with the case.","title":"Combining all together"},{"location":"articles/designing-the-channel/","text":"Designing the coroutine channel This is a design note for the channel<T> . It's one of the oldest feature in this library. In this article, I will write about the design background of the type. Summary John Bandela already talked about the coroutine based channel in CppCon 2016 . However, I designed more limited one on my own. auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ok == true: we sent a value // ... co_await ch . read (); // we can read in the writer coroutine } } auto consumer_owner () -> no_return { channel < int > ch {}; producer ( ch ); // start a producer routine // the type doesn't support for-co_await for now for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: we received a value if ( msg == bye ) break ; co_await ch . write ( msg ); // we can write in the reader coroutine } } You can visit more test codes for the type: test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp test/channel_ownership_consumer.cpp test/channel_ownership_producer.cpp Note Motivation(Background) There are multiple ways to deliver value(normally an object) from a routine to another routine. channel<T> is designed to play a role as one of them. Before the coroutine Before the C++ Coroutine becames available, there were 2 ways. return : from callee subroutine to caller subroutine future<T> since C++11 : return with synchronization(shared state) return forwards a T type object from callee subroutine to caller subroutine. C++ 11 future<T> , do the same work but uses a shared state to provide synchronization. As we know, such a synchronization is for multi-threaded code. One of those methods' limitation is that they can deliver only 1 object (of T type), only 1 time (with the return ). Which makes inconvenience sometimes... After the coroutine By adopting coroutine to our world, now we can suspend, and get a new way of delivery. task<T> : 1 time delivery, from a coroutine to another coroutine generator<T> : multi-time delivery, from the generator coroutine to activator coroutine task<T> is the simplest way to get co_return from a coroutine. The most important design point for a coroutine function is that managing suspension( co_await ). It's because suspension is more general than finalization( co_return ). task<T> deals with the cases and activates(resumes) awaiting coroutine when the activatee coroutine returns. generator<T> uses co_yield to deliver value from activatee(generator coroutine) to activator(resumer subroutine) multiple times. For us, co_yield itself is a syntatic sugar that invokes yield_value and evaluate co_await (therefore, suspend) at the same time. Indeed there is a harmony in the way generator<T> works. However, what if we can't acquire the value from generator<T> immediately? What if advancing its iterator is asynchronous? async_generator<T> : generator<T> + awaitable iterator So async_generator<T> allows us to attach a coroutine which will be resumed when the generator coroutine can yield(perform the delivery). In my perspective, using co_await on its iterator is indeed a good idea for the interface design. Its user code remains very similar to that of the generator<T> The consumer coroutine is resumed automatically, so there is no coverage leak You can review existing implementations. Please let me know if there is another implementations so I can add them :) From the https://github.com/kirkshoop/await In this library, which is based on kirkshoop's work, sequence<T> From the adorable cppcoro Another type of the delivery? At this point, we can recognize that we don't have a bidirectional delivery . generator<T> delivers its co_yield ed value only in 1 direction, and so does async_generator<T> . Also, if we need to write multi-threaded code, there are still needs of the synchronization. It depends on the pattern and can managed well, but it's still hard to the beginners. For nondirectional delivery, there is a good example in the Go language. It's channel . The channel can suspend both producer and consumer goroutines by affecting their scheduling. Notice the difference between the C++ coroutine and Go goroutine. C++ coroutine doesn't have built-in scheduling for it. coroutine_handle<T> itself is a pointer, and the programmer manages them manually. Requirement So the requirement for our new type is like the following. channel<T> Non-directional delivery (at least bidirectional) Optional synchronization Coverage leak prevention Invalidation Zero allocation Non-directional delivery We should be able to write/read to a channel in a same coroutine. It's convenient. And that is important for the beginners. Optional synchronization It supports single-threaded code and there must be zero-cost in the case. Coverage leak prevention The type must prevent coverage leak. That means, it must do its best to make related coroutines reach their ends. Invalidation The channel must be able to notify its invalidation. So its user code can handle the operation failure and prevent undefined behavior while they are writing the code. With the coverage requirement above, user will co_return the coroutine, or delegate its work somehow. Zero allocation new / delete is not allowed to avoid unnecessary cost. Design Concerns Optional synchronization The logic will remain while user applies different synchronization types. So the type will use be template. template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class channel final { public : using mutex_type = M ; private : mutex_type mtx ; } Also, as you can see above, it will use do nothing lockable by default. // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } }; Invalidation unlike the channel of Go, the type doesn't provide explicit close operation Explicit close is simple enough because we can just check the channel's state and break the loop. But it is highly possible that user will carefully design the value if there is no close . Suppose we have a close for the channel: auto producer ( channel < int >& ch ) -> no_return { int msg {}; // ... while ( ch . closed () == false ){ co_await ch . write ( msg ); // ... if ( cond ) break ; } ch . close (); // ok, no more value co_return ; } auto consumer ( channel < int >& ch ) -> no_return { while ( ch . closed () == false ){ int msg = co_await ch . read (); // ... } } In this case, user will think about the state of the channel. The following questions can be managed by patternized code, but will always arise from the existance of close . Which line should the close placed? When it's already closed, what should I do for read/write? When we don't have a close , users will think about another issue. When should I stop the read/write? The question is about managing the loop, and probably they will use something like EOF (sentinel value). In my perspective, it is more likely to have well-designed space for the value_type of the channel: auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { co_await ch . write ( msg ); // ... } } auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } Implementation Watching the CppCon 2016 talk will help you a lot for the following notes. Making a linked list of the coroutine frames Since coroutine frames are allocated separatly, we can use them like a node in the linked list. By placing next pointer in those frame, we can make zero-allocation channel. Actually they are a kind of pre-allocation since the cost is already paid in the frame construction(invocation) steps. So it will be enough for channel<T> to have 2 linked lists and 1 mutex to operate correctly under multi-threaded code. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... private : mutex_type mtx ; } To make a linked list of the coroutine frames, the type places an objects in the coroutine frame that containes next pointer. // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... public : // place a writer in the coroutine's frame decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // place a reader in the coroutine's frame decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; You can find next pointer in the following writer and reader . Notice that they have a reserved space to receive coroutine_handle<void> from await_suspend . template < typename T , typename M > class writer final { public : using value_type = T ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; union { writer * next = nullptr ; // Next writer in the channel channel_type * chan ; }; }; template < typename T , typename M > class reader { public : using value_type = T ; using channel_type = channel < T , M > ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; union { reader * next = nullptr ; // Next reader in the channel channel_type * chan ; }; }; By the design we will placing objects in the frame. Such an implementation can make the frame's size larger than expected. So operating with the channel with multiple lines will grow the frame more than required. // Bad code auto too_much_read ( channel < int >& ch ) -> no_return { co_await ch . read (); co_await ch . read (); co_await ch . read (); co_await ch . read (); // uses 24 bytes per each operation !!! // ... } But unless it's used with for statement, there will be at most 2 read/writes. So it won't be that serious memory. // at most 2 operation in 1 for loop auto consumer ( channel < int >& ch ) -> no_return { for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ... } } auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ... } } Preventing Coverage Leak We all know that RAII is the best way to make the type system work for us. Let's consider about it. What is the proper behavior of the linked list on its destruction? Like the std::list<T> , it must delete its existing nodes to prevent memory leak. Unfortunately, this case is really special because the nodes are existing coroutines' frame. That means, if we free the node, it will destroy all objects in the frame. That's really brutal because it can break all existing expectations of the function that manages its frame manually (with customized promise_type ). So the appropriate behavior is to resume those frames and let them recognize that they can't access the channel anymore. In its destructor , channel<T, M> resumes all awaiting coroutines in its linked lists. Notice the destructor is specified noexcept(false) because typically resume operation is not guaranteed noexcept . template < typename T , typename M > class channel { // ... ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; size_t repeat = 1 ; while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); // <-- use a poison value coro . resume (); // <-- resume write operations } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); // <-- resume read operations } } } } With the behavior, user code must be changed like the following. It receive not only a value from the channel but also one bool that notifies the channel is still accessible. // Before auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } // After auto consumer ( channel < int >& ch ) -> no_return { // it's returning tuple, // declare memory objects using structured binding for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: the channel is accessible // ... } } By doing so, if the reader/writer coroutines are written correctly, channel can guarantee there is no dangling coroutines in its linked lists, and prevent coverage leak of them. Using a poison in await_resume I used poison to replace explicit close . Remember that the co_await expression is affected by await_resume . Returning a tuple from the function can constrain user's code. In the implementation, to decide to return true or false , both reader<T, M> and writer<T, M> have to check if the poison is delivered. // Awaitable for channel's read operation template < typename T , typename M > class reader { // ... auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; Unlike reader, writer just returns bool . The signature makes its return can be used in if or while conveniently. // Awaitable for channel's write operation template < typename T , typename M > class writer final { // ... bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; Furthermore, the signature makes user to places a boolean in the coroutine's frame, not in the channel . So it's on-demand cost. Skip: await_ready and await_suspend This part is realted to the requirement, optional synchronization. It will be covered later because they are purely about the implementation. If you are really curious, visit this page . Conclusion The type doesn't weighted for the performance. What I focused was to enforce intuitive code and to guide users' consideration to their behavior (and undelying semantics). It's not replacement nor alternative of the other delivery methods. To summarize each methods, return : 1 time, directional, subroutine to subroutine future<T> : 1 time, directional, subroutine to subroutine, synchronization(shared state) task<T> : 1 time, directional, coroutine to coroutine generator<T> : multi-time, directional, coroutine to coroutine asnyc_generator<T> : multi-time, directional, coroutine to coroutine, awaitable iterator channel<T> : multi-time (with suspend), non-directional, optional synchronization For channel<T> itself... Non-directional delivery You can see the example with the Compiler Explorer(MSVC) or with the WandBox(clang-8) Coverage Leak For the requirement, channel becomes a linked list of each reader and writer. Its operations place reader/writer object in the coroutine frame. In the destructor, all objects in linked lists receive the poison value. Invalidation (Close Status) To detect invalidation of the channel, we check the poison value in the await_resume function. It's signature enforces to make a memory object( ok in the example) to receive channel's status. When the poison is delivered, co_await on the reader/writer will return false , so the user can break the loop. This can be done without use of close operation.","title":"Designing the coroutine channel"},{"location":"articles/designing-the-channel/#designing-the-coroutine-channel","text":"This is a design note for the channel<T> . It's one of the oldest feature in this library. In this article, I will write about the design background of the type.","title":"Designing the coroutine channel"},{"location":"articles/designing-the-channel/#summary","text":"John Bandela already talked about the coroutine based channel in CppCon 2016 . However, I designed more limited one on my own. auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ok == true: we sent a value // ... co_await ch . read (); // we can read in the writer coroutine } } auto consumer_owner () -> no_return { channel < int > ch {}; producer ( ch ); // start a producer routine // the type doesn't support for-co_await for now for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: we received a value if ( msg == bye ) break ; co_await ch . write ( msg ); // we can write in the reader coroutine } } You can visit more test codes for the type: test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp test/channel_ownership_consumer.cpp test/channel_ownership_producer.cpp","title":"Summary"},{"location":"articles/designing-the-channel/#note","text":"","title":"Note"},{"location":"articles/designing-the-channel/#motivationbackground","text":"There are multiple ways to deliver value(normally an object) from a routine to another routine. channel<T> is designed to play a role as one of them.","title":"Motivation(Background)"},{"location":"articles/designing-the-channel/#before-the-coroutine","text":"Before the C++ Coroutine becames available, there were 2 ways. return : from callee subroutine to caller subroutine future<T> since C++11 : return with synchronization(shared state) return forwards a T type object from callee subroutine to caller subroutine. C++ 11 future<T> , do the same work but uses a shared state to provide synchronization. As we know, such a synchronization is for multi-threaded code. One of those methods' limitation is that they can deliver only 1 object (of T type), only 1 time (with the return ). Which makes inconvenience sometimes...","title":"Before the coroutine"},{"location":"articles/designing-the-channel/#after-the-coroutine","text":"By adopting coroutine to our world, now we can suspend, and get a new way of delivery. task<T> : 1 time delivery, from a coroutine to another coroutine generator<T> : multi-time delivery, from the generator coroutine to activator coroutine task<T> is the simplest way to get co_return from a coroutine. The most important design point for a coroutine function is that managing suspension( co_await ). It's because suspension is more general than finalization( co_return ). task<T> deals with the cases and activates(resumes) awaiting coroutine when the activatee coroutine returns. generator<T> uses co_yield to deliver value from activatee(generator coroutine) to activator(resumer subroutine) multiple times. For us, co_yield itself is a syntatic sugar that invokes yield_value and evaluate co_await (therefore, suspend) at the same time. Indeed there is a harmony in the way generator<T> works. However, what if we can't acquire the value from generator<T> immediately? What if advancing its iterator is asynchronous? async_generator<T> : generator<T> + awaitable iterator So async_generator<T> allows us to attach a coroutine which will be resumed when the generator coroutine can yield(perform the delivery). In my perspective, using co_await on its iterator is indeed a good idea for the interface design. Its user code remains very similar to that of the generator<T> The consumer coroutine is resumed automatically, so there is no coverage leak You can review existing implementations. Please let me know if there is another implementations so I can add them :) From the https://github.com/kirkshoop/await In this library, which is based on kirkshoop's work, sequence<T> From the adorable cppcoro","title":"After the coroutine"},{"location":"articles/designing-the-channel/#another-type-of-the-delivery","text":"At this point, we can recognize that we don't have a bidirectional delivery . generator<T> delivers its co_yield ed value only in 1 direction, and so does async_generator<T> . Also, if we need to write multi-threaded code, there are still needs of the synchronization. It depends on the pattern and can managed well, but it's still hard to the beginners. For nondirectional delivery, there is a good example in the Go language. It's channel . The channel can suspend both producer and consumer goroutines by affecting their scheduling. Notice the difference between the C++ coroutine and Go goroutine. C++ coroutine doesn't have built-in scheduling for it. coroutine_handle<T> itself is a pointer, and the programmer manages them manually.","title":"Another type of the delivery?"},{"location":"articles/designing-the-channel/#requirement","text":"So the requirement for our new type is like the following. channel<T> Non-directional delivery (at least bidirectional) Optional synchronization Coverage leak prevention Invalidation Zero allocation","title":"Requirement"},{"location":"articles/designing-the-channel/#non-directional-delivery","text":"We should be able to write/read to a channel in a same coroutine. It's convenient. And that is important for the beginners.","title":"Non-directional delivery"},{"location":"articles/designing-the-channel/#optional-synchronization","text":"It supports single-threaded code and there must be zero-cost in the case.","title":"Optional synchronization"},{"location":"articles/designing-the-channel/#coverage-leak-prevention","text":"The type must prevent coverage leak. That means, it must do its best to make related coroutines reach their ends.","title":"Coverage leak prevention"},{"location":"articles/designing-the-channel/#invalidation","text":"The channel must be able to notify its invalidation. So its user code can handle the operation failure and prevent undefined behavior while they are writing the code. With the coverage requirement above, user will co_return the coroutine, or delegate its work somehow.","title":"Invalidation"},{"location":"articles/designing-the-channel/#zero-allocation","text":"new / delete is not allowed to avoid unnecessary cost.","title":"Zero allocation"},{"location":"articles/designing-the-channel/#design-concerns","text":"","title":"Design Concerns"},{"location":"articles/designing-the-channel/#optional-synchronization_1","text":"The logic will remain while user applies different synchronization types. So the type will use be template. template < typename T , typename M = bypass_lock > class channel ; // by default, channel doesn't care about the race condition template < typename T , typename M > class channel final { public : using mutex_type = M ; private : mutex_type mtx ; } Also, as you can see above, it will use do nothing lockable by default. // Lockable without lock operation. struct bypass_lock final { constexpr bool try_lock () noexcept { return true ; } constexpr void lock () noexcept { // do nothing since this is 'bypass' lock } constexpr void unlock () noexcept { // it is not locked } };","title":"Optional synchronization"},{"location":"articles/designing-the-channel/#invalidation_1","text":"unlike the channel of Go, the type doesn't provide explicit close operation Explicit close is simple enough because we can just check the channel's state and break the loop. But it is highly possible that user will carefully design the value if there is no close . Suppose we have a close for the channel: auto producer ( channel < int >& ch ) -> no_return { int msg {}; // ... while ( ch . closed () == false ){ co_await ch . write ( msg ); // ... if ( cond ) break ; } ch . close (); // ok, no more value co_return ; } auto consumer ( channel < int >& ch ) -> no_return { while ( ch . closed () == false ){ int msg = co_await ch . read (); // ... } } In this case, user will think about the state of the channel. The following questions can be managed by patternized code, but will always arise from the existance of close . Which line should the close placed? When it's already closed, what should I do for read/write? When we don't have a close , users will think about another issue. When should I stop the read/write? The question is about managing the loop, and probably they will use something like EOF (sentinel value). In my perspective, it is more likely to have well-designed space for the value_type of the channel: auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { co_await ch . write ( msg ); // ... } } auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } }","title":"Invalidation"},{"location":"articles/designing-the-channel/#implementation","text":"Watching the CppCon 2016 talk will help you a lot for the following notes.","title":"Implementation"},{"location":"articles/designing-the-channel/#making-a-linked-list-of-the-coroutine-frames","text":"Since coroutine frames are allocated separatly, we can use them like a node in the linked list. By placing next pointer in those frame, we can make zero-allocation channel. Actually they are a kind of pre-allocation since the cost is already paid in the frame construction(invocation) steps. So it will be enough for channel<T> to have 2 linked lists and 1 mutex to operate correctly under multi-threaded code. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... private : mutex_type mtx ; } To make a linked list of the coroutine frames, the type places an objects in the coroutine frame that containes next pointer. // Coroutine based channel. User have to provide appropriate lockable template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { // ... public : // place a writer in the coroutine's frame decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // place a reader in the coroutine's frame decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; You can find next pointer in the following writer and reader . Notice that they have a reserved space to receive coroutine_handle<void> from await_suspend . template < typename T , typename M > class writer final { public : using value_type = T ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; union { writer * next = nullptr ; // Next writer in the channel channel_type * chan ; }; }; template < typename T , typename M > class reader { public : using value_type = T ; using channel_type = channel < T , M > ; protected : mutable pointer ptr ; // Address of value mutable void * frame ; union { reader * next = nullptr ; // Next reader in the channel channel_type * chan ; }; }; By the design we will placing objects in the frame. Such an implementation can make the frame's size larger than expected. So operating with the channel with multiple lines will grow the frame more than required. // Bad code auto too_much_read ( channel < int >& ch ) -> no_return { co_await ch . read (); co_await ch . read (); co_await ch . read (); co_await ch . read (); // uses 24 bytes per each operation !!! // ... } But unless it's used with for statement, there will be at most 2 read/writes. So it won't be that serious memory. // at most 2 operation in 1 for loop auto consumer ( channel < int >& ch ) -> no_return { for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ... } } auto producer ( channel < int >& ch ) -> no_return { for ( int msg : { 1 , 2 , 3 , bye }) { auto ok = co_await ch . write ( msg ); // ... } }","title":"Making a linked list of the coroutine frames"},{"location":"articles/designing-the-channel/#preventing-coverage-leak","text":"We all know that RAII is the best way to make the type system work for us. Let's consider about it. What is the proper behavior of the linked list on its destruction? Like the std::list<T> , it must delete its existing nodes to prevent memory leak. Unfortunately, this case is really special because the nodes are existing coroutines' frame. That means, if we free the node, it will destroy all objects in the frame. That's really brutal because it can break all existing expectations of the function that manages its frame manually (with customized promise_type ). So the appropriate behavior is to resume those frames and let them recognize that they can't access the channel anymore. In its destructor , channel<T, M> resumes all awaiting coroutines in its linked lists. Notice the destructor is specified noexcept(false) because typically resume operation is not guaranteed noexcept . template < typename T , typename M > class channel { // ... ~ channel () noexcept ( false ) // channel can't provide exception guarantee... { writer_list & writers = * this ; reader_list & readers = * this ; size_t repeat = 1 ; while ( repeat -- ) { unique_lock lck { mtx }; while ( writers . is_empty () == false ) { writer * w = writers . pop (); auto coro = coroutine_handle < void >:: from_address ( w -> frame ); w -> frame = internal :: poison (); // <-- use a poison value coro . resume (); // <-- resume write operations } while ( readers . is_empty () == false ) { reader * r = readers . pop (); auto coro = coroutine_handle < void >:: from_address ( r -> frame ); r -> frame = internal :: poison (); coro . resume (); // <-- resume read operations } } } } With the behavior, user code must be changed like the following. It receive not only a value from the channel but also one bool that notifies the channel is still accessible. // Before auto consumer ( channel < int >& ch ) -> no_return { int msg {}; for ( co_await ch . read ( msg ); msg != bye ; co_await ch . read ( msg )){ // ... } } // After auto consumer ( channel < int >& ch ) -> no_return { // it's returning tuple, // declare memory objects using structured binding for ( auto [ msg , ok ] = co_await ch . read (); ok ; tie ( msg , ok ) = co_await ch . read ()) { // ok == true: the channel is accessible // ... } } By doing so, if the reader/writer coroutines are written correctly, channel can guarantee there is no dangling coroutines in its linked lists, and prevent coverage leak of them.","title":"Preventing Coverage Leak"},{"location":"articles/designing-the-channel/#using-a-poison-in-await_resume","text":"I used poison to replace explicit close . Remember that the co_await expression is affected by await_resume . Returning a tuple from the function can constrain user's code. In the implementation, to decide to return true or false , both reader<T, M> and writer<T, M> have to check if the poison is delivered. // Awaitable for channel's read operation template < typename T , typename M > class reader { // ... auto await_resume () noexcept ( false ) -> tuple < value_type , bool > { auto t = make_tuple ( value_type {}, false ); // frame holds poision if the channel is going to be destroyed if ( this -> frame == internal :: poison ()) return t ; // Store first. we have to do this because the resume operation // can destroy the writer coroutine get < 0 > ( t ) = move ( * ptr ); if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); get < 1 > ( t ) = true ; return t ; } }; Unlike reader, writer just returns bool . The signature makes its return can be used in if or while conveniently. // Awaitable for channel's write operation template < typename T , typename M > class writer final { // ... bool await_resume () noexcept ( false ) { // frame holds poision if the channel is going to destroy if ( this -> frame == internal :: poison ()) return false ; if ( auto coro = coroutine_handle < void >:: from_address ( frame )) coro . resume (); return true ; } }; Furthermore, the signature makes user to places a boolean in the coroutine's frame, not in the channel . So it's on-demand cost.","title":"Using a poison in await_resume"},{"location":"articles/designing-the-channel/#skip-await_ready-and-await_suspend","text":"This part is realted to the requirement, optional synchronization. It will be covered later because they are purely about the implementation. If you are really curious, visit this page .","title":"Skip: await_ready and await_suspend"},{"location":"articles/designing-the-channel/#conclusion","text":"The type doesn't weighted for the performance. What I focused was to enforce intuitive code and to guide users' consideration to their behavior (and undelying semantics). It's not replacement nor alternative of the other delivery methods. To summarize each methods, return : 1 time, directional, subroutine to subroutine future<T> : 1 time, directional, subroutine to subroutine, synchronization(shared state) task<T> : 1 time, directional, coroutine to coroutine generator<T> : multi-time, directional, coroutine to coroutine asnyc_generator<T> : multi-time, directional, coroutine to coroutine, awaitable iterator channel<T> : multi-time (with suspend), non-directional, optional synchronization For channel<T> itself...","title":"Conclusion"},{"location":"articles/designing-the-channel/#non-directional-delivery_1","text":"You can see the example with the Compiler Explorer(MSVC) or with the WandBox(clang-8)","title":"Non-directional delivery"},{"location":"articles/designing-the-channel/#coverage-leak","text":"For the requirement, channel becomes a linked list of each reader and writer. Its operations place reader/writer object in the coroutine frame. In the destructor, all objects in linked lists receive the poison value.","title":"Coverage Leak"},{"location":"articles/designing-the-channel/#invalidation-close-status","text":"To detect invalidation of the channel, we check the poison value in the await_resume function. It's signature enforces to make a memory object( ok in the example) to receive channel's status. When the poison is delivered, co_await on the reader/writer will return false , so the user can break the loop. This can be done without use of close operation.","title":"Invalidation (Close Status)"},{"location":"articles/example-of-await_transform/","text":"Example: await_transform function of the promise_type Example code for await_transform . The code can be compiled with MSVC (v141) and Clang (6.0 or later). Compile the code with the Compiler Explorer! Clang: https://godbolt.org/z/EnNBrL MSVC: https://godbolt.org/z/eCVc6I Example // // Author : github.com/luncliff (luncliff@gmail.com) // // You can compile this code with MSVC (v19.14) and Clang (6.0 or later) // Be aware of the options: // clang: -fcoroutines-ts -stdlib=libc++ -std=c++2a // msvc : /await // #include <experimental/coroutine> using namespace std :: experimental ; #ifdef __clang__ using namespace std :: experimental :: coroutines_v1 ; // The definition is from // <experimental/resumable> in VC++ class suspend_if { bool cond ; public : suspend_if ( bool c ) : cond { c }{}; bool await_ready () const noexcept { return cond ; } void await_suspend ( coroutine_handle < void > ) noexcept {} void await_resume () noexcept {} }; #endif // end: clang compiler struct return_transform { struct promise_type { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_never {}; } auto get_return_object () -> promise_type * { return this ; } // Since `bool` is primitive type, it can't support operations // like `await_ready`, `await_suspend`, `await_resume` // However, we can provide `await_transform` for // `co_await` operator to receive well-formed awaitable type auto await_transform ( bool cond ) noexcept { return suspend_if { cond }; } // for `co_return` void return_void () noexcept {} // exception handling is important ! void unhandled_exception (){} }; return_transform ( promise_type * ) noexcept {} ~ return_transform () noexcept = default ; }; auto example () -> return_transform { co_await true ; // co_await p.await_transform(true); co_await false ; // co_await p.await_transform(false); co_return ; // p.return_void(); // goto __final_suspend_point; }","title":"Example: `await_transform` function of the `promise_type`"},{"location":"articles/example-of-await_transform/#example-await_transform-function-of-the-promise_type","text":"Example code for await_transform . The code can be compiled with MSVC (v141) and Clang (6.0 or later). Compile the code with the Compiler Explorer! Clang: https://godbolt.org/z/EnNBrL MSVC: https://godbolt.org/z/eCVc6I","title":"Example: await_transform function of the promise_type"},{"location":"articles/example-of-await_transform/#example","text":"// // Author : github.com/luncliff (luncliff@gmail.com) // // You can compile this code with MSVC (v19.14) and Clang (6.0 or later) // Be aware of the options: // clang: -fcoroutines-ts -stdlib=libc++ -std=c++2a // msvc : /await // #include <experimental/coroutine> using namespace std :: experimental ; #ifdef __clang__ using namespace std :: experimental :: coroutines_v1 ; // The definition is from // <experimental/resumable> in VC++ class suspend_if { bool cond ; public : suspend_if ( bool c ) : cond { c }{}; bool await_ready () const noexcept { return cond ; } void await_suspend ( coroutine_handle < void > ) noexcept {} void await_resume () noexcept {} }; #endif // end: clang compiler struct return_transform { struct promise_type { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_never {}; } auto get_return_object () -> promise_type * { return this ; } // Since `bool` is primitive type, it can't support operations // like `await_ready`, `await_suspend`, `await_resume` // However, we can provide `await_transform` for // `co_await` operator to receive well-formed awaitable type auto await_transform ( bool cond ) noexcept { return suspend_if { cond }; } // for `co_return` void return_void () noexcept {} // exception handling is important ! void unhandled_exception (){} }; return_transform ( promise_type * ) noexcept {} ~ return_transform () noexcept = default ; }; auto example () -> return_transform { co_await true ; // co_await p.await_transform(true); co_await false ; // co_await p.await_transform(false); co_return ; // p.return_void(); // goto __final_suspend_point; }","title":"Example"},{"location":"ppt/Exploring-the-Cpp-Coroutine/","text":"Exploring the C++ Coroutine: Approach, Compiler, and Issues Note I had a presentation in C++ Korea Facebook Group 's 5th Seminar . You can download and share it :) Links PDF: Exploring The C++ Coroutine / \ud55c\uad6d\uc5b4 OneDrive: Eng / \ud55c\uad6d\uc5b4","title":"PPT - C++ Korea 5th Seminar"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#exploring-the-c-coroutine-approach-compiler-and-issues","text":"","title":"Exploring the C++ Coroutine: Approach, Compiler, and Issues"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#note","text":"I had a presentation in C++ Korea Facebook Group 's 5th Seminar . You can download and share it :)","title":"Note"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#links","text":"PDF: Exploring The C++ Coroutine / \ud55c\uad6d\uc5b4 OneDrive: Eng / \ud55c\uad6d\uc5b4","title":"Links"}]}