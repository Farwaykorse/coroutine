{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Home/","text":"Latest Release is 1.4.3 Welcome to the luncliff/coroutine wiki! Please explore the pages with this link(GitHub Pages) If you have opinion for these docs, please create an issue and claim your idea. Let me hear you and write more helpful contents. :D Developer's Notes Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine (\ud55c\uad6d\uc5b4) - the PDF is here! Notes Awaitable event using coroutine, epoll , and eventfd Thread selecting functions Examples promise_type::await_transform First with the C++ 20 Coroutine? If you want how the feature works , see the 'Exploring The C++ Coroutine' above. If you're finding any bunch of good references , visit the MattPD's collection ! If you want to run it now , there is a little WandBox example ... but it's poor for now. I will write a new one and update the link ASAP. Library Features I've used the C++ coroutine since 2017.02 . Currently working to follow the C++ 20 and writing examples in my style. Coroutine Handle Works related to <coroutine> header are placed in 1 file. #include <coroutine/frame.h> using namespace std :: experimental ; coroutine_handle<P> Frame prefix coroutine_traits<R, P...> suspend_never and suspend_always Return Type for the Coroutine #include <coroutine/return.h> using namespace coro ; no_return frame Yield #include <coroutine/yield.hpp> using namespace coro ; enumerable<T> sequence<T> Network I/O The socket async I/O related features are adopting Guideline Support Library . The type/functions don't have namespace for now. (They are global !) #include <coroutine/net.h> using namespace gsl ; Overview Working with the system's API Winsock 2 Epoll KQueue Channel #include <coroutine/channel.hpp> using namespace coro ; Concept Read & Write Select Concurrency Utilities #include <coroutine/concrt.h> using namespace concrt ; Windows latch section ptp_work ptp_event POSIX section Event Polling pthread","title":"Home"},{"location":"Home/#developers-notes","text":"Presentations C++ Korea 5th Seminar: Exploring The C++ Coroutine (\ud55c\uad6d\uc5b4) - the PDF is here! Notes Awaitable event using coroutine, epoll , and eventfd Thread selecting functions Examples promise_type::await_transform","title":"Developer's Notes"},{"location":"Home/#first-with-the-c-20-coroutine","text":"If you want how the feature works , see the 'Exploring The C++ Coroutine' above. If you're finding any bunch of good references , visit the MattPD's collection ! If you want to run it now , there is a little WandBox example ... but it's poor for now. I will write a new one and update the link ASAP.","title":"First with the C++ 20 Coroutine?"},{"location":"Home/#library-features","text":"I've used the C++ coroutine since 2017.02 . Currently working to follow the C++ 20 and writing examples in my style.","title":"Library Features"},{"location":"Home/#coroutine-handle","text":"Works related to <coroutine> header are placed in 1 file. #include <coroutine/frame.h> using namespace std :: experimental ; coroutine_handle<P> Frame prefix coroutine_traits<R, P...> suspend_never and suspend_always","title":"Coroutine Handle"},{"location":"Home/#return-type-for-the-coroutine","text":"#include <coroutine/return.h> using namespace coro ; no_return frame","title":"Return Type for the Coroutine"},{"location":"Home/#yield","text":"#include <coroutine/yield.hpp> using namespace coro ; enumerable<T> sequence<T>","title":"Yield"},{"location":"Home/#network-io","text":"The socket async I/O related features are adopting Guideline Support Library . The type/functions don't have namespace for now. (They are global !) #include <coroutine/net.h> using namespace gsl ; Overview Working with the system's API Winsock 2 Epoll KQueue","title":"Network I/O"},{"location":"Home/#channel","text":"#include <coroutine/channel.hpp> using namespace coro ; Concept Read & Write Select","title":"Channel"},{"location":"Home/#concurrency-utilities","text":"#include <coroutine/concrt.h> using namespace concrt ; Windows latch section ptp_work ptp_event POSIX section Event Polling pthread","title":"Concurrency Utilities"},{"location":"_Footer/","text":"This work is licensed under a Creative Commons Attribution 4.0 International License .","title":" Footer"},{"location":"build-using-cmake/","text":"How To Build: CMake Project Known Configurations Did you saw the status badges in the ReadMe ? This library relies on various CI services. I'm testing the build with the following configurations. You can create an issue (of course PR will be wellcomed!) if you can't try one of them. Also, if you think some complex configuration must be tested (for your development!), let me know with the issue! Linux Azure Pipelines Travis CI I'm testing with Ubuntu distribution because it's the CI services above uses them. I think build test with Docker might be possible. The option is reserved for really complex conditions. Ubuntu Travis CI Installing libc++ By default the environment won't have libc++. We need it to use <experimental/coroutine> . This library has a custom implementation so it can deal with the problem, but it is obvious that installing libc++ is more helpful and practical. Review this script file and run the installation with sudo . # suppose you are in coroutine/ sudo bash ./scripts/install-libc++8.sh ; ToDo: can we install the latest with apt? Android Travis CI Mac OS Azure Pipelines Travis CI iPhone OS Travis CI Windows Azure Pipelines AppVeyor You can try with the Visual Studio. But it's a Cross-Platform Make! How can I ignore the charming OS? Well, the configuration for the Windows OS is a bit special. It supports Clang-cl build. Visual Studio Just set the Generator as Visual Studio. LLVM Clang-cl The build support only static build for now. The known issue for this config is that clang's symbol generation doesn't fit for Windows DLL linkage. ToDo: Detail for the failure for the Windows DLL + Clang-cl Currently, the repo uses static build for Clang-cl. Build log (AppVeyor) . Install Chocolatey & Packages Chocolatey can be installed easily. Follow the official page ! Did you finished installation? We need 2 packages. The first one is LLVM, and the other is Ninja . choco install -y ninja ; choco install -y llvm ; After the installation, don't forget to check the version $ ninja --version ... $ choco info llvm ... Notice that the build tool will invoke clang through clang-cl . $ clang-cl --version ... Invoke vcvarsall.bat Specify I prefer setting $env:CXX via console in this case. For Powershell, you can set the variable using the following command. $env:CXX = \"clang-cl\" As you can see in this file , for Cmdlet, it's a bit different. set CXX=clang-cl However, if you hate using environment variable, you can set CMAKE_C_COMPILER and CMAKE_CXX_COMPILER in CMake configuration. cmake -G \"Ninja\" -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_C_COMPILER=clang-cl","title":"CMake"},{"location":"build-using-cmake/#how-to-build-cmake-project","text":"","title":"How To Build: CMake Project"},{"location":"build-using-cmake/#known-configurations","text":"Did you saw the status badges in the ReadMe ? This library relies on various CI services. I'm testing the build with the following configurations. You can create an issue (of course PR will be wellcomed!) if you can't try one of them. Also, if you think some complex configuration must be tested (for your development!), let me know with the issue!","title":"Known Configurations"},{"location":"build-using-cmake/#linux","text":"Azure Pipelines Travis CI I'm testing with Ubuntu distribution because it's the CI services above uses them. I think build test with Docker might be possible. The option is reserved for really complex conditions.","title":"Linux"},{"location":"build-using-cmake/#ubuntu","text":"Travis CI","title":"Ubuntu"},{"location":"build-using-cmake/#installing-libc","text":"By default the environment won't have libc++. We need it to use <experimental/coroutine> . This library has a custom implementation so it can deal with the problem, but it is obvious that installing libc++ is more helpful and practical. Review this script file and run the installation with sudo . # suppose you are in coroutine/ sudo bash ./scripts/install-libc++8.sh ; ToDo: can we install the latest with apt?","title":"Installing libc++"},{"location":"build-using-cmake/#android","text":"Travis CI","title":"Android"},{"location":"build-using-cmake/#mac-os","text":"Azure Pipelines Travis CI","title":"Mac OS"},{"location":"build-using-cmake/#iphone-os","text":"Travis CI","title":"iPhone OS"},{"location":"build-using-cmake/#windows","text":"Azure Pipelines AppVeyor You can try with the Visual Studio. But it's a Cross-Platform Make! How can I ignore the charming OS? Well, the configuration for the Windows OS is a bit special. It supports Clang-cl build.","title":"Windows"},{"location":"build-using-cmake/#visual-studio","text":"Just set the Generator as Visual Studio.","title":"Visual Studio"},{"location":"build-using-cmake/#llvm-clang-cl","text":"The build support only static build for now. The known issue for this config is that clang's symbol generation doesn't fit for Windows DLL linkage. ToDo: Detail for the failure for the Windows DLL + Clang-cl Currently, the repo uses static build for Clang-cl. Build log (AppVeyor) .","title":"LLVM Clang-cl"},{"location":"build-using-cmake/#install-chocolatey-packages","text":"Chocolatey can be installed easily. Follow the official page ! Did you finished installation? We need 2 packages. The first one is LLVM, and the other is Ninja . choco install -y ninja ; choco install -y llvm ; After the installation, don't forget to check the version $ ninja --version ... $ choco info llvm ... Notice that the build tool will invoke clang through clang-cl . $ clang-cl --version ...","title":"Install Chocolatey &amp; Packages"},{"location":"build-using-cmake/#invoke-vcvarsallbat","text":"","title":"Invoke vcvarsall.bat"},{"location":"build-using-cmake/#specify","text":"I prefer setting $env:CXX via console in this case. For Powershell, you can set the variable using the following command. $env:CXX = \"clang-cl\" As you can see in this file , for Cmdlet, it's a bit different. set CXX=clang-cl However, if you hate using environment variable, you can set CMAKE_C_COMPILER and CMAKE_CXX_COMPILER in CMake configuration. cmake -G \"Ninja\" -DCMAKE_CXX_COMPILER=clang-cl -DCMAKE_C_COMPILER=clang-cl","title":"Specify"},{"location":"build-using-visualstudio/","text":"How To Build: Visual Studio Before Build ... Check the Windows SDK and Visual Studio Tool/Compiler/Platform are listed in the 1.4.2 release note's 'Support' section . Visual Studio 2017, 2019 msvc : vc141, vc142 CMake (3.14 or later) clang-cl : 7.0.1, 8.0 Windows SDK 10.0.17134 10.0.14393 The list will be updated for every release. And the maintenance of those configs are top priority because it is the baseline for the purpose of this repo. You know, if you can't build & run this repo, how can people try the feature? Never hesitate to create a new issue for your configuration . Follow the steps! Clone the repo and submodules Nothing special. git clone + git submodule will do the work! PS D:\\> git clone https://github.com/luncliff/coroutine PS D:\\> cd .\\coroutine\\ PS D:\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/coroutine/external/guideline'... Cloning into 'D:/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' Open the Visual Studio Assuming you are using PowerShell. If not, just double-click the coroutine.sln . PS D:\\coroutine> Invoke-Item .\\coroutine.sln The solution file includes 1 DLL project and the others are Visual Studio Native Test projects. And don't forget that this project is only for x64 . The x86 arch is supported by MSVC, but it's not in the maintenance plan for now. Review the modules/windows.vcxproj Mostly you have to change Windows SDK Version that you are going to use. As far as I know, you don't need to touch the other settings. However, try the combinations and bother the VC++ team :D (not me!) Try The Build/Test! Press Ctrl + Shift + B to start the solution build. Afther the first build is done, open the 'Test Explorer' and run the tests. If the test runs well, it's done! The network test might fail because of permission or firewall issue. Or you can't sure about the reason, please, create an issue. The library still needs more tests. If all tests fail immediately, it must be the issue of the test execution. Check the 'Test > Test Settings > Default Processor Architecture'. Select the x64 .","title":"Visual Studio"},{"location":"build-using-visualstudio/#how-to-build-visual-studio","text":"","title":"How To Build: Visual Studio"},{"location":"build-using-visualstudio/#before-build","text":"","title":"Before Build ..."},{"location":"build-using-visualstudio/#check-the-windows-sdk-and-visual-studio","text":"Tool/Compiler/Platform are listed in the 1.4.2 release note's 'Support' section . Visual Studio 2017, 2019 msvc : vc141, vc142 CMake (3.14 or later) clang-cl : 7.0.1, 8.0 Windows SDK 10.0.17134 10.0.14393 The list will be updated for every release. And the maintenance of those configs are top priority because it is the baseline for the purpose of this repo. You know, if you can't build & run this repo, how can people try the feature? Never hesitate to create a new issue for your configuration .","title":"Check the Windows SDK and Visual Studio"},{"location":"build-using-visualstudio/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"build-using-visualstudio/#clone-the-repo-and-submodules","text":"Nothing special. git clone + git submodule will do the work! PS D:\\> git clone https://github.com/luncliff/coroutine PS D:\\> cd .\\coroutine\\ PS D:\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/coroutine/external/guideline'... Cloning into 'D:/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a'","title":"Clone the repo and submodules"},{"location":"build-using-visualstudio/#open-the-visual-studio","text":"Assuming you are using PowerShell. If not, just double-click the coroutine.sln . PS D:\\coroutine> Invoke-Item .\\coroutine.sln The solution file includes 1 DLL project and the others are Visual Studio Native Test projects. And don't forget that this project is only for x64 . The x86 arch is supported by MSVC, but it's not in the maintenance plan for now.","title":"Open the Visual Studio"},{"location":"build-using-visualstudio/#review-the-moduleswindowsvcxproj","text":"Mostly you have to change Windows SDK Version that you are going to use. As far as I know, you don't need to touch the other settings. However, try the combinations and bother the VC++ team :D (not me!)","title":"Review the modules/windows.vcxproj"},{"location":"build-using-visualstudio/#try-the-buildtest","text":"Press Ctrl + Shift + B to start the solution build. Afther the first build is done, open the 'Test Explorer' and run the tests. If the test runs well, it's done! The network test might fail because of permission or firewall issue. Or you can't sure about the reason, please, create an issue. The library still needs more tests. If all tests fail immediately, it must be the issue of the test execution. Check the 'Test > Test Settings > Default Processor Architecture'. Select the x64 .","title":"Try The Build/Test!"},{"location":"channel-overview/","text":"Overview: Coroutine based channel This is a simplified form of channel in The Go Language . Just like this library, several C++ coroutine libraries already has their own implementation of the concept. So it might be redundant to have another implementation in this repositoty, but this is one of the very first type I've wrote after the feature becomes available. Debugging its examples will help you to enhance understanding of the coroutine and which trick can be possible. See Also Go Channel types A Tour of Go: Channels CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" If you're first with the concept, I strongly recommend you to see the talk above even though I've implemented it in a different way. Example test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp Channel with a Lockable When channel<T> is used, which means that bypass_lock is used, channel doesn't care about the race condition (NOT MT-safe). Therefore, user have to provide an appropriate Lockable type and instance if it must be MT-safe As a result, the type doesn't support copy/move since typically those operations are unavailable for Lockable objects. namespace coro { // // The channel is a stream of values. // `channel<T>` isn't MT-safe (using `bypass_lock`). // template < typename T , typename M = bypass_lock > class channel ; // There are some helper types which implements the operations template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro Channel guarantees coverage of all reader/writer coroutines in its list. When a writer found its reader , or vice versa, it resumes the other's routine and then proceeds its flow. When reader can't be matched with a writer , it attaches itself in channel just before suspend . In the same way, writer attaches itself if it couldn't find reader . Template Parameters T : An element type to deliver between reader/writer coroutines M : Must be a BasicLockable type Default Operations As mentioned above, the type can't be copied/moved. template < typename T , typename M > class channel final { public : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; channel () noexcept ( false ); ~ channel () noexcept ( false ); // !!!! }; Notice that its destructor throws exception . In the destructor, the channel resumes its pending coroutines. The destructor throws if (and only if) one of the resumed coroutines throws an exception. Member Variables Since stackless coroutines are heap-allocated, it uses linked list to those coroutines without additional allocation. Member Description reader_list linked list of reader coroutines. writer_list linked list of writer coroutines. mtx mutex to provide delivery without race between reader/writer coroutines. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); using mutex_type = M ; private : mutex_type mtx {}; public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } }; Functions Function Description write create a writer object for the given channel read create a reader object for the given channel template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { public : // `writer` type implements the awaitable concept decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // `reader` type implements the awaitable concept decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Overview"},{"location":"channel-overview/#overview-coroutine-based-channel","text":"This is a simplified form of channel in The Go Language . Just like this library, several C++ coroutine libraries already has their own implementation of the concept. So it might be redundant to have another implementation in this repositoty, but this is one of the very first type I've wrote after the feature becomes available. Debugging its examples will help you to enhance understanding of the coroutine and which trick can be possible.","title":"Overview: Coroutine based channel"},{"location":"channel-overview/#see-also","text":"Go Channel types A Tour of Go: Channels CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" If you're first with the concept, I strongly recommend you to see the talk above even though I've implemented it in a different way.","title":"See Also"},{"location":"channel-overview/#example","text":"test/channel_read_write_nolock.cpp test/channel_write_read_nolock.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp test/channel_race_no_leak.cpp","title":"Example"},{"location":"channel-overview/#channel-with-a-lockable","text":"When channel<T> is used, which means that bypass_lock is used, channel doesn't care about the race condition (NOT MT-safe). Therefore, user have to provide an appropriate Lockable type and instance if it must be MT-safe As a result, the type doesn't support copy/move since typically those operations are unavailable for Lockable objects. namespace coro { // // The channel is a stream of values. // `channel<T>` isn't MT-safe (using `bypass_lock`). // template < typename T , typename M = bypass_lock > class channel ; // There are some helper types which implements the operations template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro Channel guarantees coverage of all reader/writer coroutines in its list. When a writer found its reader , or vice versa, it resumes the other's routine and then proceeds its flow. When reader can't be matched with a writer , it attaches itself in channel just before suspend . In the same way, writer attaches itself if it couldn't find reader .","title":"Channel with a Lockable"},{"location":"channel-overview/#template-parameters","text":"T : An element type to deliver between reader/writer coroutines M : Must be a BasicLockable type","title":"Template Parameters"},{"location":"channel-overview/#default-operations","text":"As mentioned above, the type can't be copied/moved. template < typename T , typename M > class channel final { public : channel ( const channel & ) noexcept ( false ) = delete ; channel ( channel && ) noexcept ( false ) = delete ; channel & operator = ( const channel & ) noexcept ( false ) = delete ; channel & operator = ( channel && ) noexcept ( false ) = delete ; channel () noexcept ( false ); ~ channel () noexcept ( false ); // !!!! }; Notice that its destructor throws exception . In the destructor, the channel resumes its pending coroutines. The destructor throws if (and only if) one of the resumed coroutines throws an exception.","title":"Default Operations"},{"location":"channel-overview/#member-variables","text":"Since stackless coroutines are heap-allocated, it uses linked list to those coroutines without additional allocation. Member Description reader_list linked list of reader coroutines. writer_list linked list of writer coroutines. mtx mutex to provide delivery without race between reader/writer coroutines. template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { static_assert ( is_reference < T >:: value == false , \"reference type can't be channel's value_type.\" ); using mutex_type = M ; private : mutex_type mtx {}; public : decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Member Variables"},{"location":"channel-overview/#functions","text":"Function Description write create a writer object for the given channel read create a reader object for the given channel template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; template < typename T , typename M > class channel final : internal :: list < reader < T , M >> , internal :: list < writer < T , M >> { public : // `writer` type implements the awaitable concept decltype ( auto ) write ( reference ref ) noexcept ( false ) { return writer { * this , addressof ( ref )}; } // `reader` type implements the awaitable concept decltype ( auto ) read () noexcept ( false ) { return reader { * this }; } };","title":"Functions"},{"location":"channel-read_write/","text":"Current version uses helper types to use channel in a designed manner. The types implements awaitable interface that is required by co_await operator. namespace coro { template < typename T , typename M > class reader ; template < typename T , typename M > class writer ; } // namespace coro See Also Channel Concept Go Channel types CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\" Example test/channel_read_write_mutex.cpp test/channel_write_read_mutex.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp Awaitable Channel Read Short Example using namespace coro ; template < typename T , typename M > auto read_from ( channel < T , M >& ch ) -> no_return { auto [ value , ok ] = co_await ch . read (); // you can use `std::tie` if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. } Reader The type supports move operation, but it is unecessary in general. template < typename T , typename M > class reader final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ); auto await_resume () noexcept ( false ) -> std :: tuple < value_type , bool > ; }; Function Description await_ready Returns true if there is a waiting writer instance in the channel await_suspend Start waiting in the channel's reader list await_resume Resumes both writer and ifself when the read was successful. Returned tuple containes false if the channel is going to be destroyed(closed). Awaitable Channel Write Short Example using namespace coro ; template < typename T , typename M > auto write_to ( channel < T , M >& ch , T && value ) -> no_return { auto ok = co_await ch . write ( value ); // call by reference (T&) if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. } Writer The type supports move operation, but it is unecessary in general. template < typename T , typename M > class writer final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > _rh ) noexcept ( false ); bool await_resume () noexcept ( false ); }; Function Description await_ready Returns true if there is a waiting reader instance in the channel await_suspend Start waiting in the channel's writer list await_resume Resumes both reader and ifself the write was successful. Return false if the channel is going to be destroyed(closed).","title":"Read/Write"},{"location":"channel-read_write/#see-also","text":"Channel Concept Go Channel types CppCon 2016: John Bandela \"Channels - An alternative to callbacks and futures\"","title":"See Also"},{"location":"channel-read_write/#example","text":"test/channel_read_write_mutex.cpp test/channel_write_read_mutex.cpp test/channel_write_fail_after_close.cpp test/channel_read_fail_after_close.cpp","title":"Example"},{"location":"channel-read_write/#awaitable-channel-read","text":"","title":"Awaitable Channel Read"},{"location":"channel-read_write/#short-example","text":"using namespace coro ; template < typename T , typename M > auto read_from ( channel < T , M >& ch ) -> no_return { auto [ value , ok ] = co_await ch . read (); // you can use `std::tie` if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. }","title":"Short Example"},{"location":"channel-read_write/#reader","text":"The type supports move operation, but it is unecessary in general. template < typename T , typename M > class reader final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { reader * next = nullptr ; // Next reader in channel channel_type * chan ; // Channel to push this reader }; private : explicit reader ( channel_type & ch ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ); auto await_resume () noexcept ( false ) -> std :: tuple < value_type , bool > ; }; Function Description await_ready Returns true if there is a waiting writer instance in the channel await_suspend Start waiting in the channel's reader list await_resume Resumes both writer and ifself when the read was successful. Returned tuple containes false if the channel is going to be destroyed(closed).","title":"Reader"},{"location":"channel-read_write/#awaitable-channel-write","text":"","title":"Awaitable Channel Write"},{"location":"channel-read_write/#short-example_1","text":"using namespace coro ; template < typename T , typename M > auto write_to ( channel < T , M >& ch , T && value ) -> no_return { auto ok = co_await ch . write ( value ); // call by reference (T&) if ( ok == false ){ // ok is `false` if channel is closed. // access to the channel will lead to undefined behavior } // ok is `true` if the operation was successful. // the value is moved from writer coroutine to reader coroutine. }","title":"Short Example"},{"location":"channel-read_write/#writer","text":"The type supports move operation, but it is unecessary in general. template < typename T , typename M > class writer final { public : using pointer = T * ; using channel_type = channel < T , M > ; private : mutable pointer ptr ; // Address of value mutable void * frame ; // Resumeable Handle union { writer * next = nullptr ; // Next writer in channel channel_type * chan ; // Channel to push this writer }; private : explicit writer ( channel_type & ch , pointer pv ) noexcept ( false ); public : bool await_ready () const noexcept ( false ); void await_suspend ( coroutine_handle < void > _rh ) noexcept ( false ); bool await_resume () noexcept ( false ); }; Function Description await_ready Returns true if there is a waiting reader instance in the channel await_suspend Start waiting in the channel's writer list await_resume Resumes both reader and ifself the write was successful. Return false if the channel is going to be destroyed(closed).","title":"Writer"},{"location":"channel-select/","text":"Current version uses helper types to use channel in a designed manner. namespace coro { template < typename T , typename M > class channel ; template < typename T , typename M > class peeker ; } // namespace coro See Also Channel Concept Channel Read/Write Example test/channel_select_bypass_empty.cpp test/channel_select_type_match.cpp test/channel_select_peek_all_cases.cpp Channel Non-blocking Select Short Example using namespace coro ; using u32_chan_t = channel < uint32_t > ; using i32_chan_t = channel < int32_t > ; TEST_METHOD ( channel_select_match_one ) { u32_chan_t ch1 {}; i32_chan_t ch2 {}; write_to ( ch1 , 17u ); select ( ch2 , // empty channel. bypass []( auto v ) { static_assert ( is_same_v < decltype ( v ), int32_t > ); Assert :: Fail ( L \"select on empty channel must bypass\" ); }, ch1 , // if the channel has a writer, peek and invoke callback []( auto v ) -> no_return { static_assert ( is_same_v < decltype ( v ), uint32_t > ); Assert :: IsTrue ( v == 17u ); co_await suspend_never {}; }); } Selecting a pair from arguments To support expression like above, select received a number of pairs of channel and functions. The functions can be a coroutine. However, their return object will be truncated. namespace coro { // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { // evaluate select ( ch , forward < FuncType &&> ( fn )); // try next pair return select ( forward < Args &&> ( args )...); } } // namespace coro For each pair, select test the channel and consume writer coroutines. namespace coro { // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } } // namespace coro Channel Peek Operation peeker<T, M> is quite simple. Function Description peek test the channel if there is a waiting writer coroutine. if so, fetch it. acquire return false if there was no writer. Move the value from writer coroutine to local storage. writer coroutine will be resumed. namespace coro { // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; } // namespace coro","title":"Select on multiple channel"},{"location":"channel-select/#see-also","text":"Channel Concept Channel Read/Write","title":"See Also"},{"location":"channel-select/#example","text":"test/channel_select_bypass_empty.cpp test/channel_select_type_match.cpp test/channel_select_peek_all_cases.cpp","title":"Example"},{"location":"channel-select/#channel-non-blocking-select","text":"","title":"Channel Non-blocking Select"},{"location":"channel-select/#short-example","text":"using namespace coro ; using u32_chan_t = channel < uint32_t > ; using i32_chan_t = channel < int32_t > ; TEST_METHOD ( channel_select_match_one ) { u32_chan_t ch1 {}; i32_chan_t ch2 {}; write_to ( ch1 , 17u ); select ( ch2 , // empty channel. bypass []( auto v ) { static_assert ( is_same_v < decltype ( v ), int32_t > ); Assert :: Fail ( L \"select on empty channel must bypass\" ); }, ch1 , // if the channel has a writer, peek and invoke callback []( auto v ) -> no_return { static_assert ( is_same_v < decltype ( v ), uint32_t > ); Assert :: IsTrue ( v == 17u ); co_await suspend_never {}; }); }","title":"Short Example"},{"location":"channel-select/#selecting-a-pair-from-arguments","text":"To support expression like above, select received a number of pairs of channel and functions. The functions can be a coroutine. However, their return object will be truncated. namespace coro { // Invoke `select` for each pairs (channel + function) template < typename ... Args , typename ChanType , typename FuncType > void select ( ChanType & ch , FuncType && fn , Args && ... args ) noexcept ( false ) { // evaluate select ( ch , forward < FuncType &&> ( fn )); // try next pair return select ( forward < Args &&> ( args )...); } } // namespace coro For each pair, select test the channel and consume writer coroutines. namespace coro { // If the channel is readable, acquire the value and the function. template < typename T , typename M , typename Fn > void select ( channel < T , M >& ch , Fn && fn ) noexcept ( false ) { static_assert ( sizeof ( reader < T , M > ) == sizeof ( peeker < T , M > )); peeker < T , M > p { ch }; // peeker will move element T storage {}; // into the call stack p . peek (); // the channel has waiting writer? if ( p . acquire ( storage )) // acquire + resume writer fn ( storage ); // invoke the function } } // namespace coro","title":"Selecting a pair from arguments"},{"location":"channel-select/#channel-peek-operation","text":"peeker<T, M> is quite simple. Function Description peek test the channel if there is a waiting writer coroutine. if so, fetch it. acquire return false if there was no writer. Move the value from writer coroutine to local storage. writer coroutine will be resumed. namespace coro { // Extension of channel reader for subroutines template < typename T , typename M > class peeker final : protected reader < T , M > { using value_type = T ; using channel_type = channel < T , M > ; public : void peek () const noexcept ( false ) { // since there is no suspension, use scoped locking unique_lock lck { this -> chan -> mtx }; if ( this -> chan -> writer_list :: is_empty () == false ) { writer * w = this -> chan -> writer_list :: pop (); swap ( this -> ptr , w -> ptr ); swap ( this -> frame , w -> frame ); } } bool acquire ( value_type & storage ) noexcept ( false ) { // if there was a writer, take its value if ( this -> ptr == nullptr ) return false ; storage = move ( * this -> ptr ); // resume writer coroutine if ( auto coro = coroutine_handle < void >:: from_address ( this -> frame )) coro . resume (); return true ; } }; } // namespace coro","title":"Channel Peek Operation"},{"location":"concrt-event/","text":"","title":"event"},{"location":"concrt-latch/","text":"Synchronization for fork-join scenario. It will be removed when it C++ Concurrency TS becomes available. See Also Go Language: sync.WaitGroup C++ Concurrency TS: Latch Example test/c2_concrt.cpp Latch Visit the cppreference.com for the detailed explaination. Latch in this library has slightly different interface with that of Concurrency TS namespace concrt { // A temporary implementation of `std::experimental::latch` class latch final : no_copy_move { // for win32 atomic_uint64_t ref {}; mutable win32_event ev {}; // for posix atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept = default ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; } // namespace concrt","title":"latch"},{"location":"concrt-latch/#see-also","text":"Go Language: sync.WaitGroup C++ Concurrency TS: Latch","title":"See Also"},{"location":"concrt-latch/#example","text":"test/c2_concrt.cpp","title":"Example"},{"location":"concrt-latch/#latch","text":"Visit the cppreference.com for the detailed explaination. Latch in this library has slightly different interface with that of Concurrency TS namespace concrt { // A temporary implementation of `std::experimental::latch` class latch final : no_copy_move { // for win32 atomic_uint64_t ref {}; mutable win32_event ev {}; // for posix atomic_uint64_t ref {}; pthread_cond_t cv {}; pthread_mutex_t mtx {}; public : _INTERFACE_ explicit latch ( uint32_t count ) noexcept ( false ); _INTERFACE_ ~ latch () noexcept = default ; _INTERFACE_ void count_down_and_wait () noexcept ( false ); _INTERFACE_ void count_down ( uint32_t n = 1 ) noexcept ( false ); _INTERFACE_ bool is_ready () const noexcept ; _INTERFACE_ void wait () noexcept ( false ); }; } // namespace concrt","title":"Latch"},{"location":"concrt-overview/","text":"","title":"Overview"},{"location":"concrt-ptp_work/","text":"See Also CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Using the thread pool functions PTP_WORK Example test/vs_channel.cpp Win32 Thread Pool Work Change current coroutine's processor to background thread in thread pool. Example using namespace concrt ; auto switch_to_background () -> no_return { auto from = GetCurrentThreadId (); co_await ptp_work {}; // resume on thread pool auto to = GetCurrentThreadId (); Assert :: IsTrue ( from != to ); } Like the example. It is recommended to use it as a temporary object. Definition namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { static void __stdcall resume_on_thread_pool ( // PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; }; } // namepace concrt Default Operations The type doesn't require memory. And it is a regular type. Functions Function Description suspend send the given coroutine_handle<void> to background await_suspend coroutine code is generated in importing code. throws error if an error is occurred. namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = suspend ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; } // namepace concrt","title":"ptp_work"},{"location":"concrt-ptp_work/#see-also","text":"CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Using the thread pool functions PTP_WORK","title":"See Also"},{"location":"concrt-ptp_work/#example","text":"test/vs_channel.cpp","title":"Example"},{"location":"concrt-ptp_work/#win32-thread-pool-work","text":"Change current coroutine's processor to background thread in thread pool.","title":"Win32 Thread Pool Work"},{"location":"concrt-ptp_work/#example_1","text":"using namespace concrt ; auto switch_to_background () -> no_return { auto from = GetCurrentThreadId (); co_await ptp_work {}; // resume on thread pool auto to = GetCurrentThreadId (); Assert :: IsTrue ( from != to ); } Like the example. It is recommended to use it as a temporary object.","title":"Example"},{"location":"concrt-ptp_work/#definition","text":"namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { static void __stdcall resume_on_thread_pool ( // PTP_CALLBACK_INSTANCE , PVOID , PTP_WORK ); public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; }; } // namepace concrt","title":"Definition"},{"location":"concrt-ptp_work/#default-operations","text":"The type doesn't require memory. And it is a regular type.","title":"Default Operations"},{"location":"concrt-ptp_work/#functions","text":"Function Description suspend send the given coroutine_handle<void> to background await_suspend coroutine code is generated in importing code. throws error if an error is occurred. namespace concrt { // Move into the win32 thread pool and continue the routine class ptp_work final : public suspend_always { public : _INTERFACE_ auto suspend ( coroutine_handle < void > coro ) noexcept -> uint32_t ; // Lazy code generation in importing code by header usage. void await_suspend ( coroutine_handle < void > coro ) noexcept ( false ) { if ( const auto ec = suspend ( coro )) throw system_error { static_cast < int > ( ec ), system_category (), \"CreateThreadpoolWork\" }; } }; } // namepace concrt","title":"Functions"},{"location":"concrt-section/","text":"This document is under progress... A basic lockable type with System API See Also https://en.cppreference.com/w/cpp/named_req/BasicLockable Critical Section Definition With Win32 API. It uses CRITICAL_SECTION instead of SRWLock . namespace concrt { // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION , no_copy_move { public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt With POSIX API, it uses pthread_rwlock_t . namespace concrt { // Standard lockable with pthread reader writer lock class section final : no_copy_move { pthread_rwlock_t rwlock ; public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt","title":"section"},{"location":"concrt-section/#see-also","text":"https://en.cppreference.com/w/cpp/named_req/BasicLockable","title":"See Also"},{"location":"concrt-section/#critical-section","text":"","title":"Critical Section"},{"location":"concrt-section/#definition","text":"With Win32 API. It uses CRITICAL_SECTION instead of SRWLock . namespace concrt { // Standard lockable with win32 criticial section class section final : CRITICAL_SECTION , no_copy_move { public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt With POSIX API, it uses pthread_rwlock_t . namespace concrt { // Standard lockable with pthread reader writer lock class section final : no_copy_move { pthread_rwlock_t rwlock ; public : _INTERFACE_ section () noexcept ( false ); _INTERFACE_ ~ section () noexcept ; _INTERFACE_ bool try_lock () noexcept ; _INTERFACE_ void lock () noexcept ( false ); _INTERFACE_ void unlock () noexcept ( false ); }; } // namepace concrt","title":"Definition"},{"location":"frame-compiler_specific/","text":"This document is under progress... This document covers compiler specific issues. See Also <coroutine/frame.h> Exploring the C++ coroutine Github Issues in this repo Compiler Awareness The file declares some variables for if constexpr support. static constexpr auto is_msvc = // true or false ... static constexpr auto is_clang = // true or false ... static constexpr auto is_gcc = // true or false ... Compiler Intrinsic For MSVC, the library rely on 2 intrinsic functions and 1 adapter function. extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // adapter for _coro_done bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; For Clang, the library rely on 3 intrinsic functions. extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * ); Coroutine Frame Prefix The file also defines frame prefix types to help debugging of coroutine frame. template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16 - 1 ) & ~ ( 16 - 1 )); using procedure_t = void ( __cdecl * )( void * ); The following type is for MSVC. struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); The following type is for Clang and Clang-cl. struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 );","title":"Compiler Specific Issues"},{"location":"frame-compiler_specific/#see-also","text":"<coroutine/frame.h> Exploring the C++ coroutine Github Issues in this repo","title":"See Also"},{"location":"frame-compiler_specific/#compiler-awareness","text":"The file declares some variables for if constexpr support. static constexpr auto is_msvc = // true or false ... static constexpr auto is_clang = // true or false ... static constexpr auto is_gcc = // true or false ...","title":"Compiler Awareness"},{"location":"frame-compiler_specific/#compiler-intrinsic","text":"For MSVC, the library rely on 2 intrinsic functions and 1 adapter function. extern \"C\" size_t _coro_resume ( void * ); extern \"C\" void _coro_destroy ( void * ); extern \"C\" size_t _coro_done ( void * ); // <- leads compiler error // adapter for _coro_done bool _coro_finished ( const msvc_frame_prefix * ) noexcept ; For Clang, the library rely on 3 intrinsic functions. extern \"C\" bool __builtin_coro_done ( void * ); extern \"C\" void __builtin_coro_resume ( void * ); extern \"C\" void __builtin_coro_destroy ( void * );","title":"Compiler Intrinsic"},{"location":"frame-compiler_specific/#coroutine-frame-prefix","text":"The file also defines frame prefix types to help debugging of coroutine frame. template < typename T > constexpr auto aligned_size_v = (( sizeof ( T ) + 16 - 1 ) & ~ ( 16 - 1 )); using procedure_t = void ( __cdecl * )( void * ); The following type is for MSVC. struct msvc_frame_prefix final { procedure_t factivate ; uint16_t index ; uint16_t flag ; }; static_assert ( aligned_size_v < msvc_frame_prefix > == 16 ); The following type is for Clang and Clang-cl. struct clang_frame_prefix final { procedure_t factivate ; procedure_t fdestroy ; }; static_assert ( aligned_size_v < clang_frame_prefix > == 16 );","title":"Coroutine Frame Prefix"},{"location":"frame-coroutine_handle/","text":"This document is under progress... See Also n4736 <experimental/coroutine> in VC++ <experimental/coroutine> in libc++ 7 or later Coroutine Handle Defines the templace class coroutine_handle<T> in std::experimental namespace. namespace std :: experimental { template < typename PromiseType = void > class coroutine_handle ; } Remarks Working with existing definitions The header file <coroutine/frame.h> is an adapter to support coroutine frame's difference between compilers. (For now, MSVC and Clang). The file imports <experimental/coroutine> . // <coroutine> header build issue handling #if defined(__clang__) && defined(_MSC_VER) // case: clang-cl, VC++ // Use this library's implementation ... #else // case: msvc, VC++ // case: clang, libc++ # if __has_include(<coroutine>) # include <coroutine> // C++ 20 standard # elif __has_include(<experimental/coroutine>) # include <experimental/coroutine> // C++ 17 experimetal # endif #endif // ... Template Parameters PromiseType must fulfills the Coroutine Promise Requirement. Default Operations The class coroutine_handle<P> is regular type . namespace std :: experimental { template <> class coroutine_handle < void > { public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept ; explicit coroutine_handle ( std :: nullptr_t ) noexcept ; // ... }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); // ... } With Void Mostly the type will be used with void as its promise type. In the case, its member functions are like the following table. Function Description operator bool Tells the coroutine handle is not empty resume Resume the coroutine's control flow. The coroutine must be in suspended state. destroy Destruct the variables in the coroutine frame and the frame done Returns true if the coroutine is returned address Acquire the address of the frame from_address Create a coroutine handle that uses the given address as a frame namespace std :: experimental { template <> class coroutine_handle < void > { public : operator bool () const noexcept ; void resume () noexcept ( false ); void destroy () noexcept ; bool done () const noexcept ; constexpr void * address () const noexcept ; static coroutine_handle from_address ( void * addr ) noexcept ; // ... }; } With Promise When the promise type is not void , the template class defines additional functions to work with the PromiseType . Function Description from_address Considering the promise type's size, create a coroutine handle from the given address from_promise Create a handle from the reference to promise namespace std :: experimental { template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; // ... static coroutine_handle from_address ( void * addr ) noexcept ; static coroutine_handle from_promise ( promise_type & prom ) noexcept ; // ... }; } Non-Member Functions Compare Operators namespace std :: experimental { bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; }","title":"coroutine_handle"},{"location":"frame-coroutine_handle/#see-also","text":"n4736 <experimental/coroutine> in VC++ <experimental/coroutine> in libc++ 7 or later","title":"See Also"},{"location":"frame-coroutine_handle/#coroutine-handle","text":"Defines the templace class coroutine_handle<T> in std::experimental namespace. namespace std :: experimental { template < typename PromiseType = void > class coroutine_handle ; }","title":"Coroutine Handle"},{"location":"frame-coroutine_handle/#remarks","text":"","title":"Remarks"},{"location":"frame-coroutine_handle/#working-with-existing-definitions","text":"The header file <coroutine/frame.h> is an adapter to support coroutine frame's difference between compilers. (For now, MSVC and Clang). The file imports <experimental/coroutine> . // <coroutine> header build issue handling #if defined(__clang__) && defined(_MSC_VER) // case: clang-cl, VC++ // Use this library's implementation ... #else // case: msvc, VC++ // case: clang, libc++ # if __has_include(<coroutine>) # include <coroutine> // C++ 20 standard # elif __has_include(<experimental/coroutine>) # include <experimental/coroutine> // C++ 17 experimetal # endif #endif // ...","title":"Working with existing definitions"},{"location":"frame-coroutine_handle/#template-parameters","text":"PromiseType must fulfills the Coroutine Promise Requirement.","title":"Template Parameters"},{"location":"frame-coroutine_handle/#default-operations","text":"The class coroutine_handle<P> is regular type . namespace std :: experimental { template <> class coroutine_handle < void > { public : coroutine_handle () noexcept = default ; ~ coroutine_handle () noexcept = default ; coroutine_handle ( coroutine_handle const & ) noexcept = default ; coroutine_handle & operator = ( coroutine_handle const & ) noexcept = default ; coroutine_handle ( coroutine_handle && rhs ) noexcept ; coroutine_handle & operator = ( coroutine_handle && rhs ) noexcept ; explicit coroutine_handle ( std :: nullptr_t ) noexcept ; // ... }; static_assert ( sizeof ( coroutine_handle < void > ) == sizeof ( void * )); // ... }","title":"Default Operations"},{"location":"frame-coroutine_handle/#with-void","text":"Mostly the type will be used with void as its promise type. In the case, its member functions are like the following table. Function Description operator bool Tells the coroutine handle is not empty resume Resume the coroutine's control flow. The coroutine must be in suspended state. destroy Destruct the variables in the coroutine frame and the frame done Returns true if the coroutine is returned address Acquire the address of the frame from_address Create a coroutine handle that uses the given address as a frame namespace std :: experimental { template <> class coroutine_handle < void > { public : operator bool () const noexcept ; void resume () noexcept ( false ); void destroy () noexcept ; bool done () const noexcept ; constexpr void * address () const noexcept ; static coroutine_handle from_address ( void * addr ) noexcept ; // ... }; }","title":"With Void"},{"location":"frame-coroutine_handle/#with-promise","text":"When the promise type is not void , the template class defines additional functions to work with the PromiseType . Function Description from_address Considering the promise type's size, create a coroutine handle from the given address from_promise Create a handle from the reference to promise namespace std :: experimental { template < typename PromiseType > class coroutine_handle : public coroutine_handle < void > { public : using promise_type = PromiseType ; // ... static coroutine_handle from_address ( void * addr ) noexcept ; static coroutine_handle from_promise ( promise_type & prom ) noexcept ; // ... }; }","title":"With Promise"},{"location":"frame-coroutine_handle/#non-member-functions","text":"","title":"Non-Member Functions"},{"location":"frame-coroutine_handle/#compare-operators","text":"namespace std :: experimental { bool operator == ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator != ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator <= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator >= ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator < ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; bool operator > ( const coroutine_handle < void > lhs , const coroutine_handle < void > rhs ) noexcept ; }","title":"Compare Operators"},{"location":"frame-coroutine_traits/","text":"This document is under progress... This document explains usage of coroutine_traits<R, P...> . See Also n4736 Coroutine Traits Unlike libc++ or VC++, current version doesn't allow SFINAE. namespace std :: experimental { // traits to enforce member `promise_type` template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; }","title":"coroutine_traits"},{"location":"frame-coroutine_traits/#see-also","text":"n4736","title":"See Also"},{"location":"frame-coroutine_traits/#coroutine-traits","text":"Unlike libc++ or VC++, current version doesn't allow SFINAE. namespace std :: experimental { // traits to enforce member `promise_type` template < typename ReturnType , typename ... Args > struct coroutine_traits { using promise_type = typename ReturnType :: promise_type ; }; }","title":"Coroutine Traits"},{"location":"frame-overview/","text":"","title":"Overview"},{"location":"frame-suspend_types/","text":"This document is under progress... <coroutine/frame.h> containes definition of suspend helper types that can be used for initial_suspend and final_suspend . See Also n4736 Suspend Types namespace std :: experimental { class suspend_never { public : constexpr bool await_ready () const noexcept ; void await_suspend ( coroutine_handle < void > ) const noexcept ; constexpr void await_resume () const noexcept ; }; class suspend_always { public : constexpr bool await_ready () const noexcept ; void await_suspend ( coroutine_handle < void > ) const noexcept ; constexpr void await_resume () const noexcept ; }; }","title":"Suspend Types"},{"location":"frame-suspend_types/#see-also","text":"n4736","title":"See Also"},{"location":"frame-suspend_types/#suspend-types","text":"namespace std :: experimental { class suspend_never { public : constexpr bool await_ready () const noexcept ; void await_suspend ( coroutine_handle < void > ) const noexcept ; constexpr void await_resume () const noexcept ; }; class suspend_always { public : constexpr bool await_ready () const noexcept ; void await_suspend ( coroutine_handle < void > ) const noexcept ; constexpr void await_resume () const noexcept ; }; }","title":"Suspend Types"},{"location":"howto-start-yours/","text":"I think you should be able to start your project if you have followed all of 'How To' documents. If not, please give me your opinion through GitHub issues . I'm longing to hear from you. :)","title":"Start Your Project!"},{"location":"import-using-cmake/","text":"How To Import: CMake Project Does this library support any package manager? Actually, you don't have to use package manager for this libary. git submodule + add_subdirectory will be work well! Try with the Vcpkg This repository is registered as package coroutine in microsoft/vcpkg . Try the awesome tool! $ vcpkg install coroutine The following packages will be built and installed: coroutine[core]:x64-osx Starting package 1/1: coroutine:x64-osx Building package coroutine[core]:x64-osx... -- ... The package coroutine:x64-osx provides CMake targets: find_package(coroutine CONFIG REQUIRED) target_link_libraries(main PRIVATE coroutine) Follow the steps! Check your environment If you didn't checked your project's configuration, please do review this document first . If possible, use the latest CMake Any reason for this? Any guide for the installation? Currently the library expects CMake 3.8 or later, which supports C++ 17 for CXX_STANDARD cmake_minimum_required ( VERSION 3.8 ) Installing GSL(Guideline Support Library) The GSL is a header-only and light-weighted library. You can just use git clone it and import easily. cmake /path/to/project -DGSL_INCLUDE_DIR = /path/to/gsl/include Call add_subdirectory Suppose your project's file tree is like the following. Notice that the project submodules GSL already . So mostly you don't have to manage GSL_INCLUDE_DIR manually. Let the command git submodule will do the work for you. $ git submodule update --init --recursive ... However this document will assume you wanted to use custom path. $ tree -L 2 /path/to/project /path/to/project \u251c\u2500\u2500 CMakeLists.txt \u251c... \u251c\u2500\u2500 gsl # <-- already placed GSL at your path \u2502 \u251c... \u2502 \u2514... \u251c\u2500\u2500 coroutine # <-- you submoduled this library \u2502 \u251c... \u2502 \u2514... \u251c... \u2514... In your CMakeLists.txt, call add_subdirectory . # if you submoduled the coroutine's master branch, # you don't have to set this cmake variable. set ( GSL_INCLUDE_DIR ${ CMAKE_CURRENT_SOURCE_DIR } /gsl/include ) add_subdirectory ( coroutine ) Test will be skipped automatically The library won't build test codes unless it is not a root project . Since you're using add_subdirectory , they will be skipped for your build time! # See the `coroutine/CMakeLists.txt` if ( TEST_DISABLED ) message ( STATUS \"Test is disabled.\" ) return () elseif ( IOS OR ANDROID ) message ( STATUS \"Mobile cross build doesn't support tests\" ) return () elseif ( NOT ${ CMAKE_SOURCE_DIR } STREQUAL ${ CMAKE_CURRENT_SOURCE_DIR } ) message ( STATUS \"This is not a root project. Skip tests\" ) return () endif () Call target_link_libraries The library's CMake configures some PUBLIC settings. So just using target_link_libraries for it will do all the necessary work for you. Such as compiler option, dependent system libraries, etc. target_link_libraries ( your_project_name PUBLIC coroutine ) Questions & Trouble Shooting Trouble 1 ...","title":"CMake"},{"location":"import-using-cmake/#how-to-import-cmake-project","text":"","title":"How To Import: CMake Project"},{"location":"import-using-cmake/#does-this-library-support-any-package-manager","text":"Actually, you don't have to use package manager for this libary. git submodule + add_subdirectory will be work well!","title":"Does this library support any package manager?"},{"location":"import-using-cmake/#try-with-the-vcpkg","text":"This repository is registered as package coroutine in microsoft/vcpkg . Try the awesome tool! $ vcpkg install coroutine The following packages will be built and installed: coroutine[core]:x64-osx Starting package 1/1: coroutine:x64-osx Building package coroutine[core]:x64-osx... -- ... The package coroutine:x64-osx provides CMake targets: find_package(coroutine CONFIG REQUIRED) target_link_libraries(main PRIVATE coroutine)","title":"Try with the Vcpkg"},{"location":"import-using-cmake/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"import-using-cmake/#check-your-environment","text":"If you didn't checked your project's configuration, please do review this document first .","title":"Check your environment"},{"location":"import-using-cmake/#if-possible-use-the-latest-cmake","text":"Any reason for this? Any guide for the installation? Currently the library expects CMake 3.8 or later, which supports C++ 17 for CXX_STANDARD cmake_minimum_required ( VERSION 3.8 )","title":"If possible, use the latest CMake"},{"location":"import-using-cmake/#installing-gslguideline-support-library","text":"The GSL is a header-only and light-weighted library. You can just use git clone it and import easily. cmake /path/to/project -DGSL_INCLUDE_DIR = /path/to/gsl/include","title":"Installing GSL(Guideline Support Library)"},{"location":"import-using-cmake/#call-add_subdirectory","text":"Suppose your project's file tree is like the following. Notice that the project submodules GSL already . So mostly you don't have to manage GSL_INCLUDE_DIR manually. Let the command git submodule will do the work for you. $ git submodule update --init --recursive ... However this document will assume you wanted to use custom path. $ tree -L 2 /path/to/project /path/to/project \u251c\u2500\u2500 CMakeLists.txt \u251c... \u251c\u2500\u2500 gsl # <-- already placed GSL at your path \u2502 \u251c... \u2502 \u2514... \u251c\u2500\u2500 coroutine # <-- you submoduled this library \u2502 \u251c... \u2502 \u2514... \u251c... \u2514... In your CMakeLists.txt, call add_subdirectory . # if you submoduled the coroutine's master branch, # you don't have to set this cmake variable. set ( GSL_INCLUDE_DIR ${ CMAKE_CURRENT_SOURCE_DIR } /gsl/include ) add_subdirectory ( coroutine )","title":"Call add_subdirectory"},{"location":"import-using-cmake/#test-will-be-skipped-automatically","text":"The library won't build test codes unless it is not a root project . Since you're using add_subdirectory , they will be skipped for your build time! # See the `coroutine/CMakeLists.txt` if ( TEST_DISABLED ) message ( STATUS \"Test is disabled.\" ) return () elseif ( IOS OR ANDROID ) message ( STATUS \"Mobile cross build doesn't support tests\" ) return () elseif ( NOT ${ CMAKE_SOURCE_DIR } STREQUAL ${ CMAKE_CURRENT_SOURCE_DIR } ) message ( STATUS \"This is not a root project. Skip tests\" ) return () endif ()","title":"Test will be skipped automatically"},{"location":"import-using-cmake/#call-target_link_libraries","text":"The library's CMake configures some PUBLIC settings. So just using target_link_libraries for it will do all the necessary work for you. Such as compiler option, dependent system libraries, etc. target_link_libraries ( your_project_name PUBLIC coroutine )","title":"Call target_link_libraries"},{"location":"import-using-cmake/#questions-trouble-shooting","text":"","title":"Questions &amp; Trouble Shooting"},{"location":"import-using-cmake/#trouble-1","text":"...","title":"Trouble 1"},{"location":"import-using-visualstudio/","text":"How To Import: Visual Studio Before Import ... Check the Windows SDK and Visual Studio The coroutine.sln file might be accessing with the wrong version. Or the different version of the Visual Studio can bother you. Try the build first . If the step fails, please create a new issue ! I tested with the following configurations Visual Studio 2017 (v141, 15.12+) 10.0.14393: AppVeyor 10.0.17134 ... Visual Studio 2019 (v142, ...) 10.0.17134 ... Follow the steps! Create a new C++ Solution/Project Of course, the first step is to create importing Project. Open your Visual Studio and create a new VC++ Solution (or project, whatever). Then clone the repository. master branch will be ok. Also, you have to fetch submodules. PS D:\\ConsoleApp\\ConsoleApplication1> git clone https://github.com/luncliff/coroutine PS D:\\ConsoleApp\\ConsoleApplication1> cd .\\coroutine\\ PS D:\\ConsoleApp\\ConsoleApplication1\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/guideline'... Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' After the clone, the folder should be like the following. Let's open the VS and keep going. :) Import VC++ Project We're going to add this library's windows project to the solution. Oh, never forget the x64 platform config! This library doesn't target x86 . The arch is supported by MSVC, but it's not in the maintenance plan for now. Add Existing Project If you cloned the library like the above, you can find it after browsing the workspace. After import, open the Properties page and check the configruation. Change the 'Windows SDK Version' to installed one that you are going to use. It matters. Add Reference Now, change the reference of the ConsoleApplication1 project. Adjustment for the modules/windows.vcxproj Include Directories With basic include directories of the VC++ project, there are 3 additional paths. $(ProjectDir)..\\interface : include folder for library interfaces $(ProjectDir)..\\external\\guideline\\include : C++ Core Guideline Support Library. <gsl/gsl> $(ProjectDir) : internal codes So we have to inherit 2 paths in our new project( ConsoleApplication1 ). After changing the 'Additional Include Directories', update the code like the follwing. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types int main ( int , char * []) { std :: cout << \"Hello Coroutine! \\n \" ; return 0 ; } Now, try the build. (I will do that with x64|Debug ). The build must fail because we didn't changed compiler option. MSVC Compier Options To build the C++ 20 Coroutine code, we have to set the option /await . Also, the language standard C++ 17 is required( /std:c++17 or /std:c++latest ). In case of the coroutine's project, the option is just like this. <Project DefaultTargets= \"Build\" ToolsVersion= \"15.0\" xmlns= \"http://schemas.microsoft.com/developer/msbuild/2003\" > <!-- ... --> <ItemDefinitionGroup Condition= \"'$(Configuration)|$(Platform)'=='Debug|x64'\" > <!-- ... --> <AdditionalOptions> /await %(AdditionalOptions) </AdditionalOptions> <LanguageStandard> stdcpplatest </LanguageStandard> <!-- ... --> Therefore the property of our ConsoleApplication1 need to be changed like the image. Linker Options Well, you don't have to care! :) Just try the new build. If something goes wrong, create a new issue with your screenshot and reproduction steps so I can help you. Try this example So this is our new code. The function doesn't suspend and returns nothing. It works just like normal void(void) subroutine, but it's enough to confirm our compiler supports the feature. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types using std :: experimental :: suspend_never ; using coro :: no_return ; // Destroy coroutine frame after co_return. // It's fire and forget manner auto no_suspend_no_return () -> no_return { co_await suspend_never {}; std :: cout << \"Hello Coroutine! \\n \" ; co_return ; } int main ( int , char * []) { no_suspend_no_return (); return 0 ; } Glad for a new C++ Coroutine user! The screen shot is here. Questions & Trouble Shooting This section is reserved to answer the question, \"If the add reference doesn't work, what should user try?\" Build with the Clang-cl ? Wow, really? You must install the LLVM packages first. Follow this document . I'm considering VS 2019's CMake integration for Clang-cl build tutorial. I will add a new document ASAP.","title":"Visual Studio"},{"location":"import-using-visualstudio/#how-to-import-visual-studio","text":"","title":"How To Import: Visual Studio"},{"location":"import-using-visualstudio/#before-import","text":"","title":"Before Import ..."},{"location":"import-using-visualstudio/#check-the-windows-sdk-and-visual-studio","text":"The coroutine.sln file might be accessing with the wrong version. Or the different version of the Visual Studio can bother you. Try the build first . If the step fails, please create a new issue ! I tested with the following configurations Visual Studio 2017 (v141, 15.12+) 10.0.14393: AppVeyor 10.0.17134 ... Visual Studio 2019 (v142, ...) 10.0.17134 ...","title":"Check the Windows SDK and Visual Studio"},{"location":"import-using-visualstudio/#follow-the-steps","text":"","title":"Follow the steps!"},{"location":"import-using-visualstudio/#create-a-new-c-solutionproject","text":"Of course, the first step is to create importing Project. Open your Visual Studio and create a new VC++ Solution (or project, whatever). Then clone the repository. master branch will be ok. Also, you have to fetch submodules. PS D:\\ConsoleApp\\ConsoleApplication1> git clone https://github.com/luncliff/coroutine PS D:\\ConsoleApp\\ConsoleApplication1> cd .\\coroutine\\ PS D:\\ConsoleApp\\ConsoleApplication1\\coroutine> git submodule update --init --recursive Submodule 'external/guideline' (https://github.com/Microsoft/GSL) registered for path 'external/guideline' Submodule 'external/ios-cmake' (https://github.com/leetal/ios-cmake) registered for path 'external/ios-cmake' Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/guideline'... Cloning into 'D:/ConsoleApp/ConsoleApplication1/coroutine/external/ios-cmake'... Submodule path 'external/guideline': checked out 'b74b286d5e333561b0f1ef1abd18de2606624455' Submodule path 'external/ios-cmake': checked out 'a177e3cafe05f0571218f3eeb39067aae7e5255a' After the clone, the folder should be like the following. Let's open the VS and keep going. :)","title":"Create a new C++ Solution/Project"},{"location":"import-using-visualstudio/#import-vc-project","text":"We're going to add this library's windows project to the solution. Oh, never forget the x64 platform config! This library doesn't target x86 . The arch is supported by MSVC, but it's not in the maintenance plan for now.","title":"Import VC++ Project"},{"location":"import-using-visualstudio/#add-existing-project","text":"If you cloned the library like the above, you can find it after browsing the workspace. After import, open the Properties page and check the configruation. Change the 'Windows SDK Version' to installed one that you are going to use. It matters.","title":"Add Existing Project"},{"location":"import-using-visualstudio/#add-reference","text":"Now, change the reference of the ConsoleApplication1 project.","title":"Add Reference"},{"location":"import-using-visualstudio/#adjustment-for-the-moduleswindowsvcxproj","text":"","title":"Adjustment for the modules/windows.vcxproj"},{"location":"import-using-visualstudio/#include-directories","text":"With basic include directories of the VC++ project, there are 3 additional paths. $(ProjectDir)..\\interface : include folder for library interfaces $(ProjectDir)..\\external\\guideline\\include : C++ Core Guideline Support Library. <gsl/gsl> $(ProjectDir) : internal codes So we have to inherit 2 paths in our new project( ConsoleApplication1 ). After changing the 'Additional Include Directories', update the code like the follwing. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types int main ( int , char * []) { std :: cout << \"Hello Coroutine! \\n \" ; return 0 ; } Now, try the build. (I will do that with x64|Debug ). The build must fail because we didn't changed compiler option.","title":"Include Directories"},{"location":"import-using-visualstudio/#msvc-compier-options","text":"To build the C++ 20 Coroutine code, we have to set the option /await . Also, the language standard C++ 17 is required( /std:c++17 or /std:c++latest ). In case of the coroutine's project, the option is just like this. <Project DefaultTargets= \"Build\" ToolsVersion= \"15.0\" xmlns= \"http://schemas.microsoft.com/developer/msbuild/2003\" > <!-- ... --> <ItemDefinitionGroup Condition= \"'$(Configuration)|$(Platform)'=='Debug|x64'\" > <!-- ... --> <AdditionalOptions> /await %(AdditionalOptions) </AdditionalOptions> <LanguageStandard> stdcpplatest </LanguageStandard> <!-- ... --> Therefore the property of our ConsoleApplication1 need to be changed like the image.","title":"MSVC Compier Options"},{"location":"import-using-visualstudio/#linker-options","text":"Well, you don't have to care! :) Just try the new build. If something goes wrong, create a new issue with your screenshot and reproduction steps so I can help you.","title":"Linker Options"},{"location":"import-using-visualstudio/#try-this-example","text":"So this is our new code. The function doesn't suspend and returns nothing. It works just like normal void(void) subroutine, but it's enough to confirm our compiler supports the feature. #include \"pch.h\" // we won't touch this since it doesn't matter #include <iostream> #include <gsl/gsl> // from GSL #include <coroutine/return.h> // pre-defined return types using std :: experimental :: suspend_never ; using coro :: no_return ; // Destroy coroutine frame after co_return. // It's fire and forget manner auto no_suspend_no_return () -> no_return { co_await suspend_never {}; std :: cout << \"Hello Coroutine! \\n \" ; co_return ; } int main ( int , char * []) { no_suspend_no_return (); return 0 ; } Glad for a new C++ Coroutine user! The screen shot is here.","title":"Try this example"},{"location":"import-using-visualstudio/#questions-trouble-shooting","text":"This section is reserved to answer the question, \"If the add reference doesn't work, what should user try?\"","title":"Questions &amp; Trouble Shooting"},{"location":"import-using-visualstudio/#build-with-the-clang-cl","text":"Wow, really? You must install the LLVM packages first. Follow this document . I'm considering VS 2019's CMake integration for Clang-cl build tutorial. I will add a new document ASAP.","title":"Build with the Clang-cl ?"},{"location":"net-implementation-epoll/","text":"This document is under progress ... Epoll For Linux platform, it uses epoll . Expect & Ensures Socket Socket object for the argument must be O_NONBLOCK flagged. int64_t socket_create ( const addrinfo & hint ) { int64_t sd = socket ( hint . ai_family , hint . ai_socktype , hint . ai_protocol ); if ( sd == - 1 ) FAIL ( strerror ( errno )); return sd ; } void socket_set_option_nonblock ( int64_t sd ) { // make non-block/async REQUIRE ( fcntl ( sd , F_SETFL , O_NONBLOCK | O_ASYNC ) != - 1 ); } The library assumes that all socket descriptors will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SHUT_RDWR ); close ( sd ); } Control Flow and Data The table shows all system calls that are used for each interface functions. Interface Internal send_to epoll_ctl , sendto recv_from epoll_ctl , recvfrom send_stream epoll_ctl , send recv_stream epoll_ctl , recv wait_io_tasks epoll_wait , epoll_create1 , close Concurrent I/O control I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume Request This step works just like Winsock based implementation. auto recv_from ( uint64_t sd , sockaddr_in6 & remote , buffer_view_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . sd = sd ; work . from6 = addressof ( remote ); work . addrlen = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); } Progress Check fcntl checks the socket's flag for non blocking. If the socket is not flagged non-block, co_await will bypass the suspend step(which uses epoll ) and it will directed to blocking I/O. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true and bypass the epoll return true ; } Suspend coroutine_handle becomes user data of epoll event. However, if there is a pending recv , another recv request won't cancel the previous one . Therefore user have to be cautious about managing pending operations for the socket. struct event_data_t { int fd ; const size_t capacity ; unique_ptr < epoll_event [] > events ; // ... void try_add ( uint64_t sd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( fd , op , sd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } }; void io_recv_from :: suspend ( coroutine_task_t rh ) noexcept ( false ) { errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails } Polling and Resume Since only 1 event can be bound for a file descriptor, the implementation separates inbound and outbound. send , send_to uses inbound and recv , recv_from uses the other. wait_io_tasks function polls both like the following code. event_data_t inbound {}, outbound {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; for ( auto coro : inbound . wait ( half_time )) co_yield coro ; for ( auto coro : outbound . wait ( half_time )) co_yield coro ; } Limitations Current version doesn't provide interface for I/O cancel.","title":"Epoll"},{"location":"net-implementation-epoll/#epoll","text":"For Linux platform, it uses epoll .","title":"Epoll"},{"location":"net-implementation-epoll/#expect-ensures","text":"","title":"Expect &amp; Ensures"},{"location":"net-implementation-epoll/#socket","text":"Socket object for the argument must be O_NONBLOCK flagged. int64_t socket_create ( const addrinfo & hint ) { int64_t sd = socket ( hint . ai_family , hint . ai_socktype , hint . ai_protocol ); if ( sd == - 1 ) FAIL ( strerror ( errno )); return sd ; } void socket_set_option_nonblock ( int64_t sd ) { // make non-block/async REQUIRE ( fcntl ( sd , F_SETFL , O_NONBLOCK | O_ASYNC ) != - 1 ); } The library assumes that all socket descriptors will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SHUT_RDWR ); close ( sd ); }","title":"Socket"},{"location":"net-implementation-epoll/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to epoll_ctl , sendto recv_from epoll_ctl , recvfrom send_stream epoll_ctl , send recv_stream epoll_ctl , recv wait_io_tasks epoll_wait , epoll_create1 , close","title":"Control Flow and Data"},{"location":"net-implementation-epoll/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume","title":"Concurrent I/O control"},{"location":"net-implementation-epoll/#request","text":"This step works just like Winsock based implementation. auto recv_from ( uint64_t sd , sockaddr_in6 & remote , buffer_view_t buffer , io_work_t & work ) noexcept ( false ) -> io_recv_from & { work . sd = sd ; work . from6 = addressof ( remote ); work . addrlen = sizeof ( sockaddr_in6 ); work . buffer = buffer ; return * reinterpret_cast < io_recv_from *> ( addressof ( work )); }","title":"Request"},{"location":"net-implementation-epoll/#progress-check","text":"fcntl checks the socket's flag for non blocking. If the socket is not flagged non-block, co_await will bypass the suspend step(which uses epoll ) and it will directed to blocking I/O. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true and bypass the epoll return true ; }","title":"Progress Check"},{"location":"net-implementation-epoll/#suspend","text":"coroutine_handle becomes user data of epoll event. However, if there is a pending recv , another recv request won't cancel the previous one . Therefore user have to be cautious about managing pending operations for the socket. struct event_data_t { int fd ; const size_t capacity ; unique_ptr < epoll_event [] > events ; // ... void try_add ( uint64_t sd , epoll_event & req ) noexcept ( false ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( fd , op , sd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try with modification goto TRY_OP ; } throw system_error { errno , system_category (), \"epoll_ctl\" }; } }; void io_recv_from :: suspend ( coroutine_task_t rh ) noexcept ( false ) { errc = 0 ; epoll_event req {}; req . events = EPOLLIN | EPOLLONESHOT | EPOLLET ; req . data . ptr = rh . address (); inbound . try_add ( sd , req ); // throws if epoll_ctl fails }","title":"Suspend"},{"location":"net-implementation-epoll/#polling-and-resume","text":"Since only 1 event can be bound for a file descriptor, the implementation separates inbound and outbound. send , send_to uses inbound and recv , recv_from uses the other. wait_io_tasks function polls both like the following code. event_data_t inbound {}, outbound {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { const int half_time = duration_cast < milliseconds > ( timeout ). count () / 2 ; for ( auto coro : inbound . wait ( half_time )) co_yield coro ; for ( auto coro : outbound . wait ( half_time )) co_yield coro ; }","title":"Polling and Resume"},{"location":"net-implementation-epoll/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"net-implementation-kqueue/","text":"This document is under progress ... KQueue For Mac OS(Darwin) platform, it uses kqueue . Expect & Ensures Socket All expectations for socket object are same with epoll based implementation . Control Flow and Data The table shows all system calls that are used for each interface functions. Interface Internal send_to kevent64 , sendto recv_from kevent64 , recvfrom send_stream kevent64 , send recv_stream kevent64 , recv wait_io_tasks kqueue , kevent64 , close Concurrent I/O control I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume Request It performs argument copy(packing) auto send_stream ( uint64_t sd , buffer_view_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . sd = sd ; work . addrlen = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); } Progress Check The implementation equals to the case of epoll . If the socket is not O_NONBLOCK flagged, it won't use kqueue API. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return errc ; } Suspend Every requests will be one shot requests. Unlike epoll based implementation, it uses io_work for user data. void io_send :: suspend ( coroutine_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = sd ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); auto ec = kevent64 ( kq . fd , & req , 1 , // change nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; } Polling and Resume wait_io_tasks yields iterates kevent64 list. Each of their user data( io_work ) holds coroutine_handle , so the functuon yields them one by one. Current version doesn't use additional information in kevent64 , but the structure will be maintained to deliver it on demand. struct kqueue_data_t { int fd ; const size_t capacity ; unique_ptr < kevent64_s [] > events ; // ... }; kqueue_data_t kq {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); // wait for events ... auto count = kevent64 ( kq . fd , nullptr , 0 , // kq . events . get (), kq . capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { auto & ev = kq . events [ i ]; auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } resume operations perform actual i/o request and acquire its result. int64_t io_send :: resume () noexcept { const auto flag = addrlen ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; // -> io_work::error return sz ; } Limitations Current version doesn't provide interface for I/O cancel.","title":"Kqueue"},{"location":"net-implementation-kqueue/#kqueue","text":"For Mac OS(Darwin) platform, it uses kqueue .","title":"KQueue"},{"location":"net-implementation-kqueue/#expect-ensures","text":"","title":"Expect &amp; Ensures"},{"location":"net-implementation-kqueue/#socket","text":"All expectations for socket object are same with epoll based implementation .","title":"Socket"},{"location":"net-implementation-kqueue/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to kevent64 , sendto recv_from kevent64 , recvfrom send_stream kevent64 , send recv_stream kevent64 , recv wait_io_tasks kqueue , kevent64 , close","title":"Control Flow and Data"},{"location":"net-implementation-kqueue/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Polling and Resume","title":"Concurrent I/O control"},{"location":"net-implementation-kqueue/#request","text":"It performs argument copy(packing) auto send_stream ( uint64_t sd , buffer_view_t buffer , uint32_t flag , io_work_t & work ) noexcept ( false ) -> io_send & { static_assert ( sizeof ( socklen_t ) == sizeof ( uint32_t )); work . sd = sd ; work . addrlen = flag ; work . buffer = buffer ; return * reinterpret_cast < io_send *> ( addressof ( work )); }","title":"Request"},{"location":"net-implementation-kqueue/#progress-check","text":"The implementation equals to the case of epoll . If the socket is not O_NONBLOCK flagged, it won't use kqueue API. bool io_work_t :: ready () const noexcept { // non blocking operation is expected // going to suspend if ( fcntl ( sd , F_GETFL , 0 ) & O_NONBLOCK ) return false ; // not configured. return true // and bypass to the blocking I/O return true ; } uint32_t io_work_t :: error () const noexcept { return errc ; }","title":"Progress Check"},{"location":"net-implementation-kqueue/#suspend","text":"Every requests will be one shot requests. Unlike epoll based implementation, it uses io_work for user data. void io_send :: suspend ( coroutine_task_t rh ) noexcept ( false ) { static_assert ( sizeof ( void * ) <= sizeof ( uint64_t )); task = rh ; // one-shot, write registration (edge-trigger) kevent64_s req {}; req . ident = sd ; req . filter = EVFILT_WRITE ; req . flags = EV_ADD | EV_ENABLE | EV_ONESHOT ; req . fflags = 0 ; req . data = 0 ; req . udata = reinterpret_cast < uint64_t > ( static_cast < io_work_t *> ( this )); auto ec = kevent64 ( kq . fd , & req , 1 , // change nullptr , 0 , 0 , nullptr ); if ( ec == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; }","title":"Suspend"},{"location":"net-implementation-kqueue/#polling-and-resume","text":"wait_io_tasks yields iterates kevent64 list. Each of their user data( io_work ) holds coroutine_handle , so the functuon yields them one by one. Current version doesn't use additional information in kevent64 , but the structure will be maintained to deliver it on demand. struct kqueue_data_t { int fd ; const size_t capacity ; unique_ptr < kevent64_s [] > events ; // ... }; kqueue_data_t kq {}; auto wait_io_tasks ( nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > { timespec ts {}; const auto sec = duration_cast < seconds > ( timeout ); ts . tv_sec = sec . count (); ts . tv_nsec = ( timeout - sec ). count (); // wait for events ... auto count = kevent64 ( kq . fd , nullptr , 0 , // kq . events . get (), kq . capacity , // 0 , & ts ); if ( count == - 1 ) throw system_error { errno , system_category (), \"kevent64\" }; for ( auto i = 0 ; i < count ; ++ i ) { auto & ev = kq . events [ i ]; auto & work = * reinterpret_cast < io_work_t *> ( ev . udata ); // need to pass error information from // kevent to io_work co_yield work . task ; } } resume operations perform actual i/o request and acquire its result. int64_t io_send :: resume () noexcept { const auto flag = addrlen ; const auto sz = send ( sd , buffer . data (), buffer . size_bytes (), flag ); errc = sz < 0 ? errno : 0 ; // -> io_work::error return sz ; }","title":"Polling and Resume"},{"location":"net-implementation-kqueue/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"net-implementation-winsock2/","text":"This document is under progress ... Coroutine + Socket Overlapped I/O + Completion Routine See Also CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Implementation Code Winsock Overlapped I/O Remarks The library never invoke WSAStartup and WSACleanup . User must do it. Socket socket object for the argument must be WSA_FLAG_OVERLAPPED flagged. int64_t socket_create ( const addrinfo & hint ) { // use address hint in test class int64_t sd = :: WSASocketW ( hint . ai_family , hint . ai_socktype , hint . ai_protocol , nullptr , 0 , WSA_FLAG_OVERLAPPED ); if ( sd == INVALID_SOCKET ) fail_with_error_message ( WSAGetLastError ()); return sd ; } The library assumes that SOCKET will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SD_BOTH ); closesocket ( sd ); } Control Flow and Data The table shows all system calls that are used for each interface functions. Interface Internal send_to WSASendTo recv_from WSARecvFrom send_stream WSASend recv_stream WSARecv io_work_t containes OVERLAPPED struct . struct io_work_t : public OVERLAPPED { coroutine_task_t task {}; buffer_view_t buffer {}; union { sockaddr * addr {}; sockaddr_in6 * from6 ; const sockaddr_in6 * to6 ; sockaddr_in * from ; const sockaddr_in * to ; }; }; Since it uses completion routine to resume I/O coroutines, wait_io_tasks will always return 0 coroutine handle. // file: <coroutine/net.h> // - Note // This function is only non-windows platform. // Over windows api, it always yields nothing. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > ; Concurrent I/O control I/O Request I/O Progress Check I/O Suspend I/O Resume Request The interface function converts given arguments to invoke Winsock API. auto send_to ( uint64_t sd , const sockaddr_in6 & remote , buffer_view_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); work . buffer = buffer ; work . to6 = std :: addressof ( remote ); work . Internal = sd ; work . InternalHigh = sizeof ( remote ); // lead to co_await operations with `io_send_to` type return * reinterpret_cast < io_send_to *> ( std :: addressof ( work )); } Progress Check Always leads to suspend procedure. bool io_work_t :: ready () const noexcept { return false ; // trigger `await_suspend` } Suspend Actual request comes after coroutine_handle is forwarded. void io_send_to :: suspend ( coroutine_task_t rh ) noexcept ( false ) { const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = DWORD { 0 }; const auto sd = gsl :: narrow_cast < SOCKET > ( Internal ); auto bufs = make_wsa_buf ( buffer ); task = rh ; // coroutine for the i/o callback :: WSASendTo ( sd , & bufs , 1 , // nullptr , flag , addr , addrlen , // zero_overlapped ( this ), onWorkDone ); const auto ec = WSAGetLastError (); if ( ec == NO_ERROR || ec == ERROR_IO_PENDING ) return ; // ok. expected for async i/o throw std :: system_error { ec , std :: system_category (), \"WSASendTo\" }; } int64_t io_send_to :: resume () noexcept { return gsl :: narrow_cast < int64_t > ( InternalHigh ); } Resume (by Completion Routine) Completion routine resumes its coroutine frame. io_work works as a receiver for the operation results. void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); work -> Internal = errc ; // -> return of `await_resume()` work -> InternalHigh = sz ; // -> return of `work.error()` work -> task . resume (); } In general(x64), Internal and InternalHigh already have same value with errc , sz . The routine just ensures it. Limitations Current version doesn't provide interface for I/O cancel.","title":"Windows Socket 2"},{"location":"net-implementation-winsock2/#see-also","text":"CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" CppCon 2016 : Kenny Kerr & James McNellis \"Putting Coroutines to Work with the Windows Runtime\" Implementation Code","title":"See Also"},{"location":"net-implementation-winsock2/#winsock-overlapped-io","text":"","title":"Winsock Overlapped I/O"},{"location":"net-implementation-winsock2/#remarks","text":"The library never invoke WSAStartup and WSACleanup . User must do it.","title":"Remarks"},{"location":"net-implementation-winsock2/#socket","text":"socket object for the argument must be WSA_FLAG_OVERLAPPED flagged. int64_t socket_create ( const addrinfo & hint ) { // use address hint in test class int64_t sd = :: WSASocketW ( hint . ai_family , hint . ai_socktype , hint . ai_protocol , nullptr , 0 , WSA_FLAG_OVERLAPPED ); if ( sd == INVALID_SOCKET ) fail_with_error_message ( WSAGetLastError ()); return sd ; } The library assumes that SOCKET will be destroyed like the following code. void socket_close ( int64_t sd ) { shutdown ( sd , SD_BOTH ); closesocket ( sd ); }","title":"Socket"},{"location":"net-implementation-winsock2/#control-flow-and-data","text":"The table shows all system calls that are used for each interface functions. Interface Internal send_to WSASendTo recv_from WSARecvFrom send_stream WSASend recv_stream WSARecv io_work_t containes OVERLAPPED struct . struct io_work_t : public OVERLAPPED { coroutine_task_t task {}; buffer_view_t buffer {}; union { sockaddr * addr {}; sockaddr_in6 * from6 ; const sockaddr_in6 * to6 ; sockaddr_in * from ; const sockaddr_in * to ; }; }; Since it uses completion routine to resume I/O coroutines, wait_io_tasks will always return 0 coroutine handle. // file: <coroutine/net.h> // - Note // This function is only non-windows platform. // Over windows api, it always yields nothing. auto wait_io_tasks ( std :: chrono :: nanoseconds timeout ) noexcept ( false ) -> enumerable < coroutine_task_t > ;","title":"Control Flow and Data"},{"location":"net-implementation-winsock2/#concurrent-io-control","text":"I/O Request I/O Progress Check I/O Suspend I/O Resume","title":"Concurrent I/O control"},{"location":"net-implementation-winsock2/#request","text":"The interface function converts given arguments to invoke Winsock API. auto send_to ( uint64_t sd , const sockaddr_in6 & remote , buffer_view_t buffer , io_work_t & work ) noexcept ( false ) -> io_send_to & { static_assert ( sizeof ( SOCKET ) == sizeof ( uint64_t )); static_assert ( sizeof ( HANDLE ) == sizeof ( SOCKET )); work . buffer = buffer ; work . to6 = std :: addressof ( remote ); work . Internal = sd ; work . InternalHigh = sizeof ( remote ); // lead to co_await operations with `io_send_to` type return * reinterpret_cast < io_send_to *> ( std :: addressof ( work )); }","title":"Request"},{"location":"net-implementation-winsock2/#progress-check","text":"Always leads to suspend procedure. bool io_work_t :: ready () const noexcept { return false ; // trigger `await_suspend` }","title":"Progress Check"},{"location":"net-implementation-winsock2/#suspend","text":"Actual request comes after coroutine_handle is forwarded. void io_send_to :: suspend ( coroutine_task_t rh ) noexcept ( false ) { const auto addrlen = gsl :: narrow_cast < socklen_t > ( InternalHigh ); const auto flag = DWORD { 0 }; const auto sd = gsl :: narrow_cast < SOCKET > ( Internal ); auto bufs = make_wsa_buf ( buffer ); task = rh ; // coroutine for the i/o callback :: WSASendTo ( sd , & bufs , 1 , // nullptr , flag , addr , addrlen , // zero_overlapped ( this ), onWorkDone ); const auto ec = WSAGetLastError (); if ( ec == NO_ERROR || ec == ERROR_IO_PENDING ) return ; // ok. expected for async i/o throw std :: system_error { ec , std :: system_category (), \"WSASendTo\" }; } int64_t io_send_to :: resume () noexcept { return gsl :: narrow_cast < int64_t > ( InternalHigh ); }","title":"Suspend"},{"location":"net-implementation-winsock2/#resume-by-completion-routine","text":"Completion routine resumes its coroutine frame. io_work works as a receiver for the operation results. void CALLBACK onWorkDone ( DWORD errc , DWORD sz , LPWSAOVERLAPPED pover , DWORD flags ) noexcept { UNREFERENCED_PARAMETER ( flags ); io_work_t * work = reinterpret_cast < io_work_t *> ( pover ); work -> Internal = errc ; // -> return of `await_resume()` work -> InternalHigh = sz ; // -> return of `work.error()` work -> task . resume (); } In general(x64), Internal and InternalHigh already have same value with errc , sz . The routine just ensures it.","title":"Resume (by Completion Routine)"},{"location":"net-implementation-winsock2/#limitations","text":"Current version doesn't provide interface for I/O cancel.","title":"Limitations"},{"location":"net-overview/","text":"This document is under progress ... The document explains how to use async socket I/O functions. See Also CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\" Example test/net/catch2_socket_echo_tcp.cpp test/net/vs_socket_echo_udp.cpp Overview Pattern User must use 2 parts to use the interface. I/O coroutine I/O polling subroutine 1 I/O Reqeust == 1 Coroutine Each I/O request flows sequentially. Polling subroutine will yields coroutines with finished(errored) I/O. auto user_io_coroutine ( int64_t socket ) -> some_return_type { io_work_t work {}; // control block object buffer_view_t buf {}; // { byte*, size_t } endpoint_t remote {}; // this is the only allowed usage pattern int64_t sz = co_await io_request ( socket , remote , buf , work ) if ( sz == - 1 ) { // errc is updated after the request auto errc = work . error (); // ... } // ... } For version 1.4, io_request can be one of following functions. Interface Description send_to Send to a specific endpoint( sockaddr ) recv_from Receive a packet and set the sender's endpoint( sockaddr ) send_stream Send to the socket's connected peer recv_stream Receive from the socket's connected peer Continuation of I/O Request User can pool until all I/O coroutines are finished with wait_io_tasks function. It will yield at least 0 coroutine handle. auto example_io_polling ( bool & all_io_finished ) { // timeout with <chrono> using namespace std :: chrono_literals ; // ... while ( all_io_finished == false ) for ( auto coro : wait_io_tasks ( 10 ms )) coro . resume (); // ... } Remarks Library doesn't provide create/destroy/option for the socket . It just expects that the given socket is non-block and async one, and it works as designed only for the case. Current version doesn't use scatter/gather operation. Examples wait_io_tasks send_to recv_from send_stream recv_stream Waiting I/O coroutines The library header declares constexpr variable to check underlying API. Since winsock implementation resumes I/O coroutines automatically. However, user must have some method to detect all coroutines are finished. wait_group can be one of the way. void wait_example () { if constexpr ( is_winsock == false ) { // unlike windows api, we have to resume tasks manually // the library doesn't guarantee they will be fetched at once // so user have to repeat enough to finish all i/o tasks auto count = 30 ; while ( count -- ) { for ( auto task : wait_io_tasks ( 10 ms )) task . resume (); } } } Sending to a specific endpoint The following code shows how send_to can be used. auto coro_send_dgram ( int64_t sd , const sockaddr_in & remote , int64_t & ssz ) -> return_ignore { using gsl :: byte ; io_work_t work {}; array < byte , 782 > storage {}; ssz = co_await send_to ( sd , remote , storage , work ); if ( auto errc = work . error ()) { CAPTURE ( errc ); FAIL ( std :: system_category (). message ( errc )); } REQUIRE ( ssz == storage . size ()); } Receiving a packet The following code shows how recv_from can be used. auto coro_recv_dgram ( int64_t sd , sockaddr_in & remote , int64_t & rsz ) -> return_ignore { using gsl :: byte ; io_work_t work {}; array < byte , 1253 > storage {}; rsz = co_await recv_from ( sd , remote , storage , work ); if ( auto errc = work . error ()) { CAPTURE ( errc ); FAIL ( std :: system_category (). message ( errc )); } REQUIRE ( rsz > 0 ); } Sending to the connected peer The following code shows how send_stream can be used. auto coro_send_stream ( int64_t sd , int64_t & ssz ) -> return_ignore { using gsl :: byte ; io_work_t work {}; array < byte , 1523 > storage {}; ssz = co_await send_stream ( sd , storage , 0 , work ); if ( auto errc = work . error ()) { CAPTURE ( errc ); FAIL ( std :: system_category (). message ( errc )); } REQUIRE ( ssz > 0 ); } Receiving from the connected peer The following code shows how recv_stream can be used. auto coro_recv_stream ( int64_t sd , int64_t & rsz ) -> return_ignore { using gsl :: byte ; io_work_t work {}; array < byte , 2000 > storage {}; rsz = co_await recv_stream ( sd , storage , 0 , work ); if ( auto errc = work . error ()) { CAPTURE ( errc ); FAIL ( std :: system_category (). message ( errc )); } REQUIRE ( rsz > 0 ); } `` ### Type Declarations ``` c ++ #include <experimental/coroutine> // or <coroutine/frame.h> #include <gsl/gsl> using coroutine_task_t = std :: experimental :: coroutine_handle < void > ; using buffer_view_t = gsl :: span < gsl :: byte > ; union endpoint_t final { sockaddr_storage storage {}; sockaddr addr ; sockaddr_in in4 ; sockaddr_in6 in6 ; }; Code generation from co_await According to the coroutine proposal, code generation from co_await operator will be like the following auto user_io_coroutine ( int64_t socket ) -> some_return_type { io_work_t work {}; // control block object buffer_view_t buf {}; // { byte*, size_t } endpoint_t remote {}; // 1. make i/o request auto & op = some_io_request ( socket , remote , buf , work ); // 2. operation result is available? if ( op . ready () == false ) { op . suspend (); // 3. prepare suspension // ---- suspend point ---- } // ---- resumed after i/o processing ---- int64_t sz = op . resume (); // 4. i/o result is now available if ( sz == - 1 ) { auto errc = work . error (); // errc can be fetched multiple times // unless another request is made // ... } } Eventually, 4 functions participate in each request. I/O Request I/O Progress Check I/O Suspend I/O Resume The library functions works as expectd if and only if they are invoked in the order. The other case their behavior is undefined.","title":"Overview"},{"location":"net-overview/#see-also","text":"CppCon 2017 : Gor Nishanov \"Naked coroutines live(with networking)\"","title":"See Also"},{"location":"net-overview/#example","text":"test/net/catch2_socket_echo_tcp.cpp test/net/vs_socket_echo_udp.cpp","title":"Example"},{"location":"net-overview/#overview","text":"","title":"Overview"},{"location":"net-overview/#pattern","text":"User must use 2 parts to use the interface. I/O coroutine I/O polling subroutine","title":"Pattern"},{"location":"net-overview/#1-io-reqeust-1-coroutine","text":"Each I/O request flows sequentially. Polling subroutine will yields coroutines with finished(errored) I/O. auto user_io_coroutine ( int64_t socket ) -> some_return_type { io_work_t work {}; // control block object buffer_view_t buf {}; // { byte*, size_t } endpoint_t remote {}; // this is the only allowed usage pattern int64_t sz = co_await io_request ( socket , remote , buf , work ) if ( sz == - 1 ) { // errc is updated after the request auto errc = work . error (); // ... } // ... } For version 1.4, io_request can be one of following functions. Interface Description send_to Send to a specific endpoint( sockaddr ) recv_from Receive a packet and set the sender's endpoint( sockaddr ) send_stream Send to the socket's connected peer recv_stream Receive from the socket's connected peer","title":"1 I/O Reqeust == 1 Coroutine"},{"location":"net-overview/#continuation-of-io-request","text":"User can pool until all I/O coroutines are finished with wait_io_tasks function. It will yield at least 0 coroutine handle. auto example_io_polling ( bool & all_io_finished ) { // timeout with <chrono> using namespace std :: chrono_literals ; // ... while ( all_io_finished == false ) for ( auto coro : wait_io_tasks ( 10 ms )) coro . resume (); // ... }","title":"Continuation of I/O Request"},{"location":"net-overview/#remarks","text":"Library doesn't provide create/destroy/option for the socket . It just expects that the given socket is non-block and async one, and it works as designed only for the case. Current version doesn't use scatter/gather operation.","title":"Remarks"},{"location":"net-overview/#examples","text":"wait_io_tasks send_to recv_from send_stream recv_stream","title":"Examples"},{"location":"net-overview/#waiting-io-coroutines","text":"The library header declares constexpr variable to check underlying API. Since winsock implementation resumes I/O coroutines automatically. However, user must have some method to detect all coroutines are finished. wait_group can be one of the way. void wait_example () { if constexpr ( is_winsock == false ) { // unlike windows api, we have to resume tasks manually // the library doesn't guarantee they will be fetched at once // so user have to repeat enough to finish all i/o tasks auto count = 30 ; while ( count -- ) { for ( auto task : wait_io_tasks ( 10 ms )) task . resume (); } } }","title":"Waiting I/O coroutines"},{"location":"net-overview/#sending-to-a-specific-endpoint","text":"The following code shows how send_to can be used. auto coro_send_dgram ( int64_t sd , const sockaddr_in & remote , int64_t & ssz ) -> return_ignore { using gsl :: byte ; io_work_t work {}; array < byte , 782 > storage {}; ssz = co_await send_to ( sd , remote , storage , work ); if ( auto errc = work . error ()) { CAPTURE ( errc ); FAIL ( std :: system_category (). message ( errc )); } REQUIRE ( ssz == storage . size ()); }","title":"Sending to a specific endpoint"},{"location":"net-overview/#receiving-a-packet","text":"The following code shows how recv_from can be used. auto coro_recv_dgram ( int64_t sd , sockaddr_in & remote , int64_t & rsz ) -> return_ignore { using gsl :: byte ; io_work_t work {}; array < byte , 1253 > storage {}; rsz = co_await recv_from ( sd , remote , storage , work ); if ( auto errc = work . error ()) { CAPTURE ( errc ); FAIL ( std :: system_category (). message ( errc )); } REQUIRE ( rsz > 0 ); }","title":"Receiving a packet"},{"location":"net-overview/#sending-to-the-connected-peer","text":"The following code shows how send_stream can be used. auto coro_send_stream ( int64_t sd , int64_t & ssz ) -> return_ignore { using gsl :: byte ; io_work_t work {}; array < byte , 1523 > storage {}; ssz = co_await send_stream ( sd , storage , 0 , work ); if ( auto errc = work . error ()) { CAPTURE ( errc ); FAIL ( std :: system_category (). message ( errc )); } REQUIRE ( ssz > 0 ); }","title":"Sending to the connected peer"},{"location":"net-overview/#receiving-from-the-connected-peer","text":"The following code shows how recv_stream can be used. auto coro_recv_stream ( int64_t sd , int64_t & rsz ) -> return_ignore { using gsl :: byte ; io_work_t work {}; array < byte , 2000 > storage {}; rsz = co_await recv_stream ( sd , storage , 0 , work ); if ( auto errc = work . error ()) { CAPTURE ( errc ); FAIL ( std :: system_category (). message ( errc )); } REQUIRE ( rsz > 0 ); } `` ### Type Declarations ``` c ++ #include <experimental/coroutine> // or <coroutine/frame.h> #include <gsl/gsl> using coroutine_task_t = std :: experimental :: coroutine_handle < void > ; using buffer_view_t = gsl :: span < gsl :: byte > ; union endpoint_t final { sockaddr_storage storage {}; sockaddr addr ; sockaddr_in in4 ; sockaddr_in6 in6 ; };","title":"Receiving from the connected peer"},{"location":"net-overview/#code-generation-from-co_await","text":"According to the coroutine proposal, code generation from co_await operator will be like the following auto user_io_coroutine ( int64_t socket ) -> some_return_type { io_work_t work {}; // control block object buffer_view_t buf {}; // { byte*, size_t } endpoint_t remote {}; // 1. make i/o request auto & op = some_io_request ( socket , remote , buf , work ); // 2. operation result is available? if ( op . ready () == false ) { op . suspend (); // 3. prepare suspension // ---- suspend point ---- } // ---- resumed after i/o processing ---- int64_t sz = op . resume (); // 4. i/o result is now available if ( sz == - 1 ) { auto errc = work . error (); // errc can be fetched multiple times // unless another request is made // ... } } Eventually, 4 functions participate in each request. I/O Request I/O Progress Check I/O Suspend I/O Resume The library functions works as expectd if and only if they are invoked in the order. The other case their behavior is undefined.","title":"Code generation from co_await"},{"location":"return-frame/","text":"Coroutine function returns an object for first suspend or first return. See Also n4736 Coroutine Promise Requirements Example test/c2_return.cpp Frame Return When user can (and have to) manage the destruction of coroutine frame, frame allows to acquire the coroutine_handle<void> . // when the coroutine frame destuction need to be controlled manually, // just return `coroutine_handle<void>`. // `<coroutine/return.h>` supports template specialization of // `coroutine_traits` for the case. The type implements... // return_void // initial_suspend -> suspend_never // final_suspend -> suspend_always auto invoke_and_get_frame_after_first_suspend () -> frame { co_await suspend_never {}; co_return ; // only void return }; TEST_CASE ( \"get coroutine_handle after first suspend \" , \"[return]\" ) { auto frame = invoke_and_get_frame_after_first_suspend (); // allow access to `coroutine_handle<void>` // after first suspend(which can be `co_return`) coroutine_handle < void >& coro = frame ; REQUIRE ( static_cast < bool > ( coro )); // not null REQUIRE ( coro . done ()); // expect final suspended REQUIRE_NOTHROW ( coro . destroy ()); // destroy it } Remarks The frame will remain final suspended after co_return . class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final { auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_always {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part } auto get_return_object () noexcept -> promise_type * { return this ; } static auto get_return_object_on_allocation_failure () noexcept -> promise_type * { return nullptr ; } }; public : // override `suspend_always::await_suspend` // provide interface to receive handle after being used as an argument of // `co_await` by reference void await_suspend ( coroutine_handle < void > coro ) noexcept { coroutine_handle < void >& self = * this ; self = coro ; } frame () noexcept = default ; frame ( promise_type * p ) noexcept { this -> await_suspend ( coroutine_handle < promise_type >:: from_promise ( * p )); } }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro Frame Awaitable The type can be also used as an awaitable to receive coroutine_handle<void> . You may think this support harms the Single Responsibility Principle, writing another type for this will make the code tedious. using namespace coro ; auto save_current_handle_to_frame ( frame & fh , int & status ) -> no_return { auto defer = gsl :: finally ([ & ]() { status = 3 ; // change state on destruction phase }); status = 1 ; co_await fh ; // frame holder is also an awaitable. status = 2 ; co_await fh ; co_return ; } TEST_CASE ( \"save coroutine_handle to frame object\" , \"[return]\" ) { int status = 0 ; frame coro {}; save_current_handle_to_frame ( coro , status ); REQUIRE ( status == 1 ); coro . resume (); // `frame` inherits `coroutine_handle<void>` REQUIRE ( status == 2 ); coro . resume (); // coroutine reached end. REQUIRE ( status == 3 ); // so `defer` in the routine will change status }","title":"frame"},{"location":"return-frame/#see-also","text":"n4736 Coroutine Promise Requirements","title":"See Also"},{"location":"return-frame/#example","text":"test/c2_return.cpp","title":"Example"},{"location":"return-frame/#frame-return","text":"When user can (and have to) manage the destruction of coroutine frame, frame allows to acquire the coroutine_handle<void> . // when the coroutine frame destuction need to be controlled manually, // just return `coroutine_handle<void>`. // `<coroutine/return.h>` supports template specialization of // `coroutine_traits` for the case. The type implements... // return_void // initial_suspend -> suspend_never // final_suspend -> suspend_always auto invoke_and_get_frame_after_first_suspend () -> frame { co_await suspend_never {}; co_return ; // only void return }; TEST_CASE ( \"get coroutine_handle after first suspend \" , \"[return]\" ) { auto frame = invoke_and_get_frame_after_first_suspend (); // allow access to `coroutine_handle<void>` // after first suspend(which can be `co_return`) coroutine_handle < void >& coro = frame ; REQUIRE ( static_cast < bool > ( coro )); // not null REQUIRE ( coro . done ()); // expect final suspended REQUIRE_NOTHROW ( coro . destroy ()); // destroy it }","title":"Frame Return"},{"location":"return-frame/#remarks","text":"The frame will remain final suspended after co_return . class frame final : public coroutine_handle < void > , public suspend_always { public : struct promise_type final { auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_always {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part } auto get_return_object () noexcept -> promise_type * { return this ; } static auto get_return_object_on_allocation_failure () noexcept -> promise_type * { return nullptr ; } }; public : // override `suspend_always::await_suspend` // provide interface to receive handle after being used as an argument of // `co_await` by reference void await_suspend ( coroutine_handle < void > coro ) noexcept { coroutine_handle < void >& self = * this ; self = coro ; } frame () noexcept = default ; frame ( promise_type * p ) noexcept { this -> await_suspend ( coroutine_handle < promise_type >:: from_promise ( * p )); } }; static_assert ( sizeof ( frame ) == sizeof ( coroutine_handle < void > )); } // namespace coro","title":"Remarks"},{"location":"return-frame/#frame-awaitable","text":"The type can be also used as an awaitable to receive coroutine_handle<void> . You may think this support harms the Single Responsibility Principle, writing another type for this will make the code tedious. using namespace coro ; auto save_current_handle_to_frame ( frame & fh , int & status ) -> no_return { auto defer = gsl :: finally ([ & ]() { status = 3 ; // change state on destruction phase }); status = 1 ; co_await fh ; // frame holder is also an awaitable. status = 2 ; co_await fh ; co_return ; } TEST_CASE ( \"save coroutine_handle to frame object\" , \"[return]\" ) { int status = 0 ; frame coro {}; save_current_handle_to_frame ( coro , status ); REQUIRE ( status == 1 ); coro . resume (); // `frame` inherits `coroutine_handle<void>` REQUIRE ( status == 2 ); coro . resume (); // coroutine reached end. REQUIRE ( status == 3 ); // so `defer` in the routine will change status }","title":"Frame Awaitable"},{"location":"return-no_return/","text":"void return type for coroutine See Also n4736 Coroutine Promise Requirements Example test/c2_return.cpp No Return Since coroutine can suspend, it is not recommended that to return value from coroutine to its caller/resumer. If the return can be ignored, just like void return, no_return can do the work. using namespace coro ; // if user doesn't care about coroutine's life cycle, // use `no_return`. // at least the routine will be resumed(continued) properly, // `co_return` will destroy the frame auto invoke_and_forget_frame () -> no_return { co_await suspend_never {}; co_return ; }; TEST_CASE ( \"no_return\" , \"[return]\" ) { REQUIRE_NOTHROW ( invoke_and_forget_frame ()); } Remarks Since promise_type does not final suspend, a frame of the coroutine that return no_return type will destroyed immediately. namespace coro { // General `void` return for coroutine. // It doesn't provide any method to get control or value from the resumable // function class no_return final { public : class promise_type final { public : // No suspend for init/final suspension point auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part } }; }; } // namespace coro","title":"no_return"},{"location":"return-no_return/#see-also","text":"n4736 Coroutine Promise Requirements","title":"See Also"},{"location":"return-no_return/#example","text":"test/c2_return.cpp","title":"Example"},{"location":"return-no_return/#no-return","text":"Since coroutine can suspend, it is not recommended that to return value from coroutine to its caller/resumer. If the return can be ignored, just like void return, no_return can do the work. using namespace coro ; // if user doesn't care about coroutine's life cycle, // use `no_return`. // at least the routine will be resumed(continued) properly, // `co_return` will destroy the frame auto invoke_and_forget_frame () -> no_return { co_await suspend_never {}; co_return ; }; TEST_CASE ( \"no_return\" , \"[return]\" ) { REQUIRE_NOTHROW ( invoke_and_forget_frame ()); }","title":"No Return"},{"location":"return-no_return/#remarks","text":"Since promise_type does not final suspend, a frame of the coroutine that return no_return type will destroyed immediately. namespace coro { // General `void` return for coroutine. // It doesn't provide any method to get control or value from the resumable // function class no_return final { public : class promise_type final { public : // No suspend for init/final suspension point auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { // nothing to do because this is `void` return } void unhandled_exception () noexcept ( false ) { // customize this part } }; }; } // namespace coro","title":"Remarks"},{"location":"return-overview/","text":"","title":"Overview"},{"location":"yield-enumerable/","text":"This document is under progress... Generator with coroutine See Also <experimental/generator> : implementation in VC++ or libc++ https://github.com/kirkshoop/await http://cpp.mimuw.edu.pl/files/await-yield-c++-coroutines.pdf Example test/c2_yield.cpp Enumerable This is a similar implementation of generator . Since the name is a kind of reserved one, it is renamed to enumerable template < typename T > class enumerable final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; enumerable contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements. Template Parameters T : the type of element in the enumerable. Default Operations Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class enumerable final { public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( promise_type * ptr ) noexcept ; ~ enumerable () noexcept ; }; Coroutine frame for the generator is managed automatically. TEST_CASE ( \"generator\" , \"[generic]\" ) { using namespace std :: experimental ; SECTION ( \"max_element\" ) { std :: array < uint16_t , 10 > container {}; uint16_t id = 15 ; for ( auto & e : container ) e = id -- ; // [15, 14, 13 ... // so the first element will hold the largest number // since generator is not a container, // using max_element (or min_element) function on it // will return invalid iterator auto try_enumerable = [ & ]() -> enumerable < uint16_t > { for ( auto e : container ) co_yield e ; co_return ; }; auto g = try_enumerable (); auto it = std :: max_element ( g . begin (), g . end ()); // after iteration is finished (co_return), // the iterator will hold nullptr. REQUIRE ( it . operator -> () == nullptr ); // so referencing it will lead to access violation // REQUIRE(*it == 15); } // ... } Functions Function Description begin Start fetching elements until co_return . end End of the enumerable. template < typename T > class enumerable final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; }; Sub Types Promise The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the generator coroutine yield_value Yield the given element and allow its consumer to access it template < typename T > class enumerable final { public : class promise_type final { public : auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; auto yield_value ( reference ref ) noexcept ; void return_void () noexcept ; void unhandled_exception () noexcept ; promise_type * get_return_object () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; Iterator Notice the iterator uses std::input_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Also, as an iterator type, it supports * , -> , == , != . template < typename T > class enumerable final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Generator"},{"location":"yield-enumerable/#see-also","text":"<experimental/generator> : implementation in VC++ or libc++ https://github.com/kirkshoop/await http://cpp.mimuw.edu.pl/files/await-yield-c++-coroutines.pdf","title":"See Also"},{"location":"yield-enumerable/#example","text":"test/c2_yield.cpp","title":"Example"},{"location":"yield-enumerable/#enumerable","text":"This is a similar implementation of generator . Since the name is a kind of reserved one, it is renamed to enumerable template < typename T > class enumerable final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; enumerable contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements.","title":"Enumerable"},{"location":"yield-enumerable/#template-parameters","text":"T : the type of element in the enumerable.","title":"Template Parameters"},{"location":"yield-enumerable/#default-operations","text":"Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class enumerable final { public : enumerable ( const enumerable & ) = delete ; enumerable & operator = ( const enumerable & ) = delete ; enumerable ( promise_type * ptr ) noexcept ; ~ enumerable () noexcept ; }; Coroutine frame for the generator is managed automatically. TEST_CASE ( \"generator\" , \"[generic]\" ) { using namespace std :: experimental ; SECTION ( \"max_element\" ) { std :: array < uint16_t , 10 > container {}; uint16_t id = 15 ; for ( auto & e : container ) e = id -- ; // [15, 14, 13 ... // so the first element will hold the largest number // since generator is not a container, // using max_element (or min_element) function on it // will return invalid iterator auto try_enumerable = [ & ]() -> enumerable < uint16_t > { for ( auto e : container ) co_yield e ; co_return ; }; auto g = try_enumerable (); auto it = std :: max_element ( g . begin (), g . end ()); // after iteration is finished (co_return), // the iterator will hold nullptr. REQUIRE ( it . operator -> () == nullptr ); // so referencing it will lead to access violation // REQUIRE(*it == 15); } // ... }","title":"Default Operations"},{"location":"yield-enumerable/#functions","text":"Function Description begin Start fetching elements until co_return . end End of the enumerable. template < typename T > class enumerable final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; };","title":"Functions"},{"location":"yield-enumerable/#sub-types","text":"","title":"Sub Types"},{"location":"yield-enumerable/#promise","text":"The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the generator coroutine yield_value Yield the given element and allow its consumer to access it template < typename T > class enumerable final { public : class promise_type final { public : auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; auto yield_value ( reference ref ) noexcept ; void return_void () noexcept ; void unhandled_exception () noexcept ; promise_type * get_return_object () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; };","title":"Promise"},{"location":"yield-enumerable/#iterator","text":"Notice the iterator uses std::input_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Also, as an iterator type, it supports * , -> , == , != . template < typename T > class enumerable final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Iterator"},{"location":"yield-overview/","text":"","title":"Overview"},{"location":"yield-sequence/","text":"This document is under progress... Generator + Async Iterator See Also <experimental/generator> : implementation in VC++ or libc++ https://github.com/kirkshoop/await http://cpp.mimuw.edu.pl/files/await-yield-c++-coroutines.pdf Example test/c2_yield.cpp Sequence sequence is an abstraction for the async generator. It is not named async_generator to imply that it's just one implementation of the concept. template < typename T > class sequence final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; sequence contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements. Template Parameters T : the type of element in the sequence. Default Operations Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class sequence final { public : sequence ( sequence & ) = delete ; sequence & operator = ( sequence & ) = delete ; sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; It is expected that the user code will destroy the coroutine frame of the sequence manually . This is inconvenient but must be ensured like the following example. TEST_CASE ( \"async_generator\" , \"[generic]\" ) { using namespace std :: experimental ; // for async generator, // its coroutine frame must be alive for some case. return_frame frame {}; auto ensure_destroy_frame = gsl :: finally ([ = ]() { if ( auto coro = static_cast < coroutine_handle < void >> ( frame )) coro . destroy (); }); SECTION ( \"yield once\" ) { auto example = []() -> sequence < int > { int v = 333 ; co_yield v ; co_return ; }; auto use_sequence = [ = ]( int & ref ) -> return_frame { for co_await ( int v : example ()) ref = v ; co_return ; }; int value = 0 ; REQUIRE_NOTHROW ( frame = use_sequence ( value )); REQUIRE ( value == 333 ); } // ... } Functions Function Description begin Start the sequence coroutine and fetch elements until co_yield receives some awaitable. end End of the sequence. template < typename T > class sequence final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; }; Sub Types Promise The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the sequence coroutine yield_value<Awaitable> Trigger suspend until the given Awaitable is resumed. yield_value Yield the given element and notify to consumer coroutine When the next element is unavailable, programmer suspend it by co_yield ing an awaitable. The promise_type allows to distinguish between the new element and programmer's awaitable by using itself as an awaitable. Function Description await_ready true if consumer is waiting for the sequence coroutine. await_suspend Save the sequence coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (user of the sequence ). template < typename T > class sequence final { public : class promise_type final { public : void unhandled_exception () noexcept ; auto get_return_object () noexcept -> promise_type * ; auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; promise_type & yield_value ( reference ref ) noexcept ; template < typename Awaitable > Awaitable & yield_value ( Awaitable && a ) noexcept ; void return_void () noexcept ; bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; void await_resume () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; Iterator Notice the iterator uses std::input_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Like normal iterator types, it supports * , -> , == , != . However, the iterator itself is an awaitable . Function Description await_ready false if the element is not available. true for the other case. await_suspend Save the current coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (this). template < typename T > class sequence final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; iterator & await_resume () noexcept ; reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Async Generator"},{"location":"yield-sequence/#see-also","text":"<experimental/generator> : implementation in VC++ or libc++ https://github.com/kirkshoop/await http://cpp.mimuw.edu.pl/files/await-yield-c++-coroutines.pdf","title":"See Also"},{"location":"yield-sequence/#example","text":"test/c2_yield.cpp","title":"Example"},{"location":"yield-sequence/#sequence","text":"sequence is an abstraction for the async generator. It is not named async_generator to imply that it's just one implementation of the concept. template < typename T > class sequence final { public : class promise_type ; class iterator ; using value_type = T ; using reference = T & ; using pointer = T * ; }; sequence contains 2 sub types. The promise_type is for resumeable promise requirements. And the other( iterator ) is for iteration of elements.","title":"Sequence"},{"location":"yield-sequence/#template-parameters","text":"T : the type of element in the sequence.","title":"Template Parameters"},{"location":"yield-sequence/#default-operations","text":"Copy is disabled. A user code of its constructor must be generated by compiler, not the programmer. For now, the only guarantee for the type is that there is no leak at destruction. template < typename T > class sequence final { public : sequence ( sequence & ) = delete ; sequence & operator = ( sequence & ) = delete ; sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; }; It is expected that the user code will destroy the coroutine frame of the sequence manually . This is inconvenient but must be ensured like the following example. TEST_CASE ( \"async_generator\" , \"[generic]\" ) { using namespace std :: experimental ; // for async generator, // its coroutine frame must be alive for some case. return_frame frame {}; auto ensure_destroy_frame = gsl :: finally ([ = ]() { if ( auto coro = static_cast < coroutine_handle < void >> ( frame )) coro . destroy (); }); SECTION ( \"yield once\" ) { auto example = []() -> sequence < int > { int v = 333 ; co_yield v ; co_return ; }; auto use_sequence = [ = ]( int & ref ) -> return_frame { for co_await ( int v : example ()) ref = v ; co_return ; }; int value = 0 ; REQUIRE_NOTHROW ( frame = use_sequence ( value )); REQUIRE ( value == 333 ); } // ... }","title":"Default Operations"},{"location":"yield-sequence/#functions","text":"Function Description begin Start the sequence coroutine and fetch elements until co_yield receives some awaitable. end End of the sequence. template < typename T > class sequence final { public : class iterator ; public : iterator begin () noexcept ( false ); iterator end () noexcept ; };","title":"Functions"},{"location":"yield-sequence/#sub-types","text":"","title":"Sub Types"},{"location":"yield-sequence/#promise","text":"The type for resumable promise requirement. It manages yielded element and resumes the consumer coroutine(if it suspended). Function Description initial_suspend Return suspend_always final_suspend Return suspend_always return_void Notify the end of the sequence coroutine yield_value<Awaitable> Trigger suspend until the given Awaitable is resumed. yield_value Yield the given element and notify to consumer coroutine When the next element is unavailable, programmer suspend it by co_yield ing an awaitable. The promise_type allows to distinguish between the new element and programmer's awaitable by using itself as an awaitable. Function Description await_ready true if consumer is waiting for the sequence coroutine. await_suspend Save the sequence coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (user of the sequence ). template < typename T > class sequence final { public : class promise_type final { public : void unhandled_exception () noexcept ; auto get_return_object () noexcept -> promise_type * ; auto initial_suspend () const noexcept ; auto final_suspend () const noexcept ; promise_type & yield_value ( reference ref ) noexcept ; template < typename Awaitable > Awaitable & yield_value ( Awaitable && a ) noexcept ; void return_void () noexcept ; bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; void await_resume () noexcept ; }; public : sequence ( promise_type * ptr ) noexcept ; ~ sequence () noexcept ; };","title":"Promise"},{"location":"yield-sequence/#iterator","text":"Notice the iterator uses std::input_iterator_tag for its iterator_category . So once the iterater advances, it can't go back. Also, post increment is deleted to prevent ambiguous usage. Function Description operator++(int) Deleted operator++() Advance the iterator and try to fetch another element. Like normal iterator types, it supports * , -> , == , != . However, the iterator itself is an awaitable . Function Description await_ready false if the element is not available. true for the other case. await_suspend Save the current coroutine's context await_resume Continue one of the suspended coroutine. It can be both producer (the coroutine that returned sequence ) and consumer (this). template < typename T > class sequence final { public : class iterator final { public : iterator & operator ++ ( int ) = delete ; // post increment iterator & operator ++ () noexcept ( false ); bool await_ready () const noexcept ; void await_suspend ( handle_t rh ) noexcept ; iterator & await_resume () noexcept ; reference operator * () noexcept ; pointer operator -> () noexcept ; bool operator == ( const iterator & rhs ) const noexcept ; bool operator != ( const iterator & rhs ) const noexcept ; }; };","title":"Iterator"},{"location":"articles/awaitable-event/","text":"Awaitable Event using the Coroutine, epoll , and eventfd The note explains the detail of event in coroutine/concrt.h Summary Look & feel of the interface via test code . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); } Note Motivation It would be convenient if there is a simple event type for co_await operator. Linux system's eventfd might be able to do the work. Requirement The requirement for the event type is simple. It doesn\u2019t support copy construction/assignment It doesn\u2019t support move construction/assignment The type can\u2019t be inherited( final ) It can be an operand of co_await operator The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. The first 3 requirement is quite strict, but it\u2019s for simplicity. Normally it won\u2019t be that hazardous for move operation. But moving from coroutine\u2019s frame to another space is a tricky situation. So I\u2019ve banned move semantics to prevent misusage like that. Design Win32 API supports internal thread pool , but Linux system API does not. So user code has to poll those created events. Fortunately, Linux supports epoll to allow the behavior. We can derive 2 behavior constraint from the interface limitation. To acquire a list of signaled events, user code has to perform a polling operation Limitation from epoll \u2019s use-case User has to resume coroutines that are suspended for an event object Limitation from coroutine_handle<void> and absence of embedded thread pool/APC support This was the rough version of the interface type & function. // Awaitable event type. class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // it's lightweight ! public : event (); ~ event (); void set (); bool await_ready () const ; void await_suspend ( coroutine_handle < void > coro ); void await_resume (); }; // Enumerate all suspended coroutines that are waiting for signaled events. auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; coro::enumerable<T> is my own implementation of the generator<T> in <experimental/generator> state is a space for eventfd , and signaled_event_tasks performs polling operation on the epoll file descriptor. Concerns You may think about why I didn\u2019t adopt design like io_context in Boost ASIO . Which provides an explicit point of creation and polling operation. For instance, with Boost ASIO, user code must create objects(e.g, socket) via boost::asio::io_context object. // see: https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/allocation/server.cpp class server { private : boost :: asio :: io_context & io_context_ ; tcp :: acceptor acceptor_ ; public : server ( boost :: asio :: io_context & io_context , short port ) : io_context_ ( io_context ), acceptor_ ( io_context , tcp :: endpoint ( tcp :: v4 (), port )) // <------ { session_ptr new_session ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } void handle_accept ( session_ptr new_session , const boost :: system :: error_code & error ) { if ( ! error ) { new_session -> start (); } new_session . reset ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } }; int main ( int argc , char * argv []) { try { // ... boost :: asio :: io_context io_context ; // <------ server s ( io_context , atoi ( argv [ 1 ])); io_context . run (); // <------ } catch ( std :: exception & e ) { std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; } As you can see, such design enforces to use reference in construction like server \u2019s constructor. Since there might be multiple instances of server in one program, this is sound and appropriate. However, event is used in system level, and we don\u2019t have to consider the owner of event objects because it is always system itself. This is why I didn\u2019t designed some type like event_context . Therefore, it will be enough to replace io_context.run() to signaled_event_tasks() . Implementation Each description is based on the actual code. In this note, I will explain with a simplified code. (skip some header, exception spec, etc.) Wrapping epoll Polling epoll Event interface Event state managment Event await operations Wrapping epoll linux/event_poll.h linux/event_poll.cpp I don't prefer writing wrapper for the system API, but I have another feature(networking) that uses it. Before the start, if you're not familiar with epoll , I do recommend you to find some articles and read them first. (I'm sorry!) Ok, let me start ... The wrapper follows RAII and provides some member functions. try_add : add or modify given epoll_event using epoll_ctl remove : epoll_ctl with EPOLL_CTL_DEL wait : wait for epoll_event s and allows iterate them for each epoll_wait #include <fcntl.h> #include <sys/epoll.h> #include <unistd.h> struct event_poll_t final : no_copy_move { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () ; ~ event_poll_t () ; void try_add ( uint64_t fd , epoll_event & req ) ; void remove ( uint64_t fd ); auto wait ( int timeout ) -> coro :: enumerable < epoll_event > ; }; As you can expect, it internally allocates an array to receive events from epoll_wait event_poll_t :: event_poll_t () : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () { close ( epfd ); } With the RAII, epoll_ctl can be wrapped with exception throwing code. You might be able to write your own version if you hate using the exception. void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try again with mod goto TRY_OP ; } // failed throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl EPOLL_CTL_DEL\" }; } It's not that complicated :) Polling epoll linux/event_poll.cpp Since event_poll_t is internal type, it is free to co_yield internal type objects like epoll_event . Type for the wait timeout uses int instead of chrono::duration because epoll_wait allows negative( -1 ) timeout. auto event_poll_t :: wait ( int timeout ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } In another translation unit, signaled_event_tasks queries the event_poll_t and yield coroutine handles from the user data in epoll_event . // signaled event list event_poll_t selist {}; auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Ok, now user code will invoke the function to acquire coroutines with the signaled event. Since its return type is coroutine generator, they can use for statement like the following test code . TEST_CASE ( \"wait for one event\" , \"[event]\" ) { // ... for ( auto task : signaled_event_tasks ()) { task . resume (); // ... } // ... } Event interface coroutine/concrt.h Now, it's time to implement event type. I will write some private member functions for each of await_ready , await_suspend , and await_resume . You may ask why I'm not implementing await_* functions directly. Well, that's because I've met an issue that exporting await_* functions for DLL leads to an internal compiler error . At least vc140 and vc141 did in my experience. My approach is to export those interface functions as private and redirecting to them using public functions to allow co_await statement // note: // _INTERFACE_ is __declspec(dllexport) or __attribute__((visibility(\"default\"))) class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // <--- will explain in next section private : _INTERFACE_ void on_suspend ( task ) ; _INTERFACE_ bool is_ready () const ; _INTERFACE_ void on_resume () ; public : _INTERFACE_ event () ; _INTERFACE_ ~ event () ; // signal the event object _INTERFACE_ void set () ; // ... redirect to private member functions safely ... bool await_ready () const { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) { return this -> on_suspend ( coro ); } void await_resume () { return this -> on_resume (); } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Its member functions will be explained below. Before that, let's see how the type implemented constructor and destructor . It's not complicated! event :: event () : state {} { const auto fd = eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } You can see a weird function, get_eventfd . Event's state managment Just like the code above, event 's state is from eventfd function. However, we need a piece of information to estimate the event is signaled . class event final : no_copy_move { private : uint64_t state ; }; Instead of using an internal counter of eventfd , I used a bit mask to distinguish that the event object is signaled . Please follow the comments. I wrote carefully! // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) { return static_cast < int64_t > ( ~ emask & state ); } uint64_t make_signaled ( int64_t efd ) ; Was the comment enough? With those helper functions, set operation becomes really simple. void event :: set () { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); state = make_signaled ( fd ); // if it didn't throwed // it's signaled state from now } Let me remind you of one of the requirements. For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. Let's just assume that our event 's fd is already registered to epoll . To make epoll return this event in epoll_wait , we will use write . And, of course, bit masking must come after the success of the operation! uint64_t make_signaled ( int64_t efd ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd auto sz = write ( efd , & efd , sizeof ( efd )); if ( sz == - 1 ) throw system_error { errno , system_category (), \"write\" }; return emask | static_cast < uint64_t > ( efd ); } Remember that we flagged EFD_NONBLOCK for eventfd function in the constructor. It was intended :) Event's await operations The last part of the implementation is for co_await statement. await_ready and await_resume is simple with the masking function. bool event :: is_ready () const { return is_signaled ( state ); } void event :: on_resume () { // make non-signaled state this -> state = static_cast < decltype ( state ) > ( get_eventfd ( state )); } The transition to non-signaled state is based on the requirement. And after set member function, await_ready will return true and will bypass await_suspend . The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend . Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement . Now, our keystone function is like this. We declared global variable with event_poll_t type when writing signaled_event_tasks . When the coroutine enters await_suspend , we have to send the coroutine_handle<void> to the event_poll_t . // signaled event list. event_poll_t selist {}; void event :: on_suspend ( task t ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded // to `signaled_event_tasks` by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } Here, we use epoll_event 's user data to save the coroutine frame's address. Compare the code with the implementation of the signaled_event_tasks below. It constructs coroutine handle from e.data.ptr . auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Summary for the implementation It wasn't that hard to combine coroutine with epoll and evnetfd . Let's cover the event again. // event type uses `eventfd` and bit masking for state check class event final : no_copy_move { public : using task = coroutine_handle < void > ; // becomes user data of `epoll_event` private : uint64_t state ; // msb + file descriptor public : event (); // create fd with `eventfd` ~ event (); // `close` the fd // if it's signaled (msb is 1), no suspend bool await_ready (); // bind current fd to epoll // and its epoll_event will hold the coroutine's handle void await_suspend ( coroutine_handle < void > coro ); // make non-signaled (reset msb to 0) void await_resume (); // if there is a suspended coroutine, // it means that the event's fd is alreadty registered via `await_suspend` // so we will invoke `write` for the fd. // `epoll` in the `signaled_event_tasks` will report that using `epoll_wait` // if it's not suspended (== no waiting coroutine), // `write` on it won't matter void set (); }; the exported function signaled_event_tasks allows user code to acquire suspended(event-waiting) coroutines. It might be unsatisfying that those coroutines are not resumed automatically, but if we already have a main loop for event handling, this function can be placed at the point without concerns. // access to hidden(global) `epoll` and invoke `epoll_wait`. // `epoll_wait` will return `epoll_event`s with `coroutine_handle<void>` // this function extracts and yields them to caller auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Whoa, that's all for the implementation details. Conclusion Now we can write a coroutine code like the summary section. epoll and eventfd is simple enough to use, but almost all of their examples use thread(or system process). With the C++ 20 coroutine, we can use the pair in a more graceful manner . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } // we must enter the loop REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Awaitable event using the coroutine, epoll and eventfd"},{"location":"articles/awaitable-event/#awaitable-event-using-the-coroutine-epoll-and-eventfd","text":"The note explains the detail of event in coroutine/concrt.h","title":"Awaitable Event using the Coroutine, epoll, and eventfd"},{"location":"articles/awaitable-event/#summary","text":"Look & feel of the interface via test code . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Summary"},{"location":"articles/awaitable-event/#note","text":"","title":"Note"},{"location":"articles/awaitable-event/#motivation","text":"It would be convenient if there is a simple event type for co_await operator. Linux system's eventfd might be able to do the work.","title":"Motivation"},{"location":"articles/awaitable-event/#requirement","text":"The requirement for the event type is simple. It doesn\u2019t support copy construction/assignment It doesn\u2019t support move construction/assignment The type can\u2019t be inherited( final ) It can be an operand of co_await operator The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. The first 3 requirement is quite strict, but it\u2019s for simplicity. Normally it won\u2019t be that hazardous for move operation. But moving from coroutine\u2019s frame to another space is a tricky situation. So I\u2019ve banned move semantics to prevent misusage like that.","title":"Requirement"},{"location":"articles/awaitable-event/#design","text":"Win32 API supports internal thread pool , but Linux system API does not. So user code has to poll those created events. Fortunately, Linux supports epoll to allow the behavior. We can derive 2 behavior constraint from the interface limitation. To acquire a list of signaled events, user code has to perform a polling operation Limitation from epoll \u2019s use-case User has to resume coroutines that are suspended for an event object Limitation from coroutine_handle<void> and absence of embedded thread pool/APC support This was the rough version of the interface type & function. // Awaitable event type. class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // it's lightweight ! public : event (); ~ event (); void set (); bool await_ready () const ; void await_suspend ( coroutine_handle < void > coro ); void await_resume (); }; // Enumerate all suspended coroutines that are waiting for signaled events. auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; coro::enumerable<T> is my own implementation of the generator<T> in <experimental/generator> state is a space for eventfd , and signaled_event_tasks performs polling operation on the epoll file descriptor.","title":"Design"},{"location":"articles/awaitable-event/#concerns","text":"You may think about why I didn\u2019t adopt design like io_context in Boost ASIO . Which provides an explicit point of creation and polling operation. For instance, with Boost ASIO, user code must create objects(e.g, socket) via boost::asio::io_context object. // see: https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/example/cpp03/allocation/server.cpp class server { private : boost :: asio :: io_context & io_context_ ; tcp :: acceptor acceptor_ ; public : server ( boost :: asio :: io_context & io_context , short port ) : io_context_ ( io_context ), acceptor_ ( io_context , tcp :: endpoint ( tcp :: v4 (), port )) // <------ { session_ptr new_session ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } void handle_accept ( session_ptr new_session , const boost :: system :: error_code & error ) { if ( ! error ) { new_session -> start (); } new_session . reset ( new session ( io_context_ )); acceptor_ . async_accept ( new_session -> socket (), boost :: bind ( & server :: handle_accept , this , new_session , boost :: asio :: placeholders :: error )); } }; int main ( int argc , char * argv []) { try { // ... boost :: asio :: io_context io_context ; // <------ server s ( io_context , atoi ( argv [ 1 ])); io_context . run (); // <------ } catch ( std :: exception & e ) { std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; } As you can see, such design enforces to use reference in construction like server \u2019s constructor. Since there might be multiple instances of server in one program, this is sound and appropriate. However, event is used in system level, and we don\u2019t have to consider the owner of event objects because it is always system itself. This is why I didn\u2019t designed some type like event_context . Therefore, it will be enough to replace io_context.run() to signaled_event_tasks() .","title":"Concerns"},{"location":"articles/awaitable-event/#implementation","text":"Each description is based on the actual code. In this note, I will explain with a simplified code. (skip some header, exception spec, etc.) Wrapping epoll Polling epoll Event interface Event state managment Event await operations","title":"Implementation"},{"location":"articles/awaitable-event/#wrapping-epoll","text":"linux/event_poll.h linux/event_poll.cpp I don't prefer writing wrapper for the system API, but I have another feature(networking) that uses it. Before the start, if you're not familiar with epoll , I do recommend you to find some articles and read them first. (I'm sorry!) Ok, let me start ... The wrapper follows RAII and provides some member functions. try_add : add or modify given epoll_event using epoll_ctl remove : epoll_ctl with EPOLL_CTL_DEL wait : wait for epoll_event s and allows iterate them for each epoll_wait #include <fcntl.h> #include <sys/epoll.h> #include <unistd.h> struct event_poll_t final : no_copy_move { int epfd ; const size_t capacity ; std :: unique_ptr < epoll_event [] > events ; public : event_poll_t () ; ~ event_poll_t () ; void try_add ( uint64_t fd , epoll_event & req ) ; void remove ( uint64_t fd ); auto wait ( int timeout ) -> coro :: enumerable < epoll_event > ; }; As you can expect, it internally allocates an array to receive events from epoll_wait event_poll_t :: event_poll_t () : epfd { - 1 }, // use 2 page for polling capacity { 2 * getpagesize () / sizeof ( epoll_event )}, events { make_unique < epoll_event [] > ( capacity )} { epfd = epoll_create1 ( EPOLL_CLOEXEC ); if ( epfd < 0 ) throw system_error { errno , system_category (), \"epoll_create1\" }; } event_poll_t ::~ event_poll_t () { close ( epfd ); } With the RAII, epoll_ctl can be wrapped with exception throwing code. You might be able to write your own version if you hate using the exception. void event_poll_t :: try_add ( uint64_t _fd , epoll_event & req ) { int op = EPOLL_CTL_ADD , ec = 0 ; TRY_OP : ec = epoll_ctl ( epfd , op , _fd , & req ); if ( ec == 0 ) return ; if ( errno == EEXIST ) { op = EPOLL_CTL_MOD ; // already exists. try again with mod goto TRY_OP ; } // failed throw system_error { errno , system_category (), \"epoll_ctl\" }; } void event_poll_t :: remove ( uint64_t _fd ) { epoll_event req {}; // just prevent non-null input auto ec = epoll_ctl ( epfd , EPOLL_CTL_DEL , _fd , & req ); if ( ec != 0 ) throw system_error { errno , system_category (), \"epoll_ctl EPOLL_CTL_DEL\" }; } It's not that complicated :)","title":"Wrapping epoll"},{"location":"articles/awaitable-event/#polling-epoll","text":"linux/event_poll.cpp Since event_poll_t is internal type, it is free to co_yield internal type objects like epoll_event . Type for the wait timeout uses int instead of chrono::duration because epoll_wait allows negative( -1 ) timeout. auto event_poll_t :: wait ( int timeout ) -> coro :: enumerable < epoll_event > { auto count = epoll_wait ( epfd , events . get (), capacity , timeout ); if ( count == - 1 ) throw system_error { errno , system_category (), \"epoll_wait\" }; for ( auto i = 0 ; i < count ; ++ i ) { co_yield events [ i ]; } } In another translation unit, signaled_event_tasks queries the event_poll_t and yield coroutine handles from the user data in epoll_event . // signaled event list event_poll_t selist {}; auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } } Ok, now user code will invoke the function to acquire coroutines with the signaled event. Since its return type is coroutine generator, they can use for statement like the following test code . TEST_CASE ( \"wait for one event\" , \"[event]\" ) { // ... for ( auto task : signaled_event_tasks ()) { task . resume (); // ... } // ... }","title":"Polling epoll"},{"location":"articles/awaitable-event/#event-interface","text":"coroutine/concrt.h Now, it's time to implement event type. I will write some private member functions for each of await_ready , await_suspend , and await_resume . You may ask why I'm not implementing await_* functions directly. Well, that's because I've met an issue that exporting await_* functions for DLL leads to an internal compiler error . At least vc140 and vc141 did in my experience. My approach is to export those interface functions as private and redirecting to them using public functions to allow co_await statement // note: // _INTERFACE_ is __declspec(dllexport) or __attribute__((visibility(\"default\"))) class event final : no_copy_move { public : using task = coroutine_handle < void > ; private : uint64_t state ; // <--- will explain in next section private : _INTERFACE_ void on_suspend ( task ) ; _INTERFACE_ bool is_ready () const ; _INTERFACE_ void on_resume () ; public : _INTERFACE_ event () ; _INTERFACE_ ~ event () ; // signal the event object _INTERFACE_ void set () ; // ... redirect to private member functions safely ... bool await_ready () const { return this -> is_ready (); } void await_suspend ( coroutine_handle < void > coro ) { return this -> on_suspend ( coro ); } void await_resume () { return this -> on_resume (); } }; // Enumerate all suspended coroutines that are waiting for signaled events. _INTERFACE_ auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Its member functions will be explained below. Before that, let's see how the type implemented constructor and destructor . It's not complicated! event :: event () : state {} { const auto fd = eventfd ( 0 , EFD_NONBLOCK | EFD_CLOEXEC ); if ( fd == - 1 ) throw system_error { errno , system_category (), \"eventfd\" }; this -> state = fd ; // start with unsignaled state } event ::~ event () { // if already closed, fd == 0 if ( auto fd = get_eventfd ( state )) close ( fd ); } You can see a weird function, get_eventfd .","title":"Event interface"},{"location":"articles/awaitable-event/#events-state-managment","text":"Just like the code above, event 's state is from eventfd function. However, we need a piece of information to estimate the event is signaled . class event final : no_copy_move { private : uint64_t state ; }; Instead of using an internal counter of eventfd , I used a bit mask to distinguish that the event object is signaled . Please follow the comments. I wrote carefully! // // We are going to combine file descriptor and state bit // // On x86 system, // this won't matter since `int` is 32 bit. // we can safely use msb for state indicator. // // On x64 system, // this might be a hazardous since the value of `eventfd` can be corrupted. // **Normally** descriptor in Linux system grows from 3, so it is highly // possible to reach system limitation before the value consumes all 63 bit. // constexpr uint64_t emask = 1ULL << 63 ; // the msb(most significant bit) will be ... // 1 if the fd is signaled, // 0 on the other case bool is_signaled ( uint64_t state ) { return emask & state ; // msb is 1? } int64_t get_eventfd ( uint64_t state ) { return static_cast < int64_t > ( ~ emask & state ); } uint64_t make_signaled ( int64_t efd ) ; Was the comment enough? With those helper functions, set operation becomes really simple. void event :: set () { // already signaled. nothing to do... if ( is_signaled ( state )) // !!! under the race condition, this check is not safe !!! return ; auto fd = get_eventfd ( state ); state = make_signaled ( fd ); // if it didn't throwed // it's signaled state from now } Let me remind you of one of the requirements. For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend. Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement. Let's just assume that our event 's fd is already registered to epoll . To make epoll return this event in epoll_wait , we will use write . And, of course, bit masking must come after the success of the operation! uint64_t make_signaled ( int64_t efd ) { // signal the eventfd... // the message can be any value // since the purpose of it is to trigger the epoll // we won't care about the internal counter of the eventfd auto sz = write ( efd , & efd , sizeof ( efd )); if ( sz == - 1 ) throw system_error { errno , system_category (), \"write\" }; return emask | static_cast < uint64_t > ( efd ); } Remember that we flagged EFD_NONBLOCK for eventfd function in the constructor. It was intended :)","title":"Event's state managment"},{"location":"articles/awaitable-event/#events-await-operations","text":"The last part of the implementation is for co_await statement. await_ready and await_resume is simple with the masking function. bool event :: is_ready () const { return is_signaled ( state ); } void event :: on_resume () { // make non-signaled state this -> state = static_cast < decltype ( state ) > ( get_eventfd ( state )); } The transition to non-signaled state is based on the requirement. And after set member function, await_ready will return true and will bypass await_suspend . The event is stateful and has 2 states. Signaled Non-signaled For each state, the behavior is like the following Non-signaled: co_await will suspend the coroutine and becomes resumable when the event object is signaled. If the event is already signaled, the coroutine must not suspend . Signaled: co_await won\u2019t suspend and the event object becomes non-signaled state after the statement . Now, our keystone function is like this. We declared global variable with event_poll_t type when writing signaled_event_tasks . When the coroutine enters await_suspend , we have to send the coroutine_handle<void> to the event_poll_t . // signaled event list. event_poll_t selist {}; void event :: on_suspend ( task t ) { // just care if there was `write` for the eventfd // when it happens, coroutine handle will be forwarded // to `signaled_event_tasks` by epoll epoll_event req {}; req . events = EPOLLET | EPOLLIN | EPOLLONESHOT ; req . data . ptr = t . address (); // throws if `epoll_ctl` fails selist . try_add ( get_eventfd ( state ), req ); } Here, we use epoll_event 's user data to save the coroutine frame's address. Compare the code with the implementation of the signaled_event_tasks below. It constructs coroutine handle from e.data.ptr . auto signaled_event_tasks () -> coro :: enumerable < event :: task > { event :: task t {}; // it's an alias of `coroutine_handle<void>` for ( auto e : selist . wait ( 0 )) { // we don't care about the internal counter of eventfd. // just receive the coroutine handle t = event :: task :: from_address ( e . data . ptr ); co_yield t ; } }","title":"Event's await operations"},{"location":"articles/awaitable-event/#summary-for-the-implementation","text":"It wasn't that hard to combine coroutine with epoll and evnetfd . Let's cover the event again. // event type uses `eventfd` and bit masking for state check class event final : no_copy_move { public : using task = coroutine_handle < void > ; // becomes user data of `epoll_event` private : uint64_t state ; // msb + file descriptor public : event (); // create fd with `eventfd` ~ event (); // `close` the fd // if it's signaled (msb is 1), no suspend bool await_ready (); // bind current fd to epoll // and its epoll_event will hold the coroutine's handle void await_suspend ( coroutine_handle < void > coro ); // make non-signaled (reset msb to 0) void await_resume (); // if there is a suspended coroutine, // it means that the event's fd is alreadty registered via `await_suspend` // so we will invoke `write` for the fd. // `epoll` in the `signaled_event_tasks` will report that using `epoll_wait` // if it's not suspended (== no waiting coroutine), // `write` on it won't matter void set (); }; the exported function signaled_event_tasks allows user code to acquire suspended(event-waiting) coroutines. It might be unsatisfying that those coroutines are not resumed automatically, but if we already have a main loop for event handling, this function can be placed at the point without concerns. // access to hidden(global) `epoll` and invoke `epoll_wait`. // `epoll_wait` will return `epoll_event`s with `coroutine_handle<void>` // this function extracts and yields them to caller auto signaled_event_tasks () -> coro :: enumerable < event :: task > ; Whoa, that's all for the implementation details.","title":"Summary for the implementation"},{"location":"articles/awaitable-event/#conclusion","text":"Now we can write a coroutine code like the summary section. epoll and eventfd is simple enough to use, but almost all of their examples use thread(or system process). With the C++ 20 coroutine, we can use the pair in a more graceful manner . auto wait_for_one_event ( event & e , atomic_flag & flag ) -> no_return { try { // resume after the event is signaled ... co_await e ; } catch ( system_error & e ) { // event throws if there was an internal system error FAIL ( e . what ()); } flag . test_and_set (); } TEST_CASE ( \"wait for one event\" , \"[event]\" ) { event e1 {}; atomic_flag flag = ATOMIC_FLAG_INIT ; wait_for_one_event ( e1 , flag ); e1 . set (); auto count = 0 ; for ( auto task : signaled_event_tasks ()) { task . resume (); ++ count ; } // we must enter the loop REQUIRE ( count > 0 ); // already set by the coroutine `wait_for_one_event` REQUIRE ( flag . test_and_set () == true ); }","title":"Conclusion"},{"location":"articles/example-of-await_transform/","text":"Example: await_transform function of the promise_type Example code for await_transform . The code can be compiled with MSVC (v141) and Clang (6.0 or later). Compile the code with the Compiler Explorer! Clang: https://godbolt.org/z/EnNBrL MSVC: https://godbolt.org/z/eCVc6I Example // // Author : github.com/luncliff (luncliff@gmail.com) // // You can compile this code with MSVC (v19.14) and Clang (6.0 or later) // Be aware of the options: // clang: -fcoroutines-ts -stdlib=libc++ -std=c++2a // msvc : /await // #include <experimental/coroutine> using namespace std :: experimental ; #ifdef __clang__ using namespace std :: experimental :: coroutines_v1 ; // The definition is from // <experimental/resumable> in VC++ class suspend_if { bool cond ; public : suspend_if ( bool c ) : cond { c }{}; bool await_ready () const noexcept { return cond ; } void await_suspend ( coroutine_handle < void > ) noexcept {} void await_resume () noexcept {} }; #endif // end: clang compiler struct return_transform { struct promise_type { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_never {}; } auto get_return_object () -> promise_type * { return this ; } // Since `bool` is primitive type, it can't support operations // like `await_ready`, `await_suspend`, `await_resume` // However, we can provide `await_transform` for // `co_await` operator to receive well-formed awaitable type auto await_transform ( bool cond ) noexcept { return suspend_if { cond }; } // for `co_return` void return_void () noexcept {} // exception handling is important ! void unhandled_exception (){} }; return_transform ( promise_type * ) noexcept {} ~ return_transform () noexcept = default ; }; auto example () -> return_transform { co_await true ; // co_await p.await_transform(true); co_await false ; // co_await p.await_transform(false); co_return ; // p.return_void(); // goto __final_suspend_point; }","title":"Example: `await_transform` function of the `promise_type`"},{"location":"articles/example-of-await_transform/#example-await_transform-function-of-the-promise_type","text":"Example code for await_transform . The code can be compiled with MSVC (v141) and Clang (6.0 or later). Compile the code with the Compiler Explorer! Clang: https://godbolt.org/z/EnNBrL MSVC: https://godbolt.org/z/eCVc6I","title":"Example: await_transform function of the promise_type"},{"location":"articles/example-of-await_transform/#example","text":"// // Author : github.com/luncliff (luncliff@gmail.com) // // You can compile this code with MSVC (v19.14) and Clang (6.0 or later) // Be aware of the options: // clang: -fcoroutines-ts -stdlib=libc++ -std=c++2a // msvc : /await // #include <experimental/coroutine> using namespace std :: experimental ; #ifdef __clang__ using namespace std :: experimental :: coroutines_v1 ; // The definition is from // <experimental/resumable> in VC++ class suspend_if { bool cond ; public : suspend_if ( bool c ) : cond { c }{}; bool await_ready () const noexcept { return cond ; } void await_suspend ( coroutine_handle < void > ) noexcept {} void await_resume () noexcept {} }; #endif // end: clang compiler struct return_transform { struct promise_type { auto initial_suspend (){ return suspend_never {}; } auto final_suspend (){ return suspend_never {}; } auto get_return_object () -> promise_type * { return this ; } // Since `bool` is primitive type, it can't support operations // like `await_ready`, `await_suspend`, `await_resume` // However, we can provide `await_transform` for // `co_await` operator to receive well-formed awaitable type auto await_transform ( bool cond ) noexcept { return suspend_if { cond }; } // for `co_return` void return_void () noexcept {} // exception handling is important ! void unhandled_exception (){} }; return_transform ( promise_type * ) noexcept {} ~ return_transform () noexcept = default ; }; auto example () -> return_transform { co_await true ; // co_await p.await_transform(true); co_await false ; // co_await p.await_transform(false); co_return ; // p.return_void(); // goto __final_suspend_point; }","title":"Example"},{"location":"articles/thread-selecting-function/","text":"Function that selects its thread using the coroutine WandBox + Clang 6.0.1 Main // // Author: luncliff@gmail.com // #include \"return.h\" #include \"coro_queue.h\" #include <future> #include <thread> using namespace std :: experimental ; using namespace std :: experimental :: coroutines_v1 ; using namespace std :: chrono ; using namespace std :: chrono_literals ; void coro_worker ( coro_queue * q ); auto program ( coro_queue & fq , coro_queue & bq ) -> return_ignore ; void print_thread_id ( const char * label ); auto fg = make_queue (); // queue for foreground auto bg = make_queue (); // queue for background int main ( int , char * []) { // launch background worker auto fb = std :: async ( std :: launch :: async , // immediately coro_worker , bg . get ()); { program ( * fg , * bg ); // start the program } coro_worker ( fg . get ()); // run foreground worker fb . get (); // clean-up or join thread } // the program switches over threads using queue. // see the program output !! auto program ( coro_queue & foreground , // coro_queue & background ) -> return_ignore { using namespace std ; print_thread_id ( \"invoke\" ); auto repeat = 3 ; while ( repeat -- ) { co_await foreground ; print_thread_id ( \"front\" ); co_await background ; print_thread_id ( \"back\" ); } print_thread_id ( \"return\" ); co_return ; } void coro_worker ( coro_queue * q ) { auto coro = coroutine_handle < void > {}; // repeat count to prevent infinite loop auto repeat = 10 ; while ( repeat -- ) // resume incoming coroutines if ( q -> try_pop ( coro ) == false ) // if queue is empty, wait. std :: this_thread :: sleep_for ( 10 ms ); else { if ( coro . done ()) coro . destroy (); else coro . resume (); } } Coro Queue Header #ifndef EXAMPLE_CORO_QUEUE_H #define EXAMPLE_CORO_QUEUE_H #include <experimental/coroutine> #include <memory> using namespace std :: experimental ; using namespace std :: experimental :: coroutines_v1 ; struct coro_queue { virtual ~ coro_queue () noexcept = default ; virtual void push ( coroutine_handle < void > rh ) = 0 ; virtual bool try_pop ( coroutine_handle < void >& rh ) = 0 ; }; extern auto make_queue () -> std :: unique_ptr < coro_queue > ; inline auto operator co_await ( coro_queue & q ) noexcept { class awaiter : public suspend_always { coro_queue * queue ; public : awaiter ( coro_queue & ref ) noexcept // : queue { std :: addressof ( ref )} { } ~ awaiter () noexcept = default ; void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { queue -> push ( rh ); } }; return awaiter { q }; } #endif // EXAMPLE_CORO_QUEUE_H Implementation #include \"coro_queue.h\" #include <mutex> #include <queue> using namespace std ; struct queue_v2 : coro_queue { using coro_task_t = coroutine_handle < void > ; mutex mtx {}; queue < coro_task_t > que {}; public : void push ( coroutine_handle < void > rh ) override ; bool try_pop ( coroutine_handle < void >& rh ) override ; }; void queue_v2 :: push ( coroutine_handle < void > rh ) { lock_guard lck { mtx }; que . push ( rh ); } bool queue_v2 :: try_pop ( coroutine_handle < void >& rh ) { lock_guard lck { mtx }; if ( que . empty ()) { rh = nullptr ; return false ; } else { rh = que . front (); que . pop (); return true ; } } auto make_queue () -> std :: unique_ptr < coro_queue > { return std :: make_unique < queue_v2 > (); } Return Type for Coroutine // // Author: luncliff@gmail.com // // The code is from the repository // - github.com/luncliff/coroutine // #ifndef COROUTINE_RETURN_TYPES_H #define COROUTINE_RETURN_TYPES_H #include <experimental/coroutine> using namespace std :: experimental ; using namespace std :: experimental :: coroutines_v1 ; class return_ignore final { public : class promise_type final { public : auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { } void unhandled_exception () noexcept ( false ) { std :: terminate (); } promise_type * get_return_object () noexcept { return this ; } }; public : return_ignore ( const promise_type * ) noexcept { } }; #endif // COROUTINE_RETURN_TYPES_H Print Thread ID // // Author: luncliff@gmail.com // #include <thread> #include <iostream> void print_thread_id ( const char * label ) { using namespace std ; cout << label << \" \\t \" << this_thread :: get_id () << endl ; }","title":"Function that selects its thread using the coroutine"},{"location":"articles/thread-selecting-function/#function-that-selects-its-thread-using-the-coroutine","text":"WandBox + Clang 6.0.1","title":"Function that selects its thread using the coroutine"},{"location":"articles/thread-selecting-function/#main","text":"// // Author: luncliff@gmail.com // #include \"return.h\" #include \"coro_queue.h\" #include <future> #include <thread> using namespace std :: experimental ; using namespace std :: experimental :: coroutines_v1 ; using namespace std :: chrono ; using namespace std :: chrono_literals ; void coro_worker ( coro_queue * q ); auto program ( coro_queue & fq , coro_queue & bq ) -> return_ignore ; void print_thread_id ( const char * label ); auto fg = make_queue (); // queue for foreground auto bg = make_queue (); // queue for background int main ( int , char * []) { // launch background worker auto fb = std :: async ( std :: launch :: async , // immediately coro_worker , bg . get ()); { program ( * fg , * bg ); // start the program } coro_worker ( fg . get ()); // run foreground worker fb . get (); // clean-up or join thread } // the program switches over threads using queue. // see the program output !! auto program ( coro_queue & foreground , // coro_queue & background ) -> return_ignore { using namespace std ; print_thread_id ( \"invoke\" ); auto repeat = 3 ; while ( repeat -- ) { co_await foreground ; print_thread_id ( \"front\" ); co_await background ; print_thread_id ( \"back\" ); } print_thread_id ( \"return\" ); co_return ; } void coro_worker ( coro_queue * q ) { auto coro = coroutine_handle < void > {}; // repeat count to prevent infinite loop auto repeat = 10 ; while ( repeat -- ) // resume incoming coroutines if ( q -> try_pop ( coro ) == false ) // if queue is empty, wait. std :: this_thread :: sleep_for ( 10 ms ); else { if ( coro . done ()) coro . destroy (); else coro . resume (); } }","title":"Main"},{"location":"articles/thread-selecting-function/#coro-queue","text":"","title":"Coro Queue"},{"location":"articles/thread-selecting-function/#header","text":"#ifndef EXAMPLE_CORO_QUEUE_H #define EXAMPLE_CORO_QUEUE_H #include <experimental/coroutine> #include <memory> using namespace std :: experimental ; using namespace std :: experimental :: coroutines_v1 ; struct coro_queue { virtual ~ coro_queue () noexcept = default ; virtual void push ( coroutine_handle < void > rh ) = 0 ; virtual bool try_pop ( coroutine_handle < void >& rh ) = 0 ; }; extern auto make_queue () -> std :: unique_ptr < coro_queue > ; inline auto operator co_await ( coro_queue & q ) noexcept { class awaiter : public suspend_always { coro_queue * queue ; public : awaiter ( coro_queue & ref ) noexcept // : queue { std :: addressof ( ref )} { } ~ awaiter () noexcept = default ; void await_suspend ( coroutine_handle < void > rh ) noexcept ( false ) { queue -> push ( rh ); } }; return awaiter { q }; } #endif // EXAMPLE_CORO_QUEUE_H","title":"Header"},{"location":"articles/thread-selecting-function/#implementation","text":"#include \"coro_queue.h\" #include <mutex> #include <queue> using namespace std ; struct queue_v2 : coro_queue { using coro_task_t = coroutine_handle < void > ; mutex mtx {}; queue < coro_task_t > que {}; public : void push ( coroutine_handle < void > rh ) override ; bool try_pop ( coroutine_handle < void >& rh ) override ; }; void queue_v2 :: push ( coroutine_handle < void > rh ) { lock_guard lck { mtx }; que . push ( rh ); } bool queue_v2 :: try_pop ( coroutine_handle < void >& rh ) { lock_guard lck { mtx }; if ( que . empty ()) { rh = nullptr ; return false ; } else { rh = que . front (); que . pop (); return true ; } } auto make_queue () -> std :: unique_ptr < coro_queue > { return std :: make_unique < queue_v2 > (); }","title":"Implementation"},{"location":"articles/thread-selecting-function/#return-type-for-coroutine","text":"// // Author: luncliff@gmail.com // // The code is from the repository // - github.com/luncliff/coroutine // #ifndef COROUTINE_RETURN_TYPES_H #define COROUTINE_RETURN_TYPES_H #include <experimental/coroutine> using namespace std :: experimental ; using namespace std :: experimental :: coroutines_v1 ; class return_ignore final { public : class promise_type final { public : auto initial_suspend () noexcept { return suspend_never {}; } auto final_suspend () noexcept { return suspend_never {}; } void return_void () noexcept { } void unhandled_exception () noexcept ( false ) { std :: terminate (); } promise_type * get_return_object () noexcept { return this ; } }; public : return_ignore ( const promise_type * ) noexcept { } }; #endif // COROUTINE_RETURN_TYPES_H","title":"Return Type for Coroutine"},{"location":"articles/thread-selecting-function/#print-thread-id","text":"// // Author: luncliff@gmail.com // #include <thread> #include <iostream> void print_thread_id ( const char * label ) { using namespace std ; cout << label << \" \\t \" << this_thread :: get_id () << endl ; }","title":"Print Thread ID"},{"location":"ppt/Exploring-the-Cpp-Coroutine/","text":"Exploring the C++ Coroutine: Approach, Compiler, and Issues Note I had a presentation in C++ Korea Facebook Group 's 5th Seminar . You can download and share it :) Links PDF: Exploring The C++ Coroutine / \ud55c\uad6d\uc5b4 OneDrive: Eng / \ud55c\uad6d\uc5b4","title":"PPT - C++ Korea 5th Seminar"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#exploring-the-c-coroutine-approach-compiler-and-issues","text":"","title":"Exploring the C++ Coroutine: Approach, Compiler, and Issues"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#note","text":"I had a presentation in C++ Korea Facebook Group 's 5th Seminar . You can download and share it :)","title":"Note"},{"location":"ppt/Exploring-the-Cpp-Coroutine/#links","text":"PDF: Exploring The C++ Coroutine / \ud55c\uad6d\uc5b4 OneDrive: Eng / \ud55c\uad6d\uc5b4","title":"Links"}]}